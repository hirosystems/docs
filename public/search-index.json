[
  {
    "title": "Contributors guide",
    "description": "Learn how to contribute to Hiro's documentation and content.",
    "slug": "/stacks/contributors-guide",
    "content": "\nimport ContributorsGuideContent from '@/content/_shared/contributors-guide.mdx';\n\n<ContributorsGuideContent components={props.components} />\n"
  },
  {
    "title": "Introduction",
    "description": "Get started with the Stacks ecosystem.",
    "slug": "/stacks/get-started",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nLFG!\n\n## Related tools\n\n- **[Clarinet](/stacks/clarinet)**: Build your app in a local environment on Stacks.\n- **[Stacks.js](/stacks/stacks.js)**: Don’t reinvent the wheel and build faster with a JS library that handles basic blockchain functionality.\n- **[Stacks Blockchain API](/stacks/api)**: Fetch data and broadcast transactions with the Stacks Blockchain API.\n\n<br />\n\n<Callout title=\"Need help building with Clarinet JS SDK?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#clarinet</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>"
  },
  {
    "title": "Rate limiting",
    "description": "Understand the rate limits for Hiro APIs and the STX Faucet.",
    "slug": "/stacks/rate-limiting",
    "content": "\nimport RateLimitingContent from '@/content/_shared/rate-limiting.mdx';\n\n<RateLimitingContent components={props.components} />\n"
  },
  {
    "title": "Simnet",
    "description": "The Simnet class is the main entry point for the Clarinet JS SDK. It provides properties and methods for interacting with the Clarinet network.",
    "slug": "/stacks/clarinet-js-sdk/references/simnet",
    "content": "\nimport {\n  Accordion,\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"@/components/ui/accordion\"\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\n# `initSimnet`\n\nThe `initSimnet` function initializes a simulated network. It will often be the first function you call when using the SDK.\n\n## Parameters\n\nThe `manifestPath` is the path to the `Clarinet.toml` manifest file.\n\n  <Tabs defaultValue=\"default\">\n    <TabsList className='flex flex-wrap'>\n      <TabsTrigger value=\"default\" className='tab group'>\n        <Badge className='transition-colors'>Creating a new instance of simnet</Badge>\n      </TabsTrigger>\n      <TabsTrigger value=\"custom\" className='tab group'>\n        <Badge className='badge transition-colors'>With a custom config path</Badge>\n      </TabsTrigger>\n    </TabsList>\n    <TabsContent value=\"default\">\n      ```ts\n      import { initSimnet } from '@hirosystems/clarinet-sdk';\n\n      const simnet = await initSimnet();\n      ```\n    </TabsContent>\n    <TabsContent value=\"custom\">\n      ```ts\n      import { initSimnet } from '@hirosystems/clarinet-sdk';\n\n      const simnet = await initSimnet('./config/Clarinet.toml');\n      ```\n    </TabsContent>\n  </Tabs>\n\n  <Accordion type=\"single\" collapsible className=\"w-full\">\n    <AccordionItem value=\"schema\">\n      <AccordionTrigger>Schema</AccordionTrigger>\n      <AccordionContent>\n        ```ts\n        initSimnet(manifestPath?: string): Promise<Simnet>\n        ```\n      </AccordionContent>\n    </AccordionItem>\n  </Accordion>"
  },
  {
    "title": "Properties",
    "description": "The Clarinet JS SDK provides properties that can be used to interact with simnet.",
    "slug": "/stacks/clarinet-js-sdk/references/properties",
    "content": "\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\n\n\n# `blockHeight`\n\nReturns the current block height of simnet.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the current block height</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const currentBlockHeight = simnet.blockHeight;\n    ```\n  </TabsContent>\n</Tabs>\n\n<Accordions>\n  <Accordion title=\"Response\">\n    ```ts\n    1\n    ```\n  </Accordion>\n</Accordions>\n\n\n# `deployer`\n\nReturns the default deployer address as defined in the project file.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the deployer address</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"set-deployer\" className='tab group'>\n      <Badge className='badge transition-colors'>Setting the deployer to a new address</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const currentDeployerAddress = simnet.deployer;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"set-deployer\">\n    ```ts\n    simnet.deployer = 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5';\n    const newDeployer = simnet.deployer\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `currentEpoch`\n\nReturns the current epoch of simnet.\n\nThis represents the Stacks blockchain's progress through discrete time periods, cycles, or upgrades.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the current epoch of simnet</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const epoch = simnet.currentEpoch;\n    ```\n  </TabsContent>\n</Tabs>\n\n<Accordions>\n  <Accordion title=\"Response\">\n    ```ts\n    2.5\n    ```\n  </Accordion>\n</Accordions>\n\n"
  },
  {
    "title": "Custom Matchers",
    "description": "A set of Vitest matchers that can be used to make assertions on Clarity values with the Clarinet JS SDK.",
    "slug": "/stacks/clarinet-js-sdk/references/custom-matchers",
    "content": "\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\n\n\n# `toHaveClarityType`\n\nCheck that a value has the right Clarity type, without checking its value.\n\n## Parameters\n\n\nThe Clarity type that the expected value should have.\n\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an ok response</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callPublicFn(\n      'counter',\n      'increment',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toHaveClarityType(ClarityType.ResponseOk);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity counter.clar\n      (define-data-var count uint u0)\n\n      (define-public (increment)\n        (begin\n          (var-set count (+ (var-get count) u1))\n          (ok (var-get count))\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toHaveClarityType(expectedType: ClarityType)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeOk`\n\nCheck that a response is `(ok <ok-type>)` and has the expected value. Any Clarity value can be passed.\n\n## Parameters\n\n\nThe `ClarityValue` that the expected value should have.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an ok response with a specific value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callPublicFn(\n      'counter',\n      'increment',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeOk(Cl.uint(1));\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity counter.clar\n      (define-data-var count uint u0)\n\n      (define-public (increment)\n        (begin\n          (var-set count (+ (var-get count) u1))\n          (ok (var-get count))\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeOk(expected: ClarityValue)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeErr`\n\nCheck that a response is `(err <error-type>)` and has the expected value. Any Clarity value can be passed.\n\n## Parameters\n\n\nThe `ClarityValue` that the expected value should have.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an err response with a specific value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callPublicFn(\n      'counter',\n      'add',\n      [Cl.uint(19)],\n      simnet.deployer\n    );\n\n    expect(result).toBeErr(Cl.uint(500));\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity counter.clar\n      (define-constant TOO_BIG u10)\n      (define-data-var count uint u0)\n\n      (define-public (add (amount uint))\n        (begin\n          (let ((new-count (+ (var-get count) amount)))\n            (if (<= new-count TOO_BIG)\n              (begin\n                (var-set count new-count)\n                (ok (var-get count))\n              )\n              (err u500)\n            )\n          )\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeErr(expected: ClarityValue)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n# `toBeSome`\n\nCheck that a response is `(some <value>)` and has the expected value. Any Clarity value can be passed.\n\n## Parameters\n\n\nThe `ClarityValue` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an optional value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'pool',\n      'get-participant',\n      [Cl.standardPrincipal('ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5')],\n      simnet.deployer\n    );\n\n    expect(result).toBeSome(Cl.bool(true));\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity pool.clar\n      (define-map Participants principal bool)\n      (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n      (define-read-only (get-participant (who principal))\n        (map-get? ParticipantStatus who)\n      )\n\n      (map-set Participants 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 true)\n      (map-set ParticipantStatus 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 { enrollmentBlock: u1, contributionAmount: u19000000 })\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeSome(expected: ClarityValue)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `toBeNone`\n\nCheck that a response is `(none)`.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a none value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'pool',\n      'get-participant',\n      [Cl.standardPrincipal('ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5')],\n      simnet.deployer\n    );\n\n    expect(result).toBeNone();\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity pool.clar\n      (define-map Participants principal bool)\n      (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n      (define-read-only (get-participant (who principal))\n        (map-get? ParticipantStatus who)\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeNone()\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `toBeBool`\n\nAsserts the value of Clarity boolean (`true` or `false`).\n\n## Parameters\n\n\nThe `boolean` that the expected value should have.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a boolean value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'pool',\n      'has-contributed',\n      [Cl.standardPrincipal('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM')],\n      simnet.deployer\n    );\n\n    expect(result).toBeBool(true);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity pool.clar\n      (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n      (define-read-only (has-contributed (who principal))\n        (is-some (get contributionAmount (map-get? ParticipantStatus who)))\n      )\n\n      (map-set ParticipantStatus tx-sender { enrollmentBlock: u1, contributionAmount: u19000000 })\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeBool(expected: boolean)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `toBeInt`\n\nAsserts the value of a Clarity integer.\n\n## Parameters\n\n\nThe `integer` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an integer value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'counter',\n      'increment',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeInt(1); // or `1n`\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity counter.clar\n      (define-data-var count int 0)\n\n      (define-public (increment)\n        (begin\n          (var-set count (+ (var-get count) 1))\n          (ok (var-get count))\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeInt(expected: number | bigint)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeUint`\n\nAsserts the value of a Clarity unsigned integer.\n\n## Parameters\n\n\nThe `unsigned integer` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an unsigned integer value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'counter',\n      'increment',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeUint(1); // or `1n`\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity counter.clar\n      (define-data-var count uint u0)\n\n      (define-public (increment)\n        (begin\n          (var-set count (+ (var-get count) u1))\n          (ok (var-get count))\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeUint(expected: number | bigint)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeAscii`\n\nAsserts the value of a Clarity string-ascii.\n\n## Parameters\n\n\nThe `string` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a string-ascii value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'hello-world',\n      'say-hi',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeAscii('Hello World');\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity hello-world.clar\n      (define-read-only (say-hi)\n        \"Hello World\"\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeAscii(expected: string)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeUtf8`\n\nAsserts the value of a Clarity string-utf8.\n\n## Parameters\n\n\nThe `string` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a string-utf8 value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'hello-world',\n      'say-hi',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeUtf8('Hello World');\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity hello-world.clar\n      (define-read-only (say-hi)\n        u\"Hello World\"\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeUtf8(expected: string)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBePrincipal`\n\nAsserts the value of a Clarity principal.\n\nThe principal can be a standard or a contract principal.\n\n## Parameters\n\n\nThe `string` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a standard principal</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"options\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a contract principal</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const deployer = simnet.deployer;\n\n    expect(Cl.standardPrincipal(deployer)).toBePrincipal(deployer);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBePrincipal(expected: string) \n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"options\">\n    ```ts\n    const contract = `${simnet.deployer}.hello-world`;\n\n    expect(Cl.contractPrincipal(contract)).toBePrincipal(contract);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBePrincipal(expected: string)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeBuff`\n\nAsserts the value of a Clarity buffer. It takes an ArrayBuffer as an input.\n\nFor building a buffer, `@stacks/transactions` provides some helper functions:\n\n- `bufferFromAscii`\n- `bufferFromUtf8`\n- `bufferFromHex`\n\n## Parameters\n\n\nThe `Uint8Array` buffer that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a Uint8Array buffer</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"ascii\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an ASCII string buffer</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"hex\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a hex string buffer</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'helpers',\n      'get-byte-array',\n      [],\n      simnet.deployer\n    );\n\n    const buffer = Uint8Array.from([1, 2, 3, 4]);\n    expect(result).toBeBuff(buffer);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity helpers.clar\n      (define-constant BUFFER 0x01020304)\n\n      (define-read-only (get-byte-array)\n        BUFFER\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeBuff(expected: Uint8Array)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"ascii\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const { result } = simnet.callReadOnlyFn(\n      'helpers',\n      'get-btc-buffer',\n      [],\n      simnet.deployer\n    );\n\n    const btc = Cl.bufferFromAscii('btc'); // or Cl.bufferFromUtf8('btc')\n\n    expect(result).toBeBuff(btc.buffer);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity helpers.clar\n      (define-constant ASCII_BTC 0x627463)\n\n      (define-read-only (get-btc-buffer)\n        ASCII_BTC\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeBuff(expected: Uint8Array)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"hex\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const { result } = simnet.callReadOnlyFn(\n      \"helpers\",\n      \"get-tx-hash\",\n      [],\n      simnet.deployer\n    );\n\n    const tx = Cl.bufferFromHex(\n      \"73e951acd451060f13bdab7bd947136efd80511309a295e876a682ab8a423a7e\"\n    );\n\n    expect(result).toBeBuff(tx.buffer);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity helpers.clar\n      (define-constant TX_HASH 0x73e951acd451060f13bdab7bd947136efd80511309a295e876a682ab8a423a7e)\n\n      (define-read-only (get-tx-hash)\n        TX_HASH\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeBuff(expected: Uint8Array)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeList`\n\nAsserts the value of a Clarity list containing an array of Clarity values.\n\n## Parameters\n\n\nThe `Uint8Array` buffer that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a list of Clarity values</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const { result } = simnet.callReadOnlyFn(\n      'helpers',\n      'get-addresses',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeList(\n      [\n        Cl.standardPrincipal('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM'),\n        Cl.standardPrincipal('ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5'),\n        Cl.standardPrincipal('ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG')\n      ]\n    );\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity helpers.clar\n      (define-read-only (get-addresses)\n        (list\n          'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n          'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\n          'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeList(expected: ClarityValue[])\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeTuple`\n\nAsserts the value of a Clarity tuple.\n\n## Parameters\n\n\nThe `object` of Clarity values that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a tuple</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n    \n    const { result } = simnet.callReadOnlyFn(\n      'pool',\n      'get-participant-data',\n      [Cl.standardPrincipal(simnet.deployer)],\n      simnet.deployer\n    );\n\n    expect(result).toBeTuple({\n      enrollmentBlock: Cl.some(Cl.uint(1)),\n      contributionAmount: Cl.some(Cl.uint(19000000)),\n    });\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity pool.clar\n      (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n      (define-read-only (get-participant (who principal))\n        (map-get? ParticipantStatus who)\n      )\n\n      (define-read-only (get-participant-data (who principal))\n        {\n          enrollmentBlock: (get enrollmentBlock (map-get? ParticipantStatus who)),\n          contributionAmount: (get contributionAmount (map-get? ParticipantStatus who))\n        }\n      )\n\n      (map-set ParticipantStatus tx-sender { enrollmentBlock: u1, contributionAmount: u19000000 })\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeTuple(expected: Record<string, ClarityValue>)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n"
  },
  {
    "title": "Methods",
    "description": "The Clarinet JS SDK provides several methods that can be used to interact with simnet.",
    "slug": "/stacks/clarinet-js-sdk/references/methods",
    "content": "\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\n\n\n# `getAccounts`\n\nRetrieve a list of all Stacks addresses configured within the project, including wallets, deployers, and faucets.\n\n\n\n\n<Tabs defaultValue=\"get-accounts\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"get-accounts\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting your accounts</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"get-account\" className='tab group'>\n      <Badge className='badge transition-colors'>Selecting a specific account</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"get-accounts\">\n    ```ts\n    const accounts = simnet.getAccounts();\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        Map(10) {\n          \"wallet_7\": \"ST3PF13W7Z0RRM42A8VZRVFQ75SV1K26RXEP8YGKJ\",\n          \"wallet_1\": \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\",\n          \"wallet_3\": \"ST2JHG361ZXG51QTKY2NQCVBPPRRE2KZB1HR05NNC\",\n          \"wallet_5\": \"ST2REHHS5J3CERCRBEPMGH7921Q6PYKAADT7JP2VB\",\n          \"wallet_8\": \"ST3NBRSFKX28FQ2ZJ1MAKX58HKHSDGNV5N7R21XCP\",\n          \"wallet_4\": \"ST2NEB84ASENDXKYGJPQW86YXQCEFEX2ZQPG87ND\",\n          \"deployer\": \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\",\n          \"wallet_6\": \"ST3AM1A56AK2C1XAFJ4115ZSV26EB49BVQ10MGCS0\",\n          \"wallet_2\": \"ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG\",\n          \"faucet\": \"STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6\",\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAccounts(): Map<string, string>\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"get-account\">\n    ```ts\n    const accounts = simnet.getAccounts();\n\n    const wallet = accounts.get('wallet_1')!;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAccounts(): Map<string, string>\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `getAssetsMap`\n\nRetrieve a list of asset balances associated with Stacks addresses, including fungible and non-fungible tokens.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting STX account balances</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"get-ft-balance\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting ft balances</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"get-nft-balance\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting nft balances</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"get-deployer-balance\" className='tab group'>\n      <Badge className='badge transition-colors'>Filtering for an account</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const assets = simnet.getAssetsMap();\n\n    const stxBalances = assets.get('STX')!;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        Map(10) {\n          \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\": 100000000000000n,\n          \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\": 100000000000000n,\n          \"ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG\": 100000000000000n,\n          \"ST2JHG361ZXG51QTKY2NQCVBPPRRE2KZB1HR05NNC\": 100000000000000n,\n          \"ST2NEB84ASENDXKYGJPQW86YXQCEFEX2ZQPG87ND\": 100000000000000n,\n          \"ST2REHHS5J3CERCRBEPMGH7921Q6PYKAADT7JP2VB\": 100000000000000n,\n          \"ST3AM1A56AK2C1XAFJ4115ZSV26EB49BVQ10MGCS0\": 100000000000000n,\n          \"ST3NBRSFKX28FQ2ZJ1MAKX58HKHSDGNV5N7R21XCP\": 100000000000000n,\n          \"ST3PF13W7Z0RRM42A8VZRVFQ75SV1K26RXEP8YGKJ\": 100000000000000n,\n          \"STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6\": 100000000000000n,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAssetsMap(): Map<string, Map<string, bigint>>\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"get-ft-balance\">\n    ```ts\n    const contractName = 'token';\n    const sourceCode = `\n      (define-fungible-token sbtc)\n      (ft-mint? sbtc u19 tx-sender)\n    `;\n\n    simnet.deployContract(\n      contractName,\n      sourceCode,\n      null,\n      simnet.deployer\n    );\n\n    const assets = simnet.getAssetsMap();\n\n    const tokenBalance = assets.get('.token.sbtc')!;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        Map(1) {\n          \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\": 19n,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAssetsMap(): Map<string, Map<string, bigint>>\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"get-nft-balance\">\n    ```ts\n    const contractName = 'nft';\n    const sourceCode = `\n      (define-non-fungible-token ticket uint)\n      (nft-mint? ticket u42 tx-sender)\n    `;\n\n    simnet.deployContract(\n      contractName,\n      sourceCode,\n      null,\n      simnet.deployer\n    );\n\n    const assets = simnet.getAssetsMap();\n\n    const nftBalance = assets.get('.nft.ticket')!;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        Map(1) {\n          \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\": 1n,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAssetsMap(): Map<string, Map<string, bigint>>\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"get-deployer-balance\">\n    ```ts\n    const assets = simnet.getAssetsMap();\n    const stxBalances = assets.get('STX')!;\n\n    const deployerBalance = stxBalances.get('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM')!;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        100000000000000n\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAssetsMap(): Map<string, Map<string, bigint>>\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `getDataVar`\n\nGet the value of a `data-var` defined in a contract.\n\n## Parameters\n\nThe contract identifier of the contract.\n\n<span>Example: `counter`</span>\n\nThe name of the `data-var` for the contract.\n\n<span>Example: `count`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the value of a data variable</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const currentCount = simnet.getDataVar('counter', 'count');\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity counter.clar\n        (define-data-var count uint u0)\n        (define-data-var contractOwner principal tx-sender)\n        \n        (var-set count (+ (var-get count) u1))\n        (var-set contractOwner 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 1,\n          value: 1n\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getDataVar(contract: string, dataVar: string): ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { cvToValue } from '@stacks/transactions';\n\n    const contractOwner = simnet.getDataVar(\"counter\", \"contractOwner\");\n\n    const response = cvToValue(contractOwner);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity counter.clar\n        (define-data-var count uint u0)\n        (define-data-var contractOwner principal tx-sender)\n        \n        (var-set count (+ (var-get count) u1))\n        (var-set contractOwner 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getDataVar(contract: string, dataVar: string): ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `getMapEntry`\n\nGet the value of a map entry by its key. Note that this method will always return an optional value `some` or `none`, just like Clarity `map-get?`.\n\n## Parameters\n\nThe contract identifier of the contract.\n\n<span>Example: `pool`</span>\n\nThe name of the map within the contract.\n\n<span>Example: `Participants`</span>\n\nThe key to access the value in the map.\n\n<span>Example: `Cl.standardPrincipal(\n  'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5'\n)`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the value of an entry</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('wallet_1')!;\n\n    const hasParticipated = simnet.getMapEntry(\n      \"pool\",\n      \"Participants\",\n      Cl.standardPrincipal(wallet)\n    );\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n\n        (map-set Participants 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 true)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 10,\n          value: {\n            type: 3,\n          },\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getMapEntry(\n          contract: string,\n          mapName: string,\n          mapKey: ClarityValue\n        ): ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { Cl, cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('wallet_1')!;\n\n    const hasParticipated = simnet.getMapEntry(\n      \"pool\",\n      \"Participants\",\n      Cl.standardPrincipal(wallet)\n    );\n\n    const response = cvToValue(hasParticipated);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n\n        (map-set Participants 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 true)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"bool\",\n          value: true,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getMapEntry(\n          contract: string,\n          mapName: string,\n          mapKey: ClarityValue\n        ): ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n# `callReadOnlyFn`\n\nCall read-only functions exposed by a contract.\n\nThis method returns an object with the result of the function call as a `ClarityValue`. It takes function arguments in the form of Clarity values, which are available in the package [`@stacks/transactions`](/stacks/stacks.js/packages/transactions).\n\n## Parameters\n\nThe contract identifier of the contract.\n\n<span>Example: `pool`</span>\n\nThe name of the read-only function within the contract.\n\n<span>Example: `get-participant`</span>\n\nThe arguments to pass to the read-only function. If no arguments are needed, pass an empty array.\n\n<span>Example: `[Cl.standardPrincipal(\n  'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5'\n)]`</span>\n\nThe Stacks address of the sender.\n\n<span>Example: `ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Making a function call</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"with-no-arguments\" className='tab group'>\n      <Badge className='badge transition-colors'>With no arguments</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"deployer\" className='tab group'>\n      <Badge className='badge transition-colors'>With an explicit contract address</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('wallet_1')!;\n\n    const getContributionAmount = simnet.callReadOnlyFn(\n      'pool',\n      'get-contribution-amount',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );  \n    \n    const response = getContributionAmount.result\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (get-contribution-amount (who principal))\n          (default-to u0 (get contributionAmount (get-participant who)))\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 1,\n          value: 420000000n,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n            result: ClarityValue;\n            events: ClarityEvent[];\n        }\n        \n        callReadOnlyFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"with-no-arguments\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('wallet_1')!;\n\n    const isActive = simnet.callReadOnlyFn(\n      'pool',\n      'is-active',\n      [],\n      wallet\n    );\n    \n    const response = isActive.result\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (get-contribution-amount (who principal))\n          (default-to u0 (get contributionAmount (get-participant who)))\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 10,\n          value: {\n            type: 3,\n          },\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n            result: ClarityValue;\n            events: ClarityEvent[];\n        }\n        \n        callReadOnlyFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"deployer\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n    const contractAddress = `${wallet}.pool`;\n\n    const getParticipant = simnet.callReadOnlyFn(\n      contractAddress,\n      'get-participant',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );\n\n    const response = getParticipant.result;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (get-contribution-amount (who principal))\n          (default-to u0 (get contributionAmount (get-participant who)))\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 9,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n            result: ClarityValue;\n            events: ClarityEvent[];\n        }\n        \n        callReadOnlyFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { Cl, cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n\n    const getContributionAmount = simnet.callReadOnlyFn(\n      'pool',\n      'get-contribution-amount',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );\n\n    const response = cvToValue(getContributionAmount.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (get-contribution-amount (who principal))\n          (default-to u0 (get contributionAmount (get-participant who)))\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        42000000n\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n            result: ClarityValue;\n            events: ClarityEvent[];\n        }\n        \n        callReadOnlyFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n    \n  </TabsContent>\n</Tabs>\n\n\n# `callPublicFn`\n\nCall public functions exposed by a contract.\n\nThis method returns an object with the result of the function call as a `ClarityValue` and the events fired during the function execution. It takes function arguments in the form of Clarity values, which are available in the package [`@stacks/transactions`](/stacks/stacks.js/packages/transactions).\n\nThis method will simulate a block being mined and increase the block height by one.\n\n## Parameters\n\nThe contract identifier of the contract.\n\n<span>Example: `pool`</span>\n\nThe name of the public function within the contract.\n\n<span>Example: `register-participant`</span>\n\nThe arguments to pass to the public function. If no arguments are needed, pass an empty array.\n\n<span>Example: `[Cl.standardPrincipal(\n  'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5'\n)]`</span>\n\nThe Stacks address of the sender.\n\n<span>Example: `ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Broadcasting your transaction</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"events\" className='tab group'>\n      <Badge className='badge transition-colors'>Filtering for contract events</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n\n    const registerParticipant = simnet.callPublicFn(\n      'pool',\n      'register-participant',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );\n\n    const response = registerParticipant.result;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-public (register-participant (who principal))\n          (begin\n            (map-set Participants who true)\n            (map-set ParticipantStatus who { enrollmentBlock: block-height, contributionAmount: u0 })\n            (print { message: \"Registered\", who: who, at: block-height })\n            (ok true)\n          )\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 7,\n          value: {\n            type: 3,\n          },\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        callPublicFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { Cl, cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n\n    const registerParticipant = simnet.callPublicFn(\n      'pool',\n      'register-participant',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );\n    \n    const response = cvToValue(registerParticipant.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-public (register-participant (who principal))\n          (begin\n            (map-set Participants who true)\n            (map-set ParticipantStatus who { enrollmentBlock: block-height, contributionAmount: u0 })\n            (print { message: \"Registered\", who: who, at: block-height })\n            (ok true)\n          )\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"bool\",\n          value: true,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        callPublicFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"events\">\n    ```ts\n    import { Cl, cvToValue, type ClarityValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n\n    const registerParticipant = simnet.callPublicFn(\n      'pool',\n      'register-participant',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );\n    \n    const eventValues = registerParticipant.events.map((event) =>\n      cvToValue(event.data.value as ClarityValue)\n    );\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-public (register-participant (who principal))\n          (begin\n            (map-set Participants who true)\n            (map-set ParticipantStatus who { enrollmentBlock: block-height, contributionAmount: u0 })\n            (print { message: \"Registered\", who: who, at: block-height })\n            (ok true)\n          )\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        [\n          {\n            at: {\n              type: \"uint\",\n              value: \"2\",\n            },\n            message: {\n              type: \"(string-ascii 10)\",\n              value: \"Registered\",\n            },\n            who: {\n              type: \"principal\",\n              value: \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\",\n            },\n          }\n        ]\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        callPublicFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `callPrivateFn`\n\nCall private functions exposed by a contract.\n\nThis method returns an object with the result of the function call as a `ClarityValue` and the events, if any, fired during the function execution. It takes function arguments in the form of Clarity values, which are available in the package [`@stacks/transactions`](/stacks/stacks.js/packages/transactions).\n\nThis method will simulate a block being mined and increase the block height by one.\n\n## Parameters\n\nThe contract identifier of the contract.\n\n<span>Example: `pool`</span>\n\nThe name of the private function within the contract.\n\n<span>Example: `reward-participant-points`</span>\n\nThe arguments to pass to the private function. If no arguments are needed, pass an empty array.\n\n<span>Example: `[Cl.standardPrincipal(\n  'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5'\n)]`</span>\n\nThe Stacks address of the sender.\n\n<span>Example: `ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Broadcasting your transaction</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n    const address1 = accounts.get(\"wallet_1\")!\n\n    const rewardParticipantPoints = simnet.callPrivateFn(\n      \"pool\",\n      \"reward-participant-points\",\n      [Cl.standardPrincipal(address1)],\n      wallet\n    );\n\n    const response = rewardParticipantPoints.result;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n        (define-map ParticipantPoints principal int)\n\n        (define-public (register-participant (who principal))\n          (begin\n            (map-set Participants who true)\n            (map-set ParticipantStatus who { enrollmentBlock: block-height, contributionAmount: u0 })\n            (reward-participant-points who)\n            (print { message: \"Registered\", who: who, at: block-height })\n            (ok true)\n          )\n        )\n\n        (define-private (reward-participant-points (who principal))\n            (map-insert ParticipantPoints who 100)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        (map-set ParticipantPoints tx-sender 1000)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 3,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n\n        callPrivateFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { Cl, cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n    const address1 = accounts.get(\"wallet_1\")!\n\n    const rewardParticipantPoints = simnet.callPrivateFn(\n      \"pool\",\n      \"reward-participant-points\",\n      [Cl.standardPrincipal(address1)],\n      wallet\n    );\n\n    const response = cvToValue(registerParticipant.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n        (define-map ParticipantPoints principal int)\n\n        (define-public (register-participant (who principal))\n          (begin\n            (map-set Participants who true)\n            (map-set ParticipantStatus who { enrollmentBlock: block-height, contributionAmount: u0 })\n            (reward-participant-points who)\n            (print { message: \"Registered\", who: who, at: block-height })\n            (ok true)\n          )\n        )\n\n        (define-private (reward-participant-points (who principal))\n            (map-insert ParticipantPoints who 100)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        (map-set ParticipantPoints tx-sender 1000)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"bool\",\n          value: true,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n\n        callPrivateFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  \n</Tabs>\n\n\n\n# `transferSTX`\n\nTransfer STX from one address to another. The amount transferred is in `uSTX`.\n\nThis method will simulate a block being mined and increase the block height by one.\n\n## Parameters\n\nThe amount of `uSTX` to transfer.\n\n<span>Example: `1000000` equals 1 STX</span>\n\nThe Stacks address of the recipient.\n\n<span>Example: `ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5`</span>\n\nThe Stacks address of the sender.\n\n<span>Example: `ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM`</span>\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Transferring STX</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"events\" className='tab group'>\n      <Badge className='badge transition-colors'>Filtering for contract events</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const accounts = simnet.getAccounts();\n    const recipient = accounts.get('wallet_1')!;\n\n    const transfer = simnet.transferSTX(\n      42000000, // 42 STX\n      recipient,\n      simnet.deployer\n    );\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          result: {\n            type: 7,\n            value: {\n              type: 3,\n            },\n          },\n          events: [\n            {\n              event: \"stx_transfer_event\",\n              data: [\n                {\n                  amount: \"42000000\",\n                  memo: \"\",\n                  recipient: \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\",\n                  sender: \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\",\n                },\n              ],\n            }\n          ],\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        transferSTX(\n          amount: number | bigint,\n          recipient: string,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const recipient = accounts.get('wallet_1')!;\n\n    const transfer = simnet.transferSTX(\n      42000000, // 42 STX\n      recipient,\n      simnet.deployer\n    );\n    \n    const response = cvToValue(transfer.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"bool\",\n          value: true,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        transferSTX(\n          amount: number | bigint,\n          recipient: string,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"events\">\n    ```ts\n    const accounts = simnet.getAccounts();\n    const recipient = accounts.get('wallet_1')!;\n\n    const transfer = simnet.transferSTX(\n      42000000, // 42 STX\n      recipient,\n      simnet.deployer\n    );\n\n    const events = transfer.events.map((event) => event);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        [\n          {\n            event: \"stx_transfer_event\",\n            data: {\n              amount: \"42000000\",\n              memo: \"\",\n              recipient: \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\",\n              sender: \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\",\n            },\n          }\n        ]\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        transferSTX(\n          amount: number | bigint,\n          recipient: string,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `deployContract`\n\nDeploy a contract to simnet.\n\nThis method will simulate a block being mined and increase the block height by one.\n\n## Parameters\n\nThe name of the contract to be deployed.\n\n<span>Example: `hello-world`</span>\n\nThe Clarity source code (or content) of the contract.\n\n<span>Example: `(define-read-only (say-hi) (ok \"Hello World\"))`</span>\n\nAn object to specify options, such as the Clarity version.\n\n<span>Example: `{ clarityVersion: 2 }` | `null`</span>\n\nThe Stacks address of the sender.\n\n<span>Example: `ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Deploying your contract</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"options\" className='tab group'>\n      <Badge className='badge transition-colors'>Specifying a Clarity version</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"interact\" className='tab group'>\n      <Badge className='badge transition-colors'>Interacting with your contract</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { cvToValue } from '@stacks/transactions';\n\n    const sourceCode = '(define-read-only (say-hi) (ok \"Hello World\"))';\n\n    const contract = simnet.deployContract(\n      'hello-world',\n      sourceCode,\n      null,\n      simnet.deployer\n    );\n\n    const response = cvToValue(contract.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        true\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        deployContract(\n          name: string,\n          content: string,\n          options: DeployContractOptions | null,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"options\">\n    ```ts\n    import { cvToValue } from '@stacks/transactions';\n\n    const sourceCode = '(define-read-only (say-hi) (ok \"Hello World\"))';\n\n    const contract = simnet.deployContract(\n      'hello-world',\n      sourceCode,\n      { clarityVersion: 2 },\n      simnet.deployer\n    );\n\n    const response = cvToValue(contract.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        true\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        deployContract(\n          name: string,\n          content: string,\n          options: DeployContractOptions | null,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"interact\">\n    ```ts\n    import { cvToValue } from '@stacks/transactions';\n\n    const sourceCode = '(define-read-only (say-hi) (ok \"Hello World\"))';\n\n    simnet.deployContract(\n      'hello-world',\n      sourceCode,\n      null,\n      simnet.deployer\n    );\n\n    const sayHi = simnet.callReadOnlyFn(\"hello-world\", \"say-hi\", [], simnet.deployer);\n\n    const response = sayHi.result\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"(string-ascii 11)\",\n          value: \"Hello World\",\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        deployContract(\n          name: string,\n          content: string,\n          options: DeployContractOptions | null,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `mineBlock`\n\nThe `callPublicFn`, `transferSTX`, and `deployContract` methods all mine one block with only one transaction. It can also be useful to mine a block with multiple transactions.\n\nThis is what `mineBlock` is for.\n\nThis method takes an array of transaction objects. The transactions can be built with the `tx` helper exported by the SDK.\n\nThe `tx` helper has three methods:\n- `callPublicFn`\n- `transferSTX`\n- `deployContract`\n\nThese methods have the same interface as simnet methods but instead of performing a transaction, they will build a transaction object that can be passed to the `mineBlock` function.\n\nIn epochs from 3.0 on, the stacks chaintip is advanced separately from the burn chaintip. This means `mineBlock` will only affect the stacks chaintip. If you'd like to also mine burn blocks, use the `mineEmptyBurnBlock` function.\n\n## Parameters\n\nAn array of transactions to be included in the block.\n\n<span>Example: `[tx.transferSTX(100, recipient, sender), ...]`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Mining multiple transactions in a single block</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { tx } from '@hirosystems/clarinet-sdk';\n    import { Cl, cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get(\"wallet_1\")!;\n\n    const block = simnet.mineBlock([\n      tx.callPublicFn(\"counter\", \"increment\", [], simnet.deployer),\n      tx.callPublicFn(\"counter\", \"add\", [Cl.uint(10)], simnet.deployer),\n      tx.transferSTX(19000000, wallet, simnet.deployer),\n    ]);\n\n    block.forEach((transaction) => {\n      console.log(cvToValue(transaction.result));\n      if (transaction.events.length > 0) console.log(transaction.events);\n    });\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity counter.clar\n        (define-data-var count uint u0)\n\n        (define-public (increment)\n          (begin\n            (var-set count (+ (var-get count) u1))\n            (ok (var-get count))\n          )\n        )\n\n        (define-public (add (amount uint))\n          (begin\n            (var-set count (+ (var-get count) amount))\n            (ok (var-get count))\n          )\n        )\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"uint\",\n          value: \"1\",\n        }\n        {\n          type: \"uint\",\n          value: \"11\",\n        }\n        {\n          type: \"bool\",\n          value: true,\n        }\n        [\n          {\n            event: \"stx_transfer_event\",\n            data: {\n              amount: \"19000000\",\n              memo: \"\",\n              recipient: \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\",\n              sender: \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\",\n            },\n          }\n        ]\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        mineBlock(txs: Tx[]): ParsedTransactionResult[]\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `mineEmptyBlock`\n\nMine one empty block and increase the block height by one.\n\nReturns the new block height.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Mining an empty block</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    simnet.mineEmptyBlock();\n\n    const response = simnet.blockHeight;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        2\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        mineEmptyBlock(): number\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `mineEmptyBlocks`\n\nMine multiple empty blocks to reach a certain block height.\n\nReturns the new block height.\n\n## Parameters\n\nThe number of empty blocks to mine. This parameter is optional.\n\n<span>Example: `5`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Mining multiple empty blocks</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"options\" className='tab group'>\n      <Badge className='badge transition-colors'>Mining an empty block without a count</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    simnet.mineEmptyBlocks(5);\n\n    const response = simnet.blockHeight;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        6\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        mineEmptyBlocks(count?: number): number\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"options\">\n    ```ts\n    simnet.mineEmptyBlocks();\n\n    const response = simnet.blockHeight;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        2\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        mineEmptyBlocks(count?: number): number\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `runSnippet`\n\nExecute arbitrary Clarity code directly, which allows you to test and interact with smart contract functions without deploying them.\n\n## Parameters\n\nThe Clarity code snippet to be executed.\n\n<span>Example: `(define-read-only (get-balance) (ok stx-balance))`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Executing arbitrary Clarity code</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"transfer\" className='tab group'>\n      <Badge className='badge transition-colors'>Running a snippet for a STX transfer</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const codeSnippet = simnet.runSnippet(\n      '(stx-account tx-sender)'\n    );\n\n    const response = Cl.prettyPrint(codeSnippet, 2);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          locked: u0,\n          unlock-height: u0,\n          unlocked: u100000000000000\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        runSnippet(snippet: string): string | ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"transfer\">\n    ```ts\n    import { cvToValue } from \"@stacks/transactions\";\n\n    const accounts = simnet.getAccounts();\n    const recipient = accounts.get(\"wallet_1\")!;\n\n    const codeSnippet = simnet.runSnippet(\n      `(stx-transfer? u19000000 tx-sender '${recipient})`\n    );\n\n    const response = cvToValue(codeSnippet);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"bool\",\n          value: true,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        runSnippet(snippet: string): string | ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `getContractsInterfaces`\n\nReturns the interfaces of the project contracts as a Map of Contracts, with the keys being the contract addresses.\n\nThese interfaces contain information such as the available `functions`, `data-vars`, `maps`, `NFTs`, and `FTs` defined in the contract.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting a specific contract interface</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"filter\" className='tab group'>\n      <Badge className='badge transition-colors'>Filtering for contract functions</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const contractInterfaces = simnet.getContractsInterfaces();\n\n    const response = contractInterfaces.get(`${simnet.deployer}.pool`);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          functions: [\n            {\n              name: \"get-participant\",\n              access: \"read_only\",\n              args: [\n                [Object ...]\n              ],\n              outputs: [Object ...],\n            }, {\n              name: \"is-active\",\n              access: \"read_only\",\n              args: [],\n              outputs: [Object ...],\n            }\n          ],\n          variables: [],\n          maps: [\n            {\n              name: \"ParticipantStatus\",\n              key: \"principal\",\n              value: [Object ...],\n            }, {\n              name: \"Participants\",\n              key: \"principal\",\n              value: \"bool\",\n            }\n          ],\n          fungible_tokens: [],\n          non_fungible_tokens: [],\n          epoch: \"Epoch25\",\n          clarity_version: \"Clarity2\",\n        }\n\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getContractsInterfaces(): Map<string, ContractInterface>\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"filter\">\n    ```ts\n    const poolContract = contractInterfaces.get(`${simnet.deployer}.pool`);\n\n    const response = poolContract?.functions;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        [\n          {\n            name: \"get-participant\",\n            access: \"read_only\",\n            args: [\n              [Object ...]\n            ],\n            outputs: [Object ...],\n          }, {\n            name: \"is-active\",\n            access: \"read_only\",\n            args: [],\n            outputs: [Object ...],\n          }\n        ]\n\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getContractsInterfaces(): Map<string, ContractInterface>\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `getContractSource`\n\nGet the source code of a contract as a string.\n\n## Parameters\n\nThe identifier of the contract for which the source code is requested.\n\n<span>Example: `pool`</span>\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the source code of a contract</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const contractSource = simnet.getContractSource('pool');\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```clarity\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getContractSource(contract: string): string | undefined\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `getContractAST`\n\nGet the full AST (Abstract Syntax Tree) of a Clarity contract.\n\nThis method throws an error if it fails to get the AST or to encode it.\n\n## Parameters\n\nThe identifier of the contract for which the AST (Abstract Syntax Tree) is requested.\n\n<span>Example: `pool`</span>\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the source code of a contract</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const contractAST = simnet.getContractAST('pool');\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          contract_identifier: {\n            issuer: [ 26, [\n                109, 120, 222, 123, 6, 37, 223, 191, 193, 108, 58, 138, 87, 53, 246, 220,\n                61, 195, 242, 206\n              ] ],\n            name: \"pool\",\n          },\n          pre_expressions: [],\n          expressions: [\n            {\n              expr: [Object ...],\n              id: 1,\n              span: [Object ...],\n              pre_comments: [],\n              end_line_comment: undefined,\n              post_comments: [],\n            },\n            ...\n          ],\n          top_level_expression_sorting: [ 0, 1, 2, 3 ],\n          referenced_traits: Map {},\n          implemented_traits: [],\n          wasm_module: undefined,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getContractAST(contractId: string): ContractAST\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n"
  },
  {
    "title": "Overview",
    "description": "The Clarinet JS SDK is a JavaScript library used to write unit tests for Clarity smart contracts.",
    "slug": "/stacks/clarinet-js-sdk/index",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nThe Clarinet JS SDK allows you to write unit tests for your Clarity smart contracts. You can theoretically use any JavaScript test framework, but the SDK supports Vitest out of the box. This SDK leverages `simnet`, a simulated network that offers a rapid feedback loop for initial testing.\n\nHere is a non-exhaustive list of some of simnet's use-cases:\n\n- Call public and read-only functions from smart contracts\n- Get Clarity maps or data-var values\n- Get contract interfaces (available functions and data)\n- Write unit tests for Clarity smart contracts\n\n<Callout title=\"Requirements\" type=\"warn\">\n  The SDK requires Node.js >= 18.0 and NPM to be installed.\n</Callout>\n\n## Guides\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/clarinet-js-sdk/quickstart\"\n    title=\"Simulate a blockchain with Clarinet JS SDK\"\n    description=\"Learn how to interact with a simulated network without running a node.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/clarinet-js-sdk/guides/migrate-to-the-clarinet-sdk\"\n    title=\"Migrate v1 tests to Clarinet JS SDK\"\n    description=\"Learn how to migrate your existing tests to the Clarinet JS SDK.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/clarinet-js-sdk/references/simnet\"\n    title=\"SDK reference\"\n    description=\"Dive deeper into the methods, properties, and types available in the Clarinet JS SDK.\"  />\n</Cards>\n\n## Related tools\n\n- **[Clarinet](/stacks/clarinet)**: Build your app in a local environment on Stacks.\n- **[Stacks.js](/stacks/stacks.js)**: Don’t reinvent the wheel and build faster with a JS library that handles basic blockchain functionality.\n- **[Stacks Blockchain API](/stacks/api)**: Fetch data and broadcast transactions with the Stacks Blockchain API.\n\n<br />\n\n<Callout title=\"Need help building with Clarinet JS SDK?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#clarinet</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>"
  },
  {
    "title": "Quickstart",
    "description": "Learn how to test a simple counter contract using the Clarinet JS SDK.",
    "slug": "/stacks/clarinet-js-sdk/quickstart",
    "content": "\nimport { ChevronRight, Code, Terminal } from 'lucide-react';\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\nimport { Steps, Step } from 'fumadocs-ui/components/steps';\nimport { SmallCard } from '@/components/card';\n\nIn this quickstart guide, you will initialize a simulated development network for testing a smart contract using the Clarinet JS SDK. You'll learn how to initialize your project, interact with a smart contract, call its functions, and test the results.\n\nCheck out the [methods](/stacks/clarinet-js-sdk/references/methods) page for the Clarinet JS SDK to learn about the different ways that you can interact with simnet.\n\n---\n\n<Steps>\n  <Step>\n    ## Importing dependencies\n  \n    Before we dive in, navigate to your project and import the `Cl` helper from the `@stacks/transactions` package in your test file.\n\n    <Files className='pointer-events-none'>\n      <Folder name=\"contracts\" defaultOpen>\n        <File name=\"counter.clar\" />\n      </Folder>\n      <Folder name=\"settings\" />\n      <Folder name=\"tests\" defaultOpen>\n        <File name=\"counter.test.ts\" className='bg-[hsl(var(--highlight))]' />\n      </Folder>\n      <File name=\".gitignore\" />\n      <File name=\"Clarinet.toml\" />\n      <File name=\"package.json\" />\n      <File name=\"tsconfig.json\" />\n      <File name=\"vitest.config.js\" />\n    </Files>\n\n    ```ts counter.test.ts\n    import { describe, expect, it } from \"vitest\";\n    import { Cl } from \"@stacks/transactions\";\n    ```\n\n    The `Cl` namespace simplifies the process of creating and handling Clarity values. This functionality is particularly useful in testing environments where developers need to simulate contract interactions accurately.\n   \n  </Step>\n  <Step>\n    ## Retrieve an account from the simnet\n  \n    For most test cases, you'll want to retrieve an account from the network in order to interact with your smart contracts. The following code uses the `getAccounts` method to achieve this.\n\n    ```ts counter.test.ts\n    import { describe, expect, it } from \"vitest\";\n    import { Cl } from \"@stacks/transactions\";\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get(\"wallet_1\")!;\n    ```\n\n    <Callout title=\"Note\">\n      The `--stacks` flag is required and allows you to specify the network to scan. Other options include `--bitcoin`.\n    </Callout>\n  </Step>\n  <Step>\n    ## Write your first test\n  \n    The process for writing tests for smart contracts with the Clarinet JS SDK follows a structured approach similar to testing in JavaScript. Here's a breakdown of the steps involved:\n\n    1. Define the group of tests you want to run using the `describe` block.\n    2. Define the test you want to run using the `it` block.\n    3. Call the function and assert the result using the `expect` function.\n\n    Now that you understand the key components for writing tests, start by writing a test that ensures the `counter` contract has been deployed.\n\n    ```ts counter.test.ts\n    describe(\"counter contract\", () => {\n      it(\"ensures the contract is deployed\", () => {\n        const contractSource = simnet.getContractSource(\"counter\");\n        expect(contractSource).toBeDefined();\n      });\n    });\n    ```\n  </Step>\n  <Step>\n    ## Test the count-up function\n  \n    Now it's time to call a public function and assert the result. The <code>count-up</code> function is expected to increment the count of the user's principal by 1. Write a test to ensure this behaves as expected.\n\n    ```ts counter.test.ts\n    describe(\"counter contract\", () => {\n      it(\"increments the count of the user's principal by 1\", () => {\n        const countUpCall = simnet.callPublicFn(\"counter\", \"count-up\", [], wallet);\n        expect(countUpCall.result).toBeOk(Cl.bool(true));\n        \n        const getCountCall = simnet.callReadOnlyFn(\n          \"counter\",\n          \"get-count\",\n          [Cl.principal(wallet)],\n          wallet\n        );\n        expect(getCountCall.result).toBeUint(1);\n      });\n    });\n    ```\n\n    Above, the `count-up` function is called, and the result is asserted to return an `(ok true)`. Then, the count for the user's principal is retrieved and asserted to be `u1`.\n\n    <Callout title=\"Custom matchers\">\n      <p>The <code>toBeOk</code> and <code>toBeUint</code> methods are used to ensure the `count-up` function returns the proper Clarity values. For more details, check out the [custom matchers](/stacks/clarinet-js-sdk/references/custom-matchers) page.</p>\n    </Callout>\n  </Step>\n  <Step>\n    ## Run your tests\n\n    Every generated project comes with a <code>package.json</code> file that contains the necessary dependencies and scripts to run your tests.\n  \n    ```json package.json\n    \"scripts\": {\n      \"test\": \"vitest run\",\n      \"test:report\": \"vitest run -- --coverage --costs\",\n      \"test:watch\": \"chokidar \\\"tests/**/*.ts\\\" \\\"contracts/**/*.clar\\\" -c \\\"npm run test:report\\\"\"\n    }\n    ```\n\n    You can now run your tests, with your preferred package manager, by executing the following command:\n  \n    ```terminal\n    $ npm run test\n    ```\n  </Step>\n  <Step>\n    ## Run your tests with code coverage and cost analysis\n\n    Clarinet can automatically also produce a code coverage report and cost analysis on the test you ran.\n\n    ```json package.json\n    \"scripts\": {\n      \"test\": \"vitest run\",\n      \"test:report\": \"vitest run -- --coverage --costs\",\n      \"test:watch\": \"chokidar \\\"tests/**/*.ts\\\" \\\"contracts/**/*.clar\\\" -c \\\"npm run test:report\\\"\"\n    }\n    ```\n\n    By running the `npm run test:report` command in your terminal, an `lcov.info` and `costs-reports.json` file will appear in your root folder:\n\n    <Files className='pointer-events-none'>\n      <Folder name=\"contracts\" defaultOpen>\n        <File name=\"counter.clar\" />\n      </Folder>\n      <Folder name=\"settings\" />\n      <Folder name=\"tests\" defaultOpen>\n        <File name=\"counter.test.ts\" />\n      </Folder>\n      <File name=\".gitignore\" />\n      <File name=\"Clarinet.toml\" />\n      <File name=\"costs-reports.json\" className='bg-[hsl(var(--highlight))]' />\n      <File name=\"lcov.info\" className='bg-[hsl(var(--highlight))]' />\n      <File name=\"package.json\" />\n      <File name=\"tsconfig.json\" />\n      <File name=\"vitest.config.js\" />\n    </Files>\n\n    The `costs-reports.json` file will output the cost analysis for every function ran in your tests. Since the `count-up` function was used in our test, this is how the cost analysis output would look like for that function:\n\n    ```json costs-reports.json\n      {\n        \"test_name\": \"tests/counter.test.ts__counter contract__increments the count of the user's principal by 1\",\n        \"contract_id\": \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.counter\",\n        \"method\": \"count-up\",\n        \"args\": [],\n        \"cost_result\": {\n          \"total\": {\n            \"write_length\": 41,\n            \"write_count\": 1,\n            \"read_length\": 245,\n            \"read_count\": 5,\n            \"runtime\": 4752\n          },\n          \"limit\": {\n            \"write_length\": 15000000,\n            \"write_count\": 15000,\n            \"read_length\": 100000000,\n            \"read_count\": 15000,\n            \"runtime\": 5000000000\n          },\n          \"memory\": 40,\n          \"memory_limit\": 100000000\n        }\n      }\n    ```\n\n    To access and read the `lcov.info` file in a human-readable format, we can first install the `lcov` [package](https://github.com/linux-test-project/lcov) that helps generate a graphical front-end for coverage testing tools.\n\n    ```terminal\n    $ brew install lcov\n    ```\n\n    Then we'll run the `genhtml` command below with the following options. This command and its options will generate the actual html file, add in additional branch coverage, and will automatically store the files in a new folder called `coverage`.\n\n    ```terminal\n    $ genhtml lcov.info --branch-coverage -o coverage\n    ```\n\n    You can then navigate into the new `coverage` folder and run the command `open index.html` to view your coverage report. In addition, a summary of the coverage report will be outputted in the terminal.\n  </Step>\n</Steps>\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/simnet\"\n    title=\"API Reference\"\n    description=\"Dive deeper into the properties and methods available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/custom-matchers\"\n    title=\"Custom matchers\"\n    description=\"Learn about the custom matchers that are available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/guides/migrate-to-the-clarinet-sdk\"\n    title=\"Migrating your tests to Clarinet SDK\"\n    description=\"Learn how to migrate your existing Clarinet projects to the Clarinet JS SDK\"\n  />\n</Cards>"
  },
  {
    "title": "Installation",
    "description": "Clarinet JS SDK can be installed using your preferred package manager.",
    "slug": "/stacks/clarinet-js-sdk/installation",
    "content": "\n<Callout type=\"warn\">\n  The SDK requires Node.js >= 18.0 and NPM to be installed.\n</Callout>\n\n```package-install\n@hirosystems/clarinet-sdk\n```\n"
  },
  {
    "title": "SDKs & Libraries",
    "description": "The following guides cover ways to use Hiro tools to build apps on Stacks.",
    "slug": "/stacks/reference",
    "content": "\nimport { Database, Ticket } from 'lucide-react';\nimport { Blockchain, BitcoinIcon, Clarinet, Container, DAO, Js, Plant, Shapes, StacksIcon } from '@/components/ui/icon';\nimport { SecondaryCard, SmallCard } from '@/components/card';\n\n<div className='flex flex-col space-y-10'>\n\n<Cards>\n  <SecondaryCard\n    icon={<Clarinet />}\n    href=\"/stacks/clarinet/quickstart\"\n    title=\"Create your first smart contract\"\n    description=\"Build a simple counter contract using Clarinet.\"\n    tag='Clarinet'\n  />\n  <SecondaryCard\n    icon={<Blockchain />}\n    href=\"/stacks/clarinet-js-sdk/quickstart\"\n    title=\"Write unit tests for your smart contracts\"\n    description=\"Learn how run unit tests with Clarinet JS SDK.\"\n    tag='Clarinet JS SDK'\n  />\n  <SecondaryCard\n    icon={<Js />}\n    href=\"/stacks/stacks.js/quickstart\"\n    title=\"Make a contract call with Stacks.js\"\n    description=\"Learn how to integrate smart contracts into your app.\"\n    tag='Stacks.js'\n  />\n  <SecondaryCard\n    icon={<Database />}\n    href=\"/stacks/chainhook/quickstart\"\n    title=\"Stream custom blockchain events\"\n    description=\"Use Chainhook to filter & stream for contract deployments.\"\n    tag='Chainhook'\n  />\n</Cards>\n\n<div className='flex flex-col'>\n\n<h4 id=\"learn-by-example\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#learn-by-example\" className=\"not-prose group text-sm uppercase\">Learn by example</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<Shapes />}\n    href=\"/guides/build-an-nft-marketplace\"\n    title=\"Build an NFT Marketplace\"\n    description=\"Learn how to create and deploy your own NFT marketplace.\"\n  />\n  {/* <SmallCard\n    icon={<DAO />}\n    href=\"/stacks/clarinet\"\n    title=\"Launch a Decentralized Autonomous Organization (DAO)\"\n    description=\"Discover the steps to creating your own DAO.\"\n  /> */}\n  <SmallCard\n    icon={<Ticket />}\n    href=\"/guides/no-loss-lottery\"\n    title=\"Create a no-loss lottery pool\"\n    description=\"Build a no-loss lottery pool that leverages stacking yield.\"\n  />\n  <SmallCard\n    icon={<Plant />}\n    href=\"/guides/build-a-decentralized-kickstarter\"\n    title=\"Build a decentralized Kickstarter\"\n    description=\"Learn how to create a crowdfunding app, enabling creators to fund their projects without a third party.\"\n  />\n</Cards>\n\n</div>\n\n<div className='flex flex-col'>\n\n<h4 id=\"installation-guides\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#installation-guides\" className=\"not-prose group text-sm uppercase\">Installation guides</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<BitcoinIcon />}\n    href=\"/guides/sync-a-bitcoin-node\"\n    title=\"Sync a Bitcoin node\"\n    description=\"Set up and run a Bitcoin node to run tools like Chainhook as a service.\"\n  />\n  <SmallCard\n    icon={<StacksIcon />}\n    href=\"/guides/sync-a-stacks-node\"\n    title=\"Sync a Stacks node\"\n    description=\"Set up and run a Stacks node to use tools like Chainhook or spin up your own API.\"\n  />\n  <SmallCard\n    icon={<Container />}\n    href=\"/guides/installing-docker\"\n    title=\"Install and run Docker on your machine\"\n    description=\"Essential for running a local development with Clarinet\"\n  />\n</Cards>\n\n</div>\n\n<Callout type=\"tip\">\nFor more, check out our [guides](/guides) section.\n</Callout>\n\n</div>\n"
  },
  {
    "title": "Best practices",
    "description": "Learn best practices for writing and running tests for your Clarity smart contracts using the Clarinet JS SDK and Vitest.",
    "slug": "/stacks/testing-best-practices",
    "content": "\nIntegration testing is a crucial step in smart contract development that involves testing how different components of your system work together. The Clarinet JS SDK provides powerful tools for writing and running integration tests, allowing you to simulate complex scenarios and interactions between multiple contracts.\n\nBy using integration tests, you can ensure that your smart contracts function correctly as part of a larger system and catch potential issues that might not be apparent in unit tests alone.\n\nIn this guide, you will:\n\n1. [Set up a Clarinet project with a `defi` contract.](#set-up-a-clarinet-project)\n2. [Write an integration test for the smart contract.](#test-the-deposit-and-borrow-functionality)\n3. [Run tests and generate coverage reports.](#run-tests-and-generate-coverage-reports)\n\n---\n\n## Set up a Clarinet project\n\nStart by creating a new Clarinet project. This command will create a new directory named `defi` and set up a basic Clarinet project inside it.\n\n```terminal\n$ clarinet new stx-defi\n$ cd stx-defi\n```\n\nAfter changing into your project directory, run `npm install` to install the package dependencies for testing.\n\n```terminal\n$ npm install\n```\n\nWe are going to use the same `defi` contract that we used in the [unit testing guide](/stacks/clarinet-js-sdk/guides/unit-testing), but with some additional functionality - the ability to `borrow` STX from the contract. If you don't have this project set up already, follow the steps below:\n\n```terminal\n$ clarinet contract new defi\n```\n\nThen, inside your `defi.clar` file, copy and paste the following contract code:\n\n```clarity\n;; Error constants for various failure scenarios.\n(define-constant err-overborrow (err u300))\n\n;; The interest rate for loans, represented as 10% (out of a base of 100).\n(define-data-var loan-interest-rate uint u10) ;; Representing 10% interest rate\n\n\n;; Holds the total amount of deposits in the contract, initialized to 0.\n(define-data-var total-deposits uint u0)\n\n;; Maps a user's principal address to their deposited amount.\n(define-map deposits { owner: principal } { amount: uint })\n\n;; Maps a borrower's principal address to their loan details: amount and the last interaction block.\n(define-map loans principal { amount: uint, last-interaction-block: uint })\n\n;; Public function for users to deposit STX into the contract.\n;; Updates their balance and the total deposits in the contract.\n(define-public (deposit (amount uint))\n  (let\n    (\n      ;; Fetch the current balance or default to 0 if none exists.\n      (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))\n    )\n    ;; Transfer the STX from sender = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\" to recipient = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.defi (ie: contract identifier on the chain!)\".\n    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))\n    ;; Update the user's deposit amount in the map.\n    (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })\n    ;; Update the total deposits variable.\n    (var-set total-deposits (+ (var-get total-deposits) amount))\n    ;; Return success.\n    (ok true)\n  )\n)\n\n;; Public function for users to borrow STX based on their deposits.\n(define-public (borrow (amount uint))\n  (let\n    (\n      ;; Fetch user's deposit or default to 0.\n      (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))\n      ;; Calculate the maximum amount the user is allowed to borrow. (which will be upto HALF of what they deposited)\n      (allowed-borrow (/ user-deposit u2))\n      ;; Fetch current loan details or default to initial values.\n      (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))\n      ;; Calculate accrued interest on the current loan.\n      (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))\n      ;; Calculate the total amount due including interest.\n      (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))\n      ;; Calculate the new loan total after borrowing additional amount.\n      (new-loan (+ amount))\n    )\n    ;; Ensure the requested borrow amount does not exceed the allowed amount.\n    (asserts! (<= new-loan allowed-borrow) err-overborrow)\n    ;; Transfer the borrowed STX to the user.\n    (let\n      (\n        (recipient tx-sender)\n      )\n      (try! (as-contract (stx-transfer? amount tx-sender recipient)))\n    )\n    ;; Update the user's loan details in the map.\n    (map-set loans tx-sender { amount: new-loan, last-interaction-block: block-height })\n    ;; Return success.\n    (ok true)\n  )\n)\n\n;; Read-only function to get the total balance by tx-sender\n(define-read-only (get-balance-by-sender)\n  (ok (map-get? deposits { owner: tx-sender }))\n)\n\n;; Read-only function to get the total amount owed by the user.\n(define-read-only (get-amount-owed)\n  (let\n    (\n      ;; Fetch current loan details or default to initial values.\n      (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))\n      ;; Calculate accrued interest on the current loan.\n      (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))\n      ;; Calculate the total amount due including interest.\n      (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))\n    )\n    ;; Return the total amount due.\n    (ok total-due)\n  )\n)\n\n;; Private function to calculate the accrued interest on a loan.\n(define-private (calculate-accrued-interest (principal uint) (start-block uint))\n  (let\n    (\n      ;; Calculate the number of blocks elapsed since the last interaction.\n      (elapsed-blocks (- block-height start-block))\n      ;; Calculate the interest based on the principal, rate, and elapsed time.\n      (interest (/ (* principal (var-get loan-interest-rate) elapsed-blocks) u10000))\n    )\n    ;; Ensure the loan started in the past (not at block 0).\n    (asserts! (not (is-eq start-block u0)) (ok u0))\n    ;; Return the calculated interest.\n    (ok interest)\n  )\n)\n```\n\nRun `clarinet check` to ensure that your smart contract is valid and ready for testing.\n\n<Callout>\nYou can find the full code for this project in [this repo](https://github.com/hirosystems/clarity-examples/tree/main/examples/stx-defi).\n</Callout>\n\n## Test the deposit and borrow functionality\n\nIn order to `borrow` STX from the contract, users must first `deposit` STX into it. Therefore, we need to write an integration test that simulates the interaction between these two functions.\n\nInside of your `defi.test.ts` file, replace the boilerplate code and add the following:\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { Cl } from '@stacks/transactions';\n\nconst accounts = simnet.getAccounts();\nconst wallet1 = accounts.get('wallet_1')!;\n\ndescribe('stx-defi', () => {\n  it('borrows 10 and verifies the amount owed to be 10', () => {\n    simnet.callPublicFn('defi', 'deposit', [Cl.uint(1000)], wallet1);\n    const totalDeposits = simnet.getDataVar('defi', 'total-deposits');\n    expect(totalDeposits).toBeUint(1000);\n\n    simnet.callPublicFn('defi', 'borrow', [Cl.uint(10)], wallet1);\n    const { result } = simnet.callReadOnlyFn('defi', 'get-amount-owed', [], wallet1);\n    expect(result).toBeOk(Cl.uint(10));\n  });\n});\n```\n\nIn this integration test, we're simulating a scenario where a user deposits STX into the DeFi contract and then borrows against that deposit. Let's walk through the process step by step.\n\nWe start by simulating a deposit of 1000 STX from `wallet1`. To do this, we use the `callPublicFn` method from the Clarinet JS SDK `simnet` object, which allows us to call public functions in our smart contract just as we would on the actual blockchain.\n\nAfter making the deposit, we want to verify that it was successful. We do this by checking the total deposits in the contract using `getDataVar`.\n\nThis handy method lets us peek at the value of data variables defined in your contract.\n\n<Callout>\nTo learn more about available methods for integration testing, check out the [reference page](/stacks/clarinet-js-sdk/references/methods).\n</Callout>\n\nTo ensure the deposit was recorded correctly, we use a custom matcher, `toBeUint`. This matcher is specifically designed to check if a value is a Clarity unsigned integer with the exact value we expect.\n\nWith the deposit confirmed, we simulate `wallet1` borrowing 10 STX. We do this with another call to `callPublicFn`, this time invoking the `borrow` function of our contract.\n\nAfter the borrowing operation, we want to check how much `wallet1` owes. We use `callReadOnlyFn` to call a read-only function named `get-amount-owed` in our contract.\n\nFinally, we verify the amount owed using another custom matcher, `toBeOk(Cl.uint(10))`. This matcher is particularly useful because it checks two things at once:\n\n1. That our contract returned a successful Clarity response type.\n2. That the value returned is a Clarity unsigned integer with the exact value we expect (`10`).\n\nThese custom matchers and simnet methods are powerful tools and allow you to simulate complex interactions with your smart contracts and make detailed assertions about the results.\n\n## Run tests and generate coverage reports\n\nTo run your tests, use:\n\n```terminal\n$ npm run test\n```\n\nTo generate a coverage report, use:\n\n```terminal\n$ npm run coverage\n```\n\nThis will run your tests and produce a detailed coverage report, helping you identify any untested parts of your contract.\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/simnet\"\n    title=\"API reference\"\n    description=\"Dive deeper into the properties and methods available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/custom-matchers\"\n    title=\"Custom matchers\"\n    description=\"Learn about the custom matchers that are available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/methods\"\n    title=\"SDK methods\"\n    description=\"Learn about the methods available in the Clarinet JS SDK.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Overview",
    "description": "The Hiro Archive is a series of data snapshots for services in the Stacks ecosystem.",
    "slug": "/stacks/archive/index",
    "content": "\nimport { Button } from \"@/components/ui/button\"\nimport { SecondaryCard } from \"@/components/card\"\n\nThe Hiro Archive enables you to quickly bootstrap supported services with pre-loaded data, which otherwise could take you days or weeks to acquire when syncing from genesis. This is a public service Hiro offers as a free benefit to the Stacks community.\n\n<Button className=\"bg-orange-500 hover:bg-orange-600\">\n    <a href=\"https://archive.hiro.so/\" target=\"_blank\" className=\"no-underline\">\n      View the Hiro Archive\n  </a>\n</Button>\n\n## Supported services\n\nWe record and archive mainnet and testnet snapshots for the following services every night:\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/archive/guides/verify-archive-data\"\n    title=\"Verify archive data\"\n    description=\"Verify the integrity of the data in a particular snapshot.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/archive/guides/stacks-blockchain\"\n    title=\"Stacks blockchain\"\n    description=\"Quickly spin up a new Stacks node.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/archive/guides/stacks-api\"\n    title=\"Stacks Blockchain API\"\n    description=\"Spin up a new instance of the Stacks Blockchain API.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/archive/guides/token-metadata-api\"\n    title=\"Token Metadata API\"\n    description=\"Spin up a new instance of the Token Metadata API.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Use the Stacks Blockchain API archive",
    "description": "Discover how to use the Hiro Archive to spin up a Stacks Blockchain API.",
    "slug": "/stacks/archive/guides/stacks-api",
    "content": "\n## Prerequisites\n\nSince the Stacks Blockchain API depends on a Stacks blockchain node being at the same block height, you will need to first [restore a Stacks blockchain node using the Hiro Archive](/stacks/archive/guides/stacks-blockchain) before restoring the Stacks Blockchain API. Otherwise, you may encounter errors when running the API.\n\nIn order for the Stacks blockchain and Stacks Blockchain API archives to be compatible, they must meet the following criteria:\n\n- Both archives correspond to the same Stacks network (mainnet/testnet).\n- The API archive version must be compatible with the Stacks blockchain archive version (See [API release notes](https://github.com/hirosystems/stacks-blockchain-api/releases) for guidance).\n- Both archives were created on the same date.\n\n## Restoration methods\n\nThere are two ways to restore a Stacks Blockchain API using the Hiro Archive. The archive file you'll need to download will depend on your method of restoration. There is no scenario where you would need both restoration methods.\n\n**Restore via Postgres database dump (Recommended)**\n\nThis is the quickest and most direct method, and it is suitable for most scenarios. It consists of a backup of the API's Postgres database taken using `pg_dump`. We generally recommend starting with this method before attempting the method below if this one does not work for any reason.\n\n**Restore via tab-separated-values (TSV) file**\n\nThis method is several times slower than restoring from a Postgres dump. The API TSV file contains the raw unprocessed events from a Stacks blockchain node. The API can ingest this file to process events into a Postgres database.\nRestoring from a TSV file can be useful when a Postgres database archive for a particular API version is not available or when it cannot be used for any reason.\n\n## Where to download archives\n\nDepending on the restoration method used above, the Stacks Blockchain API archives for each network can be found at the following locations:\n\n- Postgres database dump\n  - mainnet: https://archive.hiro.so/mainnet/stacks-blockchain-api-pg/\n  - testnet: https://archive.hiro.so/testnet/stacks-blockchain-api-pg/\n- TSV file\n  - mainnet: https://archive.hiro.so/mainnet/stacks-blockchain-api/\n  - testnet: https://archive.hiro.so/testnet/stacks-blockchain-api/\n\nThe file name patterns are as follows:\n\n- Postgres database dump\n  - archive: `stacks-blockchain-api-pg-<DATABASE VERSION>-<API VERSION>-<DATE(YYYYMMDD)>.dump`\n  - shasum: `stacks-blockchain-api-pg-<DATABASE VERSION>-<API VERSION>-<DATE(YYYYMMDD)>.sha256`\n- TSV file\n  - archive: `<network>-stacks-blockchain-api-<API VERSION>-<DATE(YYYYMMDD)>.gz`\n  - shasum: `<network>-stacks-blockchain-api-<API VERSION>-<DATE(YYYYMMDD)>.sha256`\n\nThere is a continually updated archive and shasum which always points to the most recent upload:\n\n- Postgres database dump\n  - archive: `stacks-blockchain-api-pg-<DATABASE VERSION>-latest.dump`\n  - shasum: `stacks-blockchain-api-pg-<DATABASE VERSION>-latest.sha256`\n- TSV file\n  - archive: `<network>-stacks-blockchain-api-latest.gz`\n  - shasum: `<network>-stacks-blockchain-api-latest.sha256`\n\nor the most recent upload for a particular version:\n\n- Postgres database dump\n  - archive: `stacks-blockchain-api-pg-<DATABASE VERSION>-<API VERSION>-latest.dump`\n  - shasum: `stacks-blockchain-api-pg-<DATABASE VERSION>-<API VERSION>-latest.sha256`\n- TSV file\n  - archive: `<network>-stacks-blockchain-api-<API VERSION>-latest.gz`\n  - shasum: `<network>-stacks-blockchain-api-<API VERSION>-latest.sha256`\n\n## Restoring the Stacks Blockchain API using the Hiro Archive\n\n**If restoring via Postgres dump**\n\n1. Download the archive and shasum for the appropriate network and restoration method.\n1. [Verify the archive](/stacks/archive/guides/verify-archive-data) with the shasum.\n1. Import the archive file into a running Postgres database (may take up to an hour depending on database specs and tuning):\n   ```terminal\n   $ export PGPASSWORD=<YOUR POSTGRES PASSWORD>\n   $ pg_restore --username postgres --verbose --jobs 4 --dbname stacks_blockchain_api /path/to/archive/file\n   ```\n1. Launch the Stacks Blockchain API service.\n1. Verify the dataset is being used by comparing your nodes [local block height](http://localhost:3999/extended/v1/status) with [Hiro's](https://api.hiro.so/extended/v1/status). If the block height matches or is close to Hiro's block height, the restoration was successful.\n   1. It may take a few minutes for the local node to respond on this endpoint.\n   1. Your block height may be up to a few hundred blocks away from Hiro's depending on the age of the archive. It should catch up relatively quickly.\n\n**If restoring via TSV file**\n\n1. Download the archive and shasum for the appropriate network and restoration method.\n1. [Verify the archive](/stacks/archive/guides/verify-archive-data) with the shasum.\n1. Extract the archive into the desired directory:\n   ```terminal\n   $ gzip -d <ARCHIVE FILE> --stdout > /path/to/extracted/file\n   ```\n1. [Follow these directions](https://github.com/hirosystems/stacks-blockchain-api#export-and-import) to process and import the events in the TSV file into your Postgres database.\n1. Launch the Stacks Blockchain API service.\n1. Verify the dataset is being used by comparing your nodes [local block height](http://localhost:3999/extended/v1/status) with [Hiro's](https://api.hiro.so/extended/v1/status). If the block height matches or is close to Hiro's block height, the restoration was successful.\n   1. It may take a few minutes for the local node to respond on this endpoint.\n   1. Your block height may be up to a few hundred blocks away from Hiro's depending on the age of the archive. It should catch up relatively quickly.\n"
  },
  {
    "title": "Use the Token Metadata API archive",
    "description": "Discover how to use the Hiro Archive to spin up a Token Metadata API.",
    "slug": "/stacks/archive/guides/token-metadata-api",
    "content": "\n## Prerequisites\n\nSince the Token Metadata API depends on a Stacks Blockchain API, you will need to first launch a Stacks Blockchain API configured for the same Stacks network.\n\nIf you don't already have one, you can follow [these instructions](/stacks/archive/guides/stacks-blockchain) to launch one with an archive.\n\n## Where to download archives\n\nToken Metadata API archives for each network can be found at the following locations:\n\n- mainnet: https://archive.hiro.so/mainnet/token-metadata-api-pg/\n- testnet: https://archive.hiro.so/testnet/token-metadata-api-pg/\n\nThe file name patterns are as follows:\n\n- archive: `token-metadata-api-pg-<DATABASE VERSION>-<API VERSION>-<DATE(YYYYMMDD)>.dump`\n- shasum: `token-metadata-api-pg-<DATABASE VERSION>-<API VERSION>-<DATE(YYYYMMDD)>.sha256`\n\nThere is a continually updated archive and shasum which always points to the most recent upload:\n\n- archive: `token-metadata-api-pg-<DATABASE VERSION>-latest.dump`\n- shasum: `token-metadata-api-pg-<DATABASE VERSION>-latest.sha256`\n\nor the most recent upload for a particular version:\n\n- archive: `token-metadata-api-pg-<DATABASE VERSION>-<API VERSION>-latest.dump`\n- shasum: `token-metadata-api-pg-<DATABASE VERSION>-<API VERSION>-latest.sha256`\n\n## Restoring the Token Metadata API using the Hiro Archive\n\n1. Download the archive and shasum for the appropriate network.\n1. [Verify the archive](/stacks/archive/guides/verify-archive-data) with the shasum.\n1. Import the archive file into a running Postgres database (may take up to an hour depending on database specs and tuning):\n   ```terminal\n   $ export PGPASSWORD=<YOUR POSTGRES PASSWORD>\n   $ pg_restore --username postgres --verbose --jobs 4 --dbname token_metadata_api /path/to/archive/file\n   ```\n1. Launch the Token Metadata API service.\n1. Verify the restoration was successful by viewing the [total number of tokens and contracts tracked in the service.](http://localhost:3000/metadata) If the total number of each property is greater than zero, the restoration was successful.\n   1. It may take a few minutes for the local node to respond on this endpoint.\n"
  },
  {
    "title": "Verify archive data",
    "description": "Verify the integrity of the data in a particular snapshot.",
    "slug": "/stacks/archive/guides/verify-archive-data",
    "content": "\nAll datasets have an associated SHA256 hash file which can be used to verify the integrity of the downloaded dataset.\nAs some of the archives are quite large, this is useful to ensure the file you've downloaded matches the file maintained in the Hiro Archive.\n\nAfter downloading an archive file and its associated shasum file, you can verify the integrity of the archive file like so:\n\n```terminal\n$ echo \"$(cat <SHASUM FILE> | awk '{print $1}')  <ARCHIVE FILE>\" | shasum --check\n<ARCHIVE FILE>: OK\n\n$ echo \"$(cat mainnet-stacks-blockchain-api-latest.sha256 | awk '{print $1}')  mainnet-stacks-blockchain-api-latest.gz\" | shasum --check\n\nmainnet-stacks-blockchain-api-latest.gz: OK\n\n# Otherwise a log will be printed indicating failure\nmainnet-stacks-blockchain-api-latest.gz: FAILED\nshasum: WARNING: 1 computed checksum did NOT match\n```\n\n<Callout title=\"Note\" type=\"warn\">\nIf the integrity check fails for any reason, you may need to delete the local archive and re-attempt the download. If issues persist, switch to a different network and try again.\n</Callout>"
  },
  {
    "title": "Use the Stacks blockchain archive",
    "description": "Discover how to use the Hiro Archive to spin up a Stacks node.",
    "slug": "/stacks/archive/guides/stacks-blockchain",
    "content": "\n## Where to download archives\n\nStacks blockchain archives for each network can be found at the following locations:\n\n- mainnet: https://archive.hiro.so/mainnet/stacks-blockchain/\n- testnet: https://archive.hiro.so/testnet/stacks-blockchain/\n\nThe file name patterns are as follows:\n\n- archive: `<NETWORK>-stacks-blockchain-<VERSION>-<DATE(YYYYMMDD)>.tar.gz`\n- shasum: `<NETWORK>-stacks-blockchain-<VERSION>-<DATE(YYYYMMDD)>.sha256`\n\nThere is a continually updated archive and shasum which always points to the most recent upload:\n\n- archive: `<NETWORK>-stacks-blockchain-latest.tar.gz`\n- shasum: `<NETWORK>-stacks-blockchain-latest.sha256`\n\nor the most recent upload for a particular version:\n\n- archive: `<NETWORK>-stacks-blockchain-2.3.0.0.2-latest.tar.gz`\n- shasum: `<NETWORK>-stacks-blockchain-2.3.0.0.2-latest.sha256`\n\n## Restoring a Stacks blockchain node using the Hiro Archive\n\n1. Download the archive and shasum for the appropriate network.\n1. [Verify the archive](/stacks/archive/guides/verify-archive-data) with the shasum.\n1. Extract the archive into the desired directory:\n   ```terminal\n   $ tar -zxvf <ARCHIVE FILE> -C /target/directory\n   ```\n1. [Configure the `working_dir` property](https://docs.stacks.co/docs/nodes-and-miners/stacks-node-configuration#node) in your Stacks blockchain node Config.toml file to match the directory you extracted the archive to.\n1. Launch your Stacks blockchain node. You can use [one of these example configuration files](https://github.com/stacks-network/stacks-blockchain/tree/master/testnet/stacks-node/conf) as a reference.\n1. Verify the dataset is being used by comparing your nodes [local block height](http://localhost:20443/v2/info) with [Hiro's](https://api.hiro.so/v2/info). If the block height matches or is close to Hiro's block height, the restoration was successful.\n   1. It may take a few minutes for the local node to respond on this endpoint.\n   1. Your block height may be up to a few hundred blocks away from Hiro's depending on the age of the archive. It should catch up relatively quickly.\n"
  },
  {
    "title": "Overview",
    "description": "Clarinet is a local development environment that offers everything you need to create, test, and deploy smart contracts on Stacks.",
    "slug": "/stacks/clarinet/index",
    "content": "\nimport { ArrowUpRight } from \"lucide-react\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\nimport { SecondaryCard } from \"@/components/card\";\n\nUsing a simple command line interface, Clarinet enables you to build and iterate on your contracts locally before moving into production on the `mainnet` network.\n\nYou can code with <TooltipProvider inline><Tooltip><TooltipTrigger asChild><span className='cursor-default border-b border-dotted border-primary'>Clarity syntax support</span></TooltipTrigger><TooltipContent>Using the [Clarity VSCode extension](https://marketplace.visualstudio.com/items?itemName=HiroSystems.clarity-lsp#:~:text=This%20VS%20Code%20extension%20brings,safety%20checks%2C%20debugger%20and%20more)</TooltipContent></Tooltip></TooltipProvider>, run tests, debug your code line by line, and deploy your contracts to a local Stacks blockchain environment to rapidly iterate on your code.\n\n## Installation\n\n<TerminalPicker storage=\"macOs\">\n\n```terminal !! macOS\n$ brew install clarinet\n```\n\n```terminal !! Windows\n$ winget install clarinet\n```\n\n```terminal !! Cargo\n$ sudo apt install build-essential pkg-config libssl-dev\n```\n\n```terminal !! Pre-built binary\n$ wget -nv https://github.com/hirosystems/clarinet/releases/download/v0.27.0/clarinet-linux-x64-glibc.tar.gz -O clarinet-linux-x64.tar.gz\n$ tar -xf clarinet-linux-x64.tar.gz\n$ chmod +x ./clarinet\n$ mv ./clarinet /usr/local/bin\n```\n\n</TerminalPicker>\n\n## Set up shell completions\n\nClarinet already has many different commands built in. Therefore, enabling tab completion in your shell may be useful. Using the command below, you can use `clarinet` to generate the shell completion scripts for many common shells.\n\n```terminal\n$ clarinet completions (bash|elvish|fish|powershell|zsh)\n```\n\nAfter generating the file, you can refer to the documentation for your shell to determine where this file should be moved to and what other steps may be necessary to enable tab completion for `clarinet`.\n\n## Guides\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/clarinet/guides/create-a-new-project\"\n    title=\"Create a new contract\"\n    description=\"Add new contracts to your project and have them automatically configured in your project file.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/clarinet-js-sdk/guides/unit-testing\"\n    title=\"Write unit tests\"\n    description=\"Leverage the Clarinet JS SDK to write comprehensive unit tests, ensuring your contract performs as expected.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/clarinet/guides/create-deployment-plans\"\n    title=\"Create deployment plans\"\n    description=\"Employ customizable deployment plans to streamline your contract deployments.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/clarinet/guides/run-a-local-devnet\"\n    title=\"Run a local development environment\"\n    description=\"Set up a local devnet environment for developing and testing in a controlled environment before deployment.\"\n  />\n</Cards>\n\n## Related tools\n\n- **[Clarinet JS SDK](/stacks/clarinet-js-sdk)**: Simplify your testing with the Clarinet JS SDK.\n- **[Hiro Platform](/stacks/platform)**: A developer platform for building, deploying and scaling Bitcoin apps.\n- **[Stacks.js](/stacks/stacks.js)**: Leverage a JavaScript library that handles basic functions, such as user authentication and transaction signing.\n\n<br />\n\n<Callout title=\"Need help building with Clarinet?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#clarinet</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>\n"
  },
  {
    "title": "Concepts",
    "description": "Learn about the concepts behind Clarinet.",
    "slug": "/stacks/clarinet/concepts",
    "content": "\n## Network types\n\nClarinet supports different network types to cater to various development and testing needs:\n\n| Network          | Description                                                                      | Use case\n| -------------- | ------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |\n| `simnet`       | Optimized for fast feedback loops, introspection, and portability. | Ideal for initial development and unit-testing. |\n| `devnet`       | Local Stacks and Bitcoin nodes running on Docker for faster feedback loops. | Use for integration tests or local frontend development. |\n| `testnet`      | A pre-production network that offers a realistic environment for testing. | Ideal for final testing before deploying to Mainnet. |\n| `mainnet`      | The production network where real transactions occur. | Use when you're ready to deploy your smart contract to production. |\n\n## Deployment plans\n\nThe default deployment plan of every Clarinet project is contained within specifications set inside certain files. In addition to this default deployment plan, the user can manually configure each plan, adding additional transactions or contract calls across multiple Stacks or Bitcoin blocks.\n\nYou can commit, audit, and test contracts without including any secrets in the deployment plan, and you can share these contracts without exposing any sensitive information.\n\n### Primitives\n\n| Transaction primitive   | Typical usage                                                                                                                                                                                                               |\n| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Publish contracts       | Deploy contracts to an in-memory simulated Stacks chain, public networks like testnet and mainnet, or deploy external contracts to your local network for testing purposes. |\n| Call contract functions | Call a contract deployed to any of your local devnets or public networks.                                                                                                                                                  |\n| Send BTC                | Perform a simple bitcoin transfer from a p2pkh address to a p2pkh address.                                                                                                                       |\n| Wait for block          | Test or automate contract deployment across multiple Stacks or Bitcoin blocks.                                                                                                                                             |\n| Send STX                | Send stacks to an address or contract.                                                                                                                                                                                     |"
  },
  {
    "title": "Add a contract",
    "description": "Clarinet can handle adding and configuring a new contract to your project.",
    "slug": "/stacks/clarinet/examples/add-a-contract",
    "content": "\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\n\nTo add a new contract, run the `clarinet contract new` command, along with your contract name, inside your project.\n\n```terminal\n$ clarinet contract new my-contract\n```\n\n## Project structure\n\n**Clarinet** will add 2 files to your project: `my-contract.clar` and `my-contract.test.ts`.\n\n<Files className='pointer-events-none'>\n  <Folder name=\"contracts\" defaultOpen>\n    <File name=\"my-contract.clar\" className='bg-[hsl(var(--highlight))]' />\n  </Folder>\n  <Folder name=\"settings\" />\n  <Folder name=\"tests\" defaultOpen>\n    <File name=\"my-contract.test.ts\" className='bg-[hsl(var(--highlight))]' />\n  </Folder>\n  <File name=\".gitignore\" />\n  <File name=\"Clarinet.toml\" />\n  <File name=\"package.json\" />\n  <File name=\"tsconfig.json\" />\n  <File name=\"vitest.config.js\" />\n</Files>\n\n**Clarinet** will also add the configuration to the `Clarinet.toml` file for your contract.\n\n```toml\n[contracts.my-contract]\npath = 'contracts/my-contract.clar'\nclarity_version = 2\nepoch = 2.4\n```\n\n<Callout title=\"Adding contracts manually\">\nYou can also add contracts to your project by adding the files manually. However, you must add the appropriate configuration to `Clarinet.toml` in order for **Clarinet** to recognize the contracts.\n</Callout>"
  },
  {
    "title": "Validate a contract",
    "description": "Clarinet provides syntax and semantics checkers for the smart contract language Clarity.",
    "slug": "/stacks/clarinet/examples/validate-a-contract",
    "content": "\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\n\nValidate the syntax and semantics of your contracts:\n\n```terminal\n$ clarinet check\n\u001b[32m✔\u001b[0m \u001b[1m1 contract checked\u001b[0m\n$ clarinet check path/to/my-contract.clar\n\u001b[32m✔\u001b[0m \u001b[1m1 contract checked\u001b[0m\n```\n\nThis command uses the _txt`Clarinet.toml`_ file to locate and analyze all the contracts in the project. If the Clarity code is valid, the command will indicate success with the response below.\n\n<Callout title=\"Note\">\nThe _console`clarinet check`_ command may also report warnings indicating the code is valid.\n</Callout>"
  },
  {
    "title": "Estimating contract costs",
    "description": "Analyze execution costs pertaining to your contract.",
    "slug": "/stacks/clarinet/examples/estimate-costs",
    "content": "\nimport { API, Clarinet, Js } from '@/components/ui/icon';\nimport { File, Folder, Files } from \"fumadocs-ui/components/files\"\n\nTransactions on the Stacks blockchain comes with execution costs that can dictate transaction fees for your users. To analyze the execution costs of your contract's functions, let's continue with the simple `counter` contract from the [Clarinet quickstart](/stacks/clarinet/quickstart) as an example.\n\n```clarity\n(define-map Counters principal uint)\n\n(define-read-only (get-count (who principal))\n  (default-to u0 (map-get? Counters who))\n)\n\n(define-public (count-up)\n  (ok (map-set Counters tx-sender (+ (get-count tx-sender) u1)))\n)\n```\n\nTo start analyzing execution costs, first run the `clarinet console` command inside your project.\n\n```terminal\n$ clarinet console\n```\n\n## Get Costs\n\nThe `::get_costs <expr>` command in the Clarinet console will display the cost analysis of the given expression as well as the return value of the given expression. The `::get_costs` command expects an expression, so make a `contract-call?` with our `count-up` function and see what happens.\n\n```terminal\n$ ::get_costs (contract-call? .counter count-up)\n+----------------------+-------------+----------------+-----------------+\n|                               | Consumed   | Limit              | Percentage       |\n+----------------------+-------------+----------------+-----------------+\n| Runtime                  | 4752           | 5000000000    | 0.00 %              |\n+----------------------+-------------+----------------+-----------------+\n| Read count              | 5                | 15000             | 0.03 %              |\n+----------------------+-------------+----------------+-----------------+\n| Read length (bytes) | 245             | 100000000      | 0.00 %             |\n+----------------------+-------------+----------------+-----------------+\n| Write count             | 1                 | 15000              | 0.01 %            |\n+----------------------+-------------+----------------+-----------------+\n| Write length (bytes) | 41              | 15000000        | 0.00 %             |\n+----------------------+-------------+----------------+-----------------+\n\n\n(ok true)\n```\n\nAs you can see from the chart, execution costs are broken into 5 different categories, each with its own limit. The limit is pertaining to what each Stacks block is limited to.\n\n<Callout title=\"Execution Cost Categories\">\nThe below lists out each of the 5 different categories of Clarity execution costs. ([source](https://book.clarity-lang.org/ch12-00-runtime-cost-analysis.html))\n\n- **Runtime** costs limits overall complexity of the code that can be executed. For example, negating a boolean value is less complex than calculating SHA512 hash, therefore (not false) will consume less runtime costs than (sha512 \"hello world\"). This category is also affected by contract size.\n- **Read count** limits how many times we can read from memory or chain state to a extract piece of information. It is affected by reading constants, variables, intermediate variables created with let, maps, but also by some functions that needs to save intermediate results during execution.\n- **Read length (bytes)** limits how much data we can read from memory or the chain. It is also affected by contract size. Calling into a contract using contract-call? Increases the read length by an amount equal to the contract size in bytes, every time. If you call into a contract with a length of 2,000 bytes twice, the read length is increased twice.\n- **Write count** limits how many times we can write data into chain. It increments when writing to variables and maps.\n- **Write length (bytes)** limits how much data we can write to the chain.\n\n</Callout>\n\nThe percentage column shows what percentage of the execution costs your expression consumed out of the block limit given.\n\n## Toggle costs\n\nYou can toggle the cost analysis to always be displayed after every expression execution in the console by toggling this feature on with the command `::toggle_costs`.\n\n```terminal\n$ ::toggle_costs\n```\n\nTo turn it off, just run the `::toggle_costs` command again.\n\nCheck out the Clarity Book section on [runtime cost analysis](https://book.clarity-lang.org/ch12-00-runtime-cost-analysis.html) to read up on cost optimization techniques and recommendations.\n\nTo see how you can run automated cost analysis on your unit tests, check out our [quickstart](/stacks/clarinet-js-sdk/quickstart#run-your-tests-with-code-coverage-and-cost-analysis) section for the Clarinet JS SDK.\n\n<Cards>\n  <SecondaryCard\n    icon={<Clarinet />}\n    href=\"/stacks/clarinet/guides/cli-commands/validate-a-contract\"\n    title=\"Validate a contract\"\n    description=\"Learn how to validate a contract.\"\n    tag='Clarinet'\n  />\n  <SecondaryCard\n    icon={<API />}\n    href=\"/stacks/rpc-api/fees/estimate\"\n    title=\"Get fee estimates for a transaction\"\n    description=\"Learn how to fetch transaction costs.\"\n    tag='API'\n  />\n  <SecondaryCard\n    icon={<Js />}\n    href=\"/stacks/clarinet-js-sdk/quickstart\"\n    title=\"Write tests for your smart contracts\"\n    description=\"Learn how to write unit tests using the Clarinet JS SDK.\"\n    tag='Clarinet JS SDK'\n  />\n</Cards>"
  },
  {
    "title": "Start development console",
    "description": "Launch the Clarinet console for interactive development.",
    "slug": "/stacks/clarinet/examples/start-a-development-console",
    "content": "\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\n\nLaunch the Clarinet console for interactive development:\n\n```terminal\n$ clarinet console\n```\n\nThis commands starts a new interactive REPL session so you can interact with your contracts."
  },
  {
    "title": "Run a local devnet",
    "description": "Integrate your contracts with a local development environment.",
    "slug": "/stacks/clarinet/examples/run-a-local-devnet",
    "content": "\nLaunch a local development network with all required services:\n\n```terminal\n$ clarinet devnet start\n```\n\nRequires Docker to be running locally. See [installing Docker](/guides/install-docker) guide for more information.\n\n<Callout title=\"Common errors\" type=\"warn\">\n  <p>If you are getting `error: clarinet was unable to create network`, make sure you have a container service running locally.</p>\n</Callout>"
  },
  {
    "title": "Deploy a contract",
    "description": "Use Clarinet to publish your contracts to the devnet, testnet, or mainnet networks.",
    "slug": "/stacks/clarinet/examples/deploy-a-contract",
    "content": "\nGenerate a deployment plan:\n\n```terminal\n$ clarinet deployments generate --<network>\n```\nSupported networks: console`devnet`_, console`testnet`_, console`mainnet`_\n\nDeploy contracts:\n\n```terminal\n$ clarinet deployments apply --<network>\n```\n\n## Add Contract Requirements\nAdd external contract dependencies:\n\n```terminal\n$ clarinet requirements add <contract-principal>\n```\n\nExample:\n```terminal\n$ clarinet requirements add SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait\n```\n\n## Deployment Plan Transactions\n\nYour deployment plans can include various transaction types:\n\n### Contract Operations\n```yaml\n- contract-publish:\n    contract-name: my-contract\n    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    cost: 5960\n    path: contracts/my-contract.clar\n    clarity-version: 2\n\n- contract-call:\n    contract-id: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.my-contract\n    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    method: my-function\n    parameters: []\n    cost: 5960\n```\n\n### Asset Transfers\n```yaml\n- stx-transfer:\n    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    recipient: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.my-contract\n    mstx-amount: 1000\n    memo: '0x01'\n    cost: 10000\n\n- btc-transfer:\n    expected-sender: mjSrB3wS4xab3kYqFktwBzfTdPg367ZJ2d\n    recipient: bcrt1qnxknq3wqtphv7sfwy07m7e4sr6ut9yt6ed99jg\n    sats-amount: 100000000\n    sats-per-byte: 10\n```\n\n### Simnet Operations\n```yaml\n- emulated-contract-publish:\n    contract-name: my-contract\n    emulated-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    path: contracts/my-contract.clar\n    clarity-version: 2\n\n- emulated-contract-call:\n    contract-id: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.my-contract\n    emulated-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    method: my-function\n    parameters: []\n```\n\n<Callout title=\"Note\">\nFor functions that take no arguments or read-only functions, use an empty parameters list: `parameters: []`\n</Callout>"
  },
  {
    "title": "Debug a contract",
    "description": "Step through and debug your contracts inside the command line.",
    "slug": "/stacks/clarinet/examples/debug-a-contract",
    "content": "\nimport { Clarinet, Js } from '@/components/ui/icon';\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\n\nInside the console, you can use these debugging commands:\n\n```terminal\n$ ::trace (contract-call? .my-contract my-function)\n$ ::debug (contract-call? .my-contract my-function)\n$ break my-function\n```\n\nDebug navigation commands:\n- _console`step`_ or _console`s`_ - Step into\n- _console`finish`_ or _console`f`_ - Step out\n- _console`next`_ or _console`n`_ - Step over\n- _console`continue`_ or _console`c`_ - Continue execution\n\nLet's take the clarity_`counter`_ contract as an example:\n\n```clarity\n(define-map Counters principal uint)\n\n(define-read-only (get-count (who principal))\n  (default-to u0 (map-get? Counters who))\n)\n\n(define-public (count-up)\n  (ok (map-set Counters tx-sender (+ (get-count tx-sender) u1)))\n)\n```\n\n### Trace\n\nThe _console`::trace`_ command expects an expression, so make a _clarity`contract-call?`_ with our _clarity`count-up`_ function and see what happens.\n\n```terminal\n$ ::trace (contract-call? .counter count-up)\n(contract-call? .counter count-up)  \u001b[30m<console>\u001b[0m\n( get-count tx-sender )  \u001b[30mcounter:4:38\u001b[0m\n  \u001b[31m↳ args:\u001b[0m \u001b[1mST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\u001b[0m\n    \u001b[34mu0\u001b[0m\n\u001b[34m(ok true)\u001b[0m\n```\n\n### Breakpoints\n\nYou can also set a breakpoint at a specific line to better understand what's happening in your contract.\n\nWith `::debug`, you can add breakpoints at a specific line of a contract or function to better understand what's happening in your contracts.\n\n```clarity\n(define-map Counters principal uint)\n\n(define-read-only (get-count (who principal))\n  (default-to u0 (map-get? Counters who))\n)\n\n(define-public (count-up)\n  (ok (map-set Counters tx-sender (+ (get-count tx-sender) u1)))\n)\n\n;; !mark(1:3)\n(define-public (count-twice)\n  (double)\n)\n\n;; !mark(1:6)\n(define-private (double)\n  (begin\n    (unwrap-panic (count-up))\n    (count-up)\n  )\n)\n```\n\n```terminal\n$ ::debug (contract-call? .counter count-twice)\n$ break count-up\n```\n\n\n<Callout title=\"Breakpoint Commands\">\nTo step through these breakpoints, you can use one of the following commands:\n\n- **Step-in (`step` or `s`)**: Step into the sub-expressions.\n- **Step-out (`finish` or `f`)**: Complete execution of the current expression and return the result to the parent.\n- **Step-over (`next` or `n`)**: Continue to completion of the current expression, stepping over sub-expressions.\n- **Continue (`continue` or `c`)**: Continue execution until hitting a breakpoint or completing execution.\n</Callout>\n\nUsing the _console`continue`_ command, the breakpoint you set in the _clarity`double`_ function will trigger twice due to two _clarity`count-up`_ calls, which enables you to do variable and map analysis.\n\n## Next steps\n\n<Cards>\n  <SecondaryCard\n    icon={<Clarinet />}\n    href=\"/stacks/clarinet/guides/cli-commands/validate-a-contract\"\n    title=\"Validate a contract\"\n    description=\"Learn how to validate a contract.\"\n    tag='Clarinet'\n  />\n  <SecondaryCard\n    icon={<Js />}\n    href=\"/stacks/clarinet/guides/estimate-costs\"\n    title=\"Estimate costs for a contract\"\n    description=\"Learn how to estimate costs for a contract.\"\n    tag='Clarinet'\n  />\n  <SecondaryCard\n    icon={<Js />}\n    href=\"/stacks/clarinet-js-sdk/quickstart\"\n    title=\"Write tests for your smart contracts\"\n    description=\"Learn how to write unit tests using the Clarinet JS SDK.\"\n    tag='Clarinet JS SDK'\n  />\n</Cards>"
  },
  {
    "title": "Create deployment plans",
    "description": "Learn how to create deployment plans.",
    "slug": "/stacks/clarinet/examples/create-deployment-plans",
    "content": "\nimport { Clarinet, Js } from '@/components/ui/icon';\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\n\n\nDeployment plans minimize the inherent complexity of deployments, such as smart contract dependencies and interactions, transaction chaining limits, deployment costs, and more. Deployment plans ensure reproducible deployments, a critical workflow for testing purposes.\n\nIn this guide, you will learn how to:\n\n1. [Generate and configure a deployment plan.](#generate-a-deployment-plan)\n2. [Set deployment plan specifications.](#deployment-plan-specifications)\n3. [Add project contract requirements.](#adding-project-contract-requirements)\n4. [Customize your deployment plan.](#edit-your-deployment-plan)\n\n---\n\n## Generate a deployment plan\n\nClarinet uses a deployment plan for every deployment—whether for a basic `simnet`, `devnet` (for use with the `clarinet devnet start` command), or the public `testnet` and `mainnet`.\n\nYou can view the current deployment plan saved to disk at any time with the following command (specifying the network `simnet`, `devnet`, `testnet`, `mainnet`)\n\n```terminal\n$ clarinet deployments generate --<network>\n```\n\nUpon this command, your project's default deployment plan, a `.yaml` file (for example, `default.devnet-plan.yaml`), is generated from your project specifications and contracts. Here, for example, is the deployment plan for [the counter smart contract](/stacks/clarinet/quickstart) used in our quickstart guide:\n\n```yaml deployments/default.devnet-plan.yaml\n---\nid: 0\nname: Devnet deployment\nnetwork: devnet\nstacks-node: \"http://localhost:20443\"\nbitcoin-node: \"http://devnet:devnet@localhost:18443\"\nplan:\n  batches:\n    - id: 0\n      transactions:\n        - contract-publish:\n            contract-name: counter\n            expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n            cost: 6940\n            path: contracts/counter.clar\n            anchor-block-only: true\n            clarity-version: 2\n      epoch: \"2.5\"\n```\n\n## Deployment plan specifications\n\nA project's deployment plan specifications are set on two files within a Clarinet project—the `Clarinet.toml` file as well as the network’s corresponding `.toml` file (for example, `Devnet.toml`) in the `settings/` folder.\n\nSpecifications in the `Clarinet.toml` file you can change include:\n\n- The Clarity version or blockchain epoch that Clarinet emulates for your smart contracts\n- Project requirements in the form of contract dependencies (see next section)\n\nSpecifications in the `Devnet.toml` file you can change include:\n\n- Accounts, balances, and names\n- Blockchain environment features of your devnet, such as block time or API ports\n- Stacking orders\n- Specifying derivation path of a given account:\n\n```toml settings/devnet.toml\n[accounts.deployer]\nmnemonic = \"<YOUR PRIVATE TESTNET MNEMONIC HERE>\"\nbalance = 100_000_000_000_000\nderivation = \"m/44'/5757'/0'/0/2\"\n```\n\n## Adding project contract requirements\n\nYour project can reference a smart contract that already exists on the blockchain.\n\nFor example, [Stacks Improvement Proposal 009](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md) specifies a trait reference for all non-fungible tokens. Instead of redeploying this trait as a separate contract each time a new NFT collection is published, you can reference the contract directly within deployment plans with the following Clarinet command, including the contract principal reference:\n\n```terminal\n$ clarinet requirements add SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait\n```\n\nThis command updates a Clarinet project's deployment plan for use in development.\n\nFor instance, `clarinet devnet start` would now download a copy of the contract principal via the Stacks API node that is booted alongside each devnet deployment, and it would remap the principal that publishes this contract to one of the accounts specified in your `Devnet.toml` file.\n\nThis permits a developer to maintain the minimum set of contracts their Clarinet project will deploy to mainnet (with a single use of an `impl-trait` statement in their Clarity contract).\n\n## Edit your deployment plan\n\nRecall that a default deployment plan is used for every deployment, comprising your projects specifications as set in your `Clarinet.toml` and `<network>.toml` files.\n\nThe default plan is generated upon each `clarinet deployments generate --<network>` shell command to your `deployments/` folder.\n\nHowever, you can also manually edit this default deployment `.yaml` file directly—programmatically orchestrating your contract publication and user interaction beyond your plan's defaults.\n\n<Callout title=\"Note\">\nWhen deploying, Clarinet prompts you to overwrite any manually added or edited changes that differ from the specifications laid out in your project's .toml files. Type `no` to proceed with your manually configured deployment plan instead of the default.\n</Callout>\n\nHere are some of the relevant transactions and configurations available to developers manually configuring their deployment plans:\n\n[`emulated-contract-publish:`](#emulated-contract-publish) Deploy a contract in an in-memory simulated chain.\n\n[`emulated-contract-call:`](#emulated-contract-call) Call a contract that has been deployed in an in-memory simulated chain.\n\n[`requirement-publish:`](#requirement-publish) <TooltipProvider inline><Tooltip><TooltipTrigger asChild><span className='cursor-default border-b border-dotted border-primary'>Deploy an external contract</span></TooltipTrigger><TooltipContent>One that is not published by the same set of private keys as the user wallet currently deploying.</TooltipContent></Tooltip></TooltipProvider> on another `testnet`/`devnet` using another wallet.\n\n[`contract-publish:`](#contract-publish) Deploy a contract.\n\n[`contract-call:`](#contract-call) Call a contract.\n\n[`stx-transfer:`](#stx-transfer) Transfer STX between specified accounts.\n\n[`btc-transfer:`](#btc-transfer) Simple bitcoin transfer from a p2pkh address to a p2pkh address (experimental, `regtest`/`testnet`/`mainnet`).\n\n### emulated-contract-publish\n\nThis default transaction is included in every generated deployment for a `simnet` deployment.\n\n```yaml\n- emulated-contract-publish:\n    contract-name: extension-trait\n    emulated-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    path: contracts/dao/traits/extension-trait.clar\n    clarity-version: 1\n```\n\n### emulated-contract-call\n\nThis is a transaction type for a `simnet` deployment where the developer wants to emulate a contract call.\n\n```yaml\n- emulated-contract-call:\n    contract-id: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.counter\n    emulated-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    method: increment\n    parameters:\n      - u1\n```\n\n<Callout title=\"Note\">\nRead-only functions and functions that take no arguments are passed an empty list like so: `parameters: []`\n</Callout>\n\n### requirement-publish\n\nThis cBTC smart contract application has a [devnet deployment plan](https://github.com/hirosystems/clarinet/blob/develop/components/clarinet-cli/examples/cbtc/deployments/default.devnet-plan.yaml) that publishes the contract required by its core smart contract.\n\n```yaml\n- requirement-publish:\n    contract-id: SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard\n    remap-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    remap-principals:\n      SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    cost: 8400\n    path: '.cache/requirements/SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.clar'\n```\n\n### contract-publish\n\nThis default transaction is included in every generated deployment plan for every contract your Clarinet project has. This `counter` application has a [devnet deployment plan](https://github.com/hirosystems/clarinet/blob/develop/components/clarinet-cli/examples/counter/deployments/default.devnet-plan.yaml) that publishes its core smart contract.\n\n```yaml\n- contract-publish:\n    contract-name: counter\n    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    cost: 5960\n    path: contracts/counter.clar\n    anchor-block-only: true\n    clarity-version: 1\n```\n\n### contract-call\n\nThe developer can call a function and pass arguments of any valid Clarity type.\n\n```yaml\n- contract-call:\n    contract-id: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.bitcoin-dao\n    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    method: add-new-member\n    parameters:\n        - u1\n        - \"0x01\"\n        - \"{ id: u4, username: \"Satoshi\", address: 'SP1HTBVD3JG9C05J7HBJTHGR0GGW7KXW28M5JS8QE }\"\n        - \"'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\"\n    cost: 5960\n```\n\n<Callout title=\"Note\">\nRead-only functions and functions that take no arguments are passed an empty list like so: `parameters: []`\n</Callout>\n\n### stx-transfer\n\nThe developer can specify the originating account of an STX transfer, the quantity denominated in microstacks, and the recipient, as well as an optional memo field (Note: the memo field can only contain a Clarity [buffer type](https://book.clarity-lang.org/ch02-02-sequence-types.html) up to 34 bytes in size, pre-fixed with `0x` (for example, `0x68656c6c6f21`), not ASCII text or strings)\n\n```yaml\n- stx-transfer:\n    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n    recipient: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.my-contract\n    mstx-amount: 1000\n    memo: '0x01'\n    cost: 10000\n```\n\n### btc-transfer\n\nThis cBTC smart contract application has a [devnet deployment plan](https://github.com/hirosystems/clarinet/blob/develop/components/clarinet-cli/examples/cbtc/deployments/wrap-btc.devnet-plan.yaml) that includes broadcasting a BTC transfer transaction to the emulated bitcoin chain with these parameters.\n\n```yaml\n- btc-transfer:\n    expected-sender: mjSrB3wS4xab3kYqFktwBzfTdPg367ZJ2d\n    recipient: bcrt1qnxknq3wqtphv7sfwy07m7e4sr6ut9yt6ed99jg\n    sats-amount: 100000000\n    sats-per-byte: 10\n```\n\n---\n\n## Next steps\n\n<Cards>\n  <SecondaryCard\n    icon={<Clarinet />}\n    href=\"/stacks/clarinet/guides/cli-commands/run-a-local-devnet\"\n    title=\"Run a local devnet\"\n    description=\"Learn how to run a local devnet.\"\n    tag='Clarinet'\n  />\n  <SecondaryCard\n    icon={<Js />}\n    href=\"/stacks/clarinet-js-sdk/references/simnet\"\n    title=\"Simnet reference\"\n    description=\"Learn how to use simnet with the Clarinet JS SDK.\"\n    tag='Clarinet JS SDK'\n  />\n</Cards>"
  },
  {
    "title": "Working with sBTC",
    "description": "Clarinet helps with building, testing, and deploying contracts that use sBTC.",
    "slug": "/stacks/clarinet/examples/working-with-sbtc",
    "content": "\nTo take advantage of these features, make sure to use Clarinet 2.15.0 or later.\n\n## About sBTC\n\nsBTC is a fungible token on the Stacks blockchain. It follows the\n[SIP-010 standard](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md)\nfor fungible tokens.\n\nEven though it's *just* a fungible token, Clarinet has some helpers to make it easier to work with.\n\n## Using sBTC in your contract\n\nTo use sBTC in your contract, you need to add the `sbtc-deposit` smart contract to your requirements.\n\nIn a Clarinet project, run the following command:\n\n```terminal\n$ clarinet requirements add SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-deposit\n```\n\nThis will add the [`sbtc-deposit`](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-deposit)\nsmart contract to your project, along with it's dependencies:\n- [`sbtc-token`](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token)\n- [`sbtc-registry`](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-registry)\n\nWhen Clarinet detects the `sbtc-deposit` contract, it will automatically fund your test wallets with \nsBTC that you can use to test your contract in Clarinet simnet and devnet.\n\n## Using sBTC in your contract\n\nAs a SIP-010 token, sBTC let you call the `transfer` function to transfer tokens from one address to another.\n\nLet's say we have an NFT contract that allows users to mint an NFT by spending sBTC.  \n\n\n```clarity\n;; this code is for demo purposes\n;; it doesn't implement SIP-009 NFT standard\n(define-non-fungible-token nft-name uint)\n\n;; mint for 100 sats\n(define-data-var sats-sbtc-mint-price uint u100)\n(define-data-var next-id uint u0)\n\n(define-public (mint-one-with-sbtc)\n  (begin\n    ;; call the sbtc-token contract to transfer the sbtcs\n    (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer\n      (var-get sats-sbtc-mint-price)\n      tx-sender\n      (as-contract tx-sender)\n      none\n    ))\n\n    (try! (nft-mint? nft-name (var-get next-id) tx-sender))\n\n    (ok (var-set next-id (+ (var-get next-id) u1)))\n  )\n)\n```\n\nBecause Clarinet already took care of funding the test wallets with sBTC, you can call the\n`mint-one-with-sbtc` function with one of your test wallets.\n\nIn simnet (unit tests or `clarinet console`), the deployer address of the contract will remain\n`SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4`, but in devnet, like every other requirements, the contract will\nbe deployed by the default deployer address. You don't have to worry about this—Clarinet always make\nsure that your contracts call the right address.\n\n## Deploying your contract on testnet\n\nOn testnet, the official Hiro sBTC contract is\n[ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-token](https://explorer.hiro.so/txid/ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-token?chain=testnet).\nThis is the contract that is linked to the sBTC faucet: `ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-deposit`.\n\nAgain, Clarinet will make sure that your contracts call this address when being deployed on mainnet.\nYou can see the address of the sbtc-contract being re-mapped in the testnet deployment plan.\n\n## Deploying your contract on mainnet\n\nOn mainnet, your contract will remain unchanged and call the one and only sBTC contract.\n"
  },
  {
    "title": "Create a new project",
    "description": "Once you install Clarinet, you can use Clarinet to create a new project.",
    "slug": "/stacks/clarinet/examples/create-a-new-project",
    "content": "\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\n\nCreate a new Clarinet project with the basic directory structure and configuration files:\n\n```terminal\n$ clarinet new my-project\n\u001b[32mCreate directory\u001b[0m \u001b[1mmy-project\u001b[0m\n\u001b[32mCreate directory\u001b[0m \u001b[1mcontracts\u001b[0m\n\u001b[32mCreate directory\u001b[0m \u001b[1msettings\u001b[0m\n\u001b[32mCreate directory\u001b[0m \u001b[1mtests\u001b[0m\n\u001b[32mCreate file\u001b[0m \u001b[1mClarinet.toml\u001b[0m\n\u001b[32mCreate file\u001b[0m \u001b[1msettings/Mainnet.toml\u001b[0m\n\u001b[32mCreate file\u001b[0m \u001b[1msettings/Testnet.toml\u001b[0m\n\u001b[32mCreate file\u001b[0m \u001b[1msettings/Devnet.toml\u001b[0m\n\u001b[32mCreate directory\u001b[0m \u001b[1m.vscode\u001b[0m\n\u001b[32mCreate file\u001b[0m \u001b[1m.vscode/settings.json\u001b[0m\n\u001b[32mCreate file\u001b[0m \u001b[1m.vscode/tasks.json\u001b[0m\n\u001b[32mCreate file\u001b[0m \u001b[1m.gitignore\u001b[0m\n\u001b[32mCreate file\u001b[0m \u001b[1m.gitattributes\u001b[0m\n\u001b[32mCreate file\u001b[0m \u001b[1mpackage.json\u001b[0m\n\u001b[32mCreate file\u001b[0m \u001b[1mtsconfig.json\u001b[0m\n\u001b[32mCreate file\u001b[0m \u001b[1mvitest.config.js\u001b[0m\n```\nThis will create a project directory with the following directory layout:\n\n<Files className='pointer-events-none'>\n  <Folder name=\"contracts\" />\n  <Folder name=\"settings\" defaultOpen>\n    <File name=\"Devnet.toml\" />\n    <File name=\"Mainnet.toml\" />\n    <File name=\"Testnet.toml\" />\n  </Folder>\n  <Folder name=\"tests\" />\n  <File name=\".gitignore\" />\n  <File name=\"Clarinet.toml\" />\n  <File name=\"package.json\" />\n  <File name=\"tsconfig.json\" />\n  <File name=\"vitest.config.js\" />\n</Files>\n\nThe _txt`Clarinet.toml`_ file contains configuration for the smart contracts in your project. When you create contracts in your project, Clarinet will automatically add them to this file.\n\nThe _txt`settings/Devnet.toml`_ file contains configuration for accounts in the Clarinet console, including the seed phrases and initial balances for a set of out-of-the-box wallets that you can use for testing in the devnet environment."
  },
  {
    "title": "Quickstart",
    "description": "Learn how to create a simple counter contract using Clarinet.",
    "slug": "/stacks/clarinet/quickstart",
    "content": "\nimport { Clarinet, Js } from '@/components/ui/icon';\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\nimport { Steps, Step } from 'fumadocs-ui/components/steps';\n\nIn this quickstart guide, you will write a simple counter contract with Clarity. Throughout this tutorial, you'll learn how to generate a new project, create a smart contract, and validate your smart contract code using the Clarinet CLI.\n\nCheck out the [create a new project](/stacks/clarinet/guides/create-a-new-project) and [validate a contract](/stacks/clarinet/guides/validate-a-contract) guides for a deeper look.\n\n---\n\n<Steps>\n  <Step>\n    ## Generate your counter project\n  \n    Start by creating a new Clarinet project. This command will create a new directory named _console`counter`_ and set up a basic Clarinet project inside it.\n\n    ```terminal\n    $ clarinet new counter\n    \u001b[32mCreate directory\u001b[0m \u001b[1mcounter\u001b[0m\n    \u001b[32mCreate directory\u001b[0m \u001b[1mcontracts\u001b[0m\n    \u001b[32mCreate directory\u001b[0m \u001b[1msettings\u001b[0m\n    \u001b[32mCreate directory\u001b[0m \u001b[1mtests\u001b[0m\n    \u001b[32mCreate file\u001b[0m \u001b[1mClarinet.toml\u001b[0m\n    \u001b[32mCreate file\u001b[0m \u001b[1msettings/Mainnet.toml\u001b[0m\n    \u001b[32mCreate file\u001b[0m \u001b[1msettings/Testnet.toml\u001b[0m\n    \u001b[32mCreate file\u001b[0m \u001b[1msettings/Devnet.toml\u001b[0m\n    \u001b[32mCreate directory\u001b[0m \u001b[1m.vscode\u001b[0m\n    \u001b[32mCreate file\u001b[0m \u001b[1m.vscode/settings.json\u001b[0m\n    \u001b[32mCreate file\u001b[0m \u001b[1m.vscode/tasks.json\u001b[0m\n    \u001b[32mCreate file\u001b[0m \u001b[1m.gitignore\u001b[0m\n    \u001b[32mCreate file\u001b[0m \u001b[1m.gitattributes\u001b[0m\n    \u001b[32mCreate file\u001b[0m \u001b[1mpackage.json\u001b[0m\n    \u001b[32mCreate file\u001b[0m \u001b[1mtsconfig.json\u001b[0m\n    \u001b[32mCreate file\u001b[0m \u001b[1mvitest.config.js\u001b[0m\n    ```\n\n    <Files className=\"pointer-events-none\">\n      <Folder name=\"contracts\" />\n      <Folder name=\"settings\" defaultOpen>\n        <File name=\"Devnet.toml\" />\n        <File name=\"Mainnet.toml\" />\n        <File name=\"Testnet.toml\" />\n      </Folder>\n      <Folder name=\"tests\" />\n      <File name=\".gitignore\" />\n      <File name=\"Clarinet.toml\" />\n      <File name=\"package.json\" />\n      <File name=\"tsconfig.json\" />\n      <File name=\"vitest.config.js\" />\n    </Files>\n  </Step>\n  <Step>\n    ## Create a counter contract\n  \n    Inside your project directory, run _console`clarinet contract new counter`_ to create your contract. This will generate and update the proper files for writing and testing your code.\n\n    ```terminal\n    $ cd counter\n    $ clarinet contract new counter\n    \u001b[32mCreated file\u001b[0m \u001b[1mcontracts/counter.clar\u001b[0m\n    \u001b[32mCreated file\u001b[0m \u001b[1mtests/counter.test.ts\u001b[0m\n    \u001b[33mUpdated Clarinet.toml\u001b[0m \u001b[1mwith contract counter\u001b[0m\n    ```\n\n    ```toml Clarinet.toml\n    [contracts.counter]\n    path = 'contracts/counter.clar'\n    clarity_version = 2\n    epoch = 2.5\n    ```\n  </Step>\n  <Step>\n    ## Variables and functions\n  \n    Inside your _txt`contracts/counter.clar`_ file:\n\n    1. Define a map called _clarity`Counters`_ to store the count associated with each user.\n    2. Define a public function called _clarity`count-up`_ that increments the count of the user who calls it.\n    3. Add a read-only function called _clarity`get-count`_ that returns the count of the user who calls it.\n\n    ```clarity counter.clar -c\n    (define-map Counters principal uint)\n\n    (define-public (count-up)\n      (ok (map-set Counters tx-sender (+ (get-count tx-sender) u1)))\n    )\n\n    (define-read-only (get-count (who principal))\n      (default-to u0 (map-get? Counters who))\n    )\n    ```\n  </Step>\n  <Step>\n    ## Validate your contract\n  \n    Now it's time to validate your contract. This command will check your contract for errors and typos.\n\n    ```terminal\n    $ clarinet check\n    \u001b[32m✔\u001b[0m \u001b[1m1 contract checked\u001b[0m\n    ```\n\n    Once your contract is validated, you can interact with it locally with the _console`clarinet console`_ inside your project directory.\n\n    ```terminal\n    $ clarinet console\n    ```\n\n    Here are some example interactions you can perform with your contract:\n\n    1. Call the _clarity`count-up`_ function on your contract to increment the count.\n    2. Verify the count of the user has been incremented by calling the _clarity`get-count`_ function with the _clarity`tx-sender`_ as the argument.\n    \n    ```terminal\n    $ (contract-call? .counter count-up)\n    \u001b[32m(ok true)\u001b[0m\n    $ (contract-call? .counter get-count tx-sender)\n    \u001b[32mu1\u001b[0m\n    ```\n  </Step>\n</Steps>\n\n## Next steps\n\n<Cards>\n  <SecondaryCard\n    icon={<Clarinet />}\n    href=\"/stacks/clarinet/guides/add-a-contract\"\n    title=\"Add a contract to your project\"\n    description=\"Learn how to add a contract to your project.\"\n    tag='Clarinet'\n  />\n  <SecondaryCard\n    icon={<Clarinet />}\n    href=\"/stacks/clarinet/guides/run-a-local-devnet\"\n    title=\"Run a local devnet\"\n    description=\"Learn how to set up and run a local development network for your project.\"\n    tag='Clarinet'\n  />\n  <SecondaryCard\n    icon={<Js />}\n    href=\"/stacks/clarinet-js-sdk/quickstart\"\n    title=\"Write tests for your smart contracts\"\n    description=\"Learn how to write unit tests using the Clarinet JS SDK.\"\n    tag='Clarinet JS SDK'\n  />\n</Cards>"
  },
  {
    "title": "Overview",
    "description": "Leverage programmatic API access in order to seamlessly interact with devnet and manage chainhooks.",
    "slug": "/stacks/platform-api/index",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nThe Platform API unlocks powerful automation opportunities in your application code, development and CI scripts, and more, via a familiar REST interface.\n\nIn particular, this API lets you programmatically create, update, query, and delete chainhooks as well as interact with a platform-hosted devnet from your local machine.\n\nWhen you create a Platform account, you'll automatically receive an API key that's required to use these endpoints. You can also create additional API keys in the [Hiro Platform](/stacks/api-keys) as needed.\n\n## Popular endpoints\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/platform-api/devnet/stacks-blockchain-api\"\n    title=\"Query devnet API endpoints\"\n    description=\"Query Stacks API endpoints for data related to your devnet.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/platform-api/devnet/start\"\n    title=\"Start a devnet service\"\n    description=\"Start a hosted devnet through the Platform API.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/platform-api/chainhooks/create\"\n    title=\"Create a chainhook\"\n    description=\"Create a chainhook through the Platform API.\"\n  />\n</Cards>\n\n\n## Related tools\n\n- **[Hiro Platform](/stacks/platform)**: A developer platform for building, deploying and scaling Bitcoin apps.\n- **[Chainhook](/stacks/chainhook)**: You don't need the platform to create event streams. Leverage chainhook independently, so your app can react to on-chain events in real time.\n- **[Stacks Blockchain API](/stacks/api)**: Fetch on-chain data from the Stacks blockchain.\n- **[Token Metadata API](/stacks/token-metadata-api)**: Fetch fungible and non-fungible token data on the Stacks blockchain.\n\n<br />\n\n<Callout title=\"Need help building with the Platform API?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#hiro-platform</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>\n\n\n\n"
  },
  {
    "title": "Bitcoin node",
    "description": "Proxy for the Bitcoin node on a development network (devnet).",
    "slug": "/stacks/platform-api/devnet/bitcoin-node",
    "content": "\n<APIPage\n  document=\"./openapi/platform-api.json\"\n  operations={[{ path: '/v1/ext/{apiKey}/bitcoin-node/{*}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Devnet",
    "description": "Retrieves information about the Platform Devnet services such as Stacks Blockchain API, Bitcoin node, and more.",
    "slug": "/stacks/platform-api/devnet/index",
    "content": ""
  },
  {
    "title": "Stop devnet",
    "description": "Stop a development network (devnet).",
    "slug": "/stacks/platform-api/devnet/stop",
    "content": "\n<APIPage\n  document=\"./openapi/platform-api.json\"\n  operations={[{ path: '/v1/ext/{apiKey}/devnet', method: 'delete' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Start devnet",
    "description": "Start a development network (devnet).",
    "slug": "/stacks/platform-api/devnet/start",
    "content": "\n<APIPage\n  document=\"./openapi/platform-api.json\"\n  operations={[{ path: '/v1/ext/{apiKey}/devnet/{projectName}', method: 'put' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Stacks Blockchain API",
    "description": "Proxy for the Stacks Blockchain API on a development network (devnet).",
    "slug": "/stacks/platform-api/devnet/stacks-blockchain-api",
    "content": "\n<APIPage\n  document=\"./openapi/platform-api.json\"\n  operations={[{ path: '/v1/ext/{apiKey}/stacks-blockchain-api/{*}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get all chainhooks",
    "description": "Get all of your chainhooks through the Hiro Platform.",
    "slug": "/stacks/platform-api/chainhooks/list",
    "content": "\n<APIPage\n  document=\"./openapi/platform-api.json\"\n  operations={[{ path: '/v1/ext/{apiKey}/chainhooks', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Create a chainhook",
    "description": "Create a chainhook through the Hiro Platform.",
    "slug": "/stacks/platform-api/chainhooks/create",
    "content": "\n<APIPage\n  document=\"./openapi/platform-api.json\"\n  operations={[{ path: '/v1/ext/{apiKey}/chainhooks', method: 'post' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get a specific chainhook",
    "description": "Get a specific chainhook through the Hiro Platform.",
    "slug": "/stacks/platform-api/chainhooks/get",
    "content": "\n<APIPage\n  document=\"./openapi/platform-api.json\"\n  operations={[{ path: '/v1/ext/{apiKey}/chainhooks/{chainhookUuid}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Chainhooks",
    "description": "Retrieves information about the Platform Chainhooks API.",
    "slug": "/stacks/platform-api/chainhooks/index",
    "content": ""
  },
  {
    "title": "Update a chainhook",
    "description": "Update a chainhook through the Hiro Platform.",
    "slug": "/stacks/platform-api/chainhooks/update",
    "content": "\n<APIPage\n  document=\"./openapi/platform-api.json\"\n  operations={[{ path: '/v1/ext/{apiKey}/chainhooks/{chainhookUuid}', method: 'put' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Delete a chainhook",
    "description": "Delete a chainhook through the Hiro Platform.",
    "slug": "/stacks/platform-api/chainhooks/delete",
    "content": "\n<APIPage\n  document=\"./openapi/platform-api.json\"\n  operations={[{ path: '/v1/ext/{apiKey}/chainhooks/{chainhookUuid}', method: 'delete' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get a chainhook status",
    "description": "Retrieve the status of a specific chainhook through the Hiro Platform.",
    "slug": "/stacks/platform-api/chainhooks/status",
    "content": "\n<APIPage\n  document=\"./openapi/platform-api.json\"\n  operations={[{ path: '/v1/ext/{apiKey}/chainhooks/{chainhookUuid}/status', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Home",
    "description": "",
    "slug": "/stacks/index",
    "content": "\nimport { Card as MainCard, SmallCard } from '@/components/card';\nimport { ImageZoom } from 'fumadocs-ui/components/image-zoom';\nimport { PageFooter } from '@/components/footer';\nimport { MessageCircle, Braces, ChevronRight, Code, Database, Play, Rocket, Star, Terminal, Wallet } from 'lucide-react';\nimport { API, Backend, BugIcon, Clarinet, Cloud, Chainhook, Frontend, Hiro, Js, Newspaper, Pulse, QuestionIcon } from '@/components/ui/icon';\nimport heroImage from '@/public/stacks-hero.svg';\n\n<div className='flex flex-col space-y-10 pt-0'>\n\n<div className='flex space-x-6 items-end'>\n  <ImageZoom\n    alt=\"banner\"\n    src={heroImage}\n    className=\"mt-0 mb-6 first-line:rounded-xl bg-background\"\n    priority\n  />\n\n  <div className='flex flex-col [&_h2]:mt-0 [&_h2]:mb-2 [&_p]:mb-6'>\n\n  ## Build with Stacks\n\n  Find all the guides and resources you need to build on Stacks.\n\n  </div>\n</div>\n\n<Cards>\n  <MainCard\n    className='group space-y-1'\n    icon={<Play className='transition-colors duration-500 ease-in-out group-hover:text-primary' />}\n    href=\"/stacks/get-started\"\n    title=\"Get Started\"\n    description=\"Get started with our end-to-end tutorials and quickstart guides across all Hiro tools.\"\n  />\n  <MainCard\n    className='group space-y-1'\n    icon={<API className='transition-colors duration-500 ease-in-out group-hover:text-primary' />}\n    href=\"/stacks/api\"\n    title=\"Stacks API Reference\"\n    description=\"Explore API endpoints for interacting with the Stacks Blockchain.\"\n  />\n</Cards>\n\n<div className='flex flex-col'>\n\n<h4 id=\"explore-by-category\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#explore-by-category\" className=\"not-prose group text-sm uppercase\">Explore by category</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<Cloud />}\n    href=\"/stacks/platform\"\n    title=\"Quickstart App Templates\"\n    description=\"Full-stack starter-kits, including front-end, back-end, and smart contract components.\"\n  />\n  <SmallCard\n    icon={<Code />}\n    href=\"/stacks/clarinet\"\n    title=\"Smart Contract Development\"\n    description=\"Kickstart your smart contract journey with Clarinet and the Clarinet JS SDK.\"\n  />\n  <SmallCard\n    icon={<Database />}\n    href=\"/stacks/chainhook\"\n    title=\"Data Streaming &amp; Events\"\n    description=\"Create custom event streams for real-time data with Chainhook.\"\n  />\n  <SmallCard\n    icon={<Frontend />}\n    href=\"/stacks/stacks.js\"\n    title=\"Frontend Web Development\"\n    description=\"Interact with smart contracts on the web with the Stacks.js library.\"\n  />\n  <SmallCard\n    icon={<Backend />}\n    href=\"/stacks/api\"\n    title=\"Backend Development\"\n    description=\"Explore our hosted APIs offering a familiar REST interface.\"\n  />\n  <SmallCard\n    icon={<Braces />}\n    href=\"/stacks/token-metadata-api\"\n    title=\"Token Management\"\n    description=\"Explore our hosted API for fetching token metadata on Stacks.\"\n  />\n</Cards>\n\n</div>\n\n\n<div className='flex flex-col'>\n\n<h4 id=\"explore-by-tool\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#explore-by-tool\" className=\"not-prose group text-sm uppercase\">Explore by tool</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<Hiro />}\n    href=\"/stacks/platform\"\n    title=\"Hiro Platform\"\n    description=\"A developer platform for building, deploying and scaling Bitcoin apps.\"\n  />\n  <SmallCard\n    icon={<Clarinet />}\n    href=\"/stacks/clarinet\"\n    title=\"Clarinet\"\n    description=\"Create, test, and deploy smart contracts on the Stacks blockchain.\"\n  />\n  <SmallCard\n    icon={<API />}\n    href=\"/stacks/api\"\n    title=\"Stacks Blockchain API\"\n    description=\"Interact with the Stacks blockchain from your backend via our hosted API.\"\n  />\n  <SmallCard\n    icon={<Js />}\n    href=\"/stacks/stacks.js\"\n    title=\"Stacks.js\"\n    description=\"A collection of JavaScript libraries to build web applications on Stacks.\"\n  />\n  <SmallCard\n    icon={<Chainhook />}\n    href=\"/stacks/chainhook\"\n    title=\"Chainhook\"\n    description=\"Create customizable, lightweight databases for on-chain events for Bitcoin and Stacks.\"\n  />\n</Cards>\n\n</div>\n\n</div>\n\n<PageFooter />"
  },
  {
    "title": "Overview",
    "description": "A developer platform for building, deploying, and scaling Bitcoin apps.",
    "slug": "/stacks/platform/index",
    "content": "\nimport Link from \"next/link\";\nimport { Button } from \"@/components/ui/button\"\n\nThe Hiro Platform is your all-in-one solution for building and scaling Bitcoin applications. It provides essential tools including API key management, customizable data streams, production-ready app templates, dedicated testing environments, and onchain monitoring and analytics - everything developers need to bring their Bitcoin apps to life.\n\n<Button className=\"bg-orange-500 hover:bg-orange-600\">\n  <Link\n    target=\"_blank\"\n    href=\"https://platform.hiro.so/\"\n    className=\"no-underline\"\n  >\n    Get started on the platform\n  </Link>\n</Button>\n\n![Projects](./images/o1.png)\n\n## Guides\n\n<Cards>\n\n<Card\n  href=\"/stacks/platform/guides/create-chainhooks\"\n  title=\"Create event streams with Chainhook\"\n  description=\"Create and manage webhook-like triggers that react to on-chain events in real time.\"\n/>\n\n{\" \"}\n\n<Card\n  href=\"/stacks/platform/guides/deploy-contracts\"\n  title=\"Deploy your contracts\"\n  description=\"Deploy your project with customizable deployment plans that can handle contract dependencies.\"\n/>\n\n<Card \n  href=\"/stacks/platform/guides/devnet\"\n  title=\"Iterate quickly with devnet\"\n  description=\"Leverage devnet, a private instance of the blockchain, for rapid feedback loops and a better debugging experience.\"\n/>\n\n<Card \n    href=\"/stacks/platform/guides/contract-monitoring\"\n    title=\"Monitor your contract activity\"\n    description=\"Set up monitoring for your smart contracts with customizable alerts to track on-chain activity after deployment.\"\n  />\n</Cards>\n\n## Related tools\n\n- **[Clarinet](/stacks/clarinet)**: Build and deploy smart contracts locally on your device with Clarinet.\n- **[Chainhook](/stacks/chainhook)**: You don’t need the platform to create event streams. Leverage chainhook independently, so your app can react to on-chain events in real time.\n- **[Stacks.js](/stacks/stacks.js)**: Don’t reinvent the wheel. Build faster with a JS library that handles basic functions.\n\n<br />\n\n<Callout title=\"Need help building with the Hiro Platform?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#hiro-platform</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>\n"
  },
  {
    "title": "Deploy contracts",
    "description": "Learn how to deploy contracts in the Hiro Platform.",
    "slug": "/stacks/platform/examples/deploy-contracts",
    "content": "\n## Prerequisites\n\n- Follow the [create project](/stacks/platform/guides/create-project) guide to create or import a project.\n- Make sure you have installed and connected a Stacks wallet to deploy your contracts.\n\n## Use the deploy button\n\nOnce your project is setup, you can deploy the contracts to testnet or mainnet using the \"Deploy\" button on the Hiro Platform.\n\n![deploy contracts](../images/deploy-contracts/d1.png)\n\nThe following are the steps to deploy your contracts using the deploy button.\n\n1. On the projects page, select the project you want to deploy contracts from.\n2. Use the \"Deploy Contracts\" button available at the top right of the page.\n3. Choose the network you want to deploy to. Note: for devnet, [reference this guide](/stacks/platform/guides/devnet). The steps below are specific to testnet and mainnet.\n4. Once you choose a network, you will see a button to generate a deployment plan.\n5. Once the deployment plan is generated, you will see the list of contracts to be deployed - you can now connect your wallet and click \"Deploy\" to deploy your contracts.\n\n![deploy contracts](../images/deploy-contracts/d2.png)\n\nIf you find issues with your deployment process, you can reach out to us on the [#hiro-platform channel](https://stacks.chat) on Discord under the Hiro Developer Tools section or file an issue [here](https://hiro-pbc.canny.io/hiro-platform).\n"
  },
  {
    "title": "Create a project",
    "description": "Learn how to create or import a project in the Hiro Platform.",
    "slug": "/stacks/platform/examples/create-project",
    "content": "\nimport { Code, Terminal } from \"lucide-react\"\nimport { SmallCard } from \"@/components/card\"\n\nimport { Callout } from \"@/components/callout\"\nimport { Card, Cards } from \"@/components/card\"\n\nThe Hiro Platform offers multiple ways to create projects, whether you're starting from scratch with a template or importing an existing repository. This guide will walk you through both approaches.\n\n## Using templates\n\nFrom the main projects page, click the \"Add a project\" button to begin creating a new project.\n\n![template selection](../images/create-project/c2.png)\n\nThe Platform provides 2 types of pre-built templates to help you get started quickly:\n\n1. App templates\n2. Contract-only templates\n\n**App templates** are feature rich templates pre-configured with a frontend and smart contracts.\n\n**Contract-only templates** are pre-configured with just that: a smart contract to help you start building.\n\nSimply select the template you want to get started with to open up a more detailed view of the app.\n\n![template selection](../images/create-project/c1.png)\n\nOnce you are ready, click the \"Clone\" button to copy the template to your GitHub account. From there, you will see instructions on how to clone the repository locally to start development.\n\n## Importing existing projects\n\nIf you have an existing project on GitHub, you can import it directly into the Hiro Platform:\n\n1. If you haven't already, authorize your GitHub account with the Hiro Platform\n2. You'll see a list of your repositories that can be imported\n3. Select the repository you want by clicking the \"Import\" button\n\n![import from github](../images/create-project/c3.png)\n\n<Callout type=\"info\">\nThe Platform requires specific Clarinet-generated files and a directory structure to import projects successfully. Your project should include:\n\n- `.clar` files containing your smart contracts\n- A `Clarinet.toml` configuration file\n- A specific directory structure with contracts in a `contracts` folder\n</Callout>\n\nOnce your project is ready, you will see instructions on next steps to get started.\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/platform/guides/deploy-contracts\"\n    title=\"Deploy contracts\"\n    description=\"Learn how to deploy your contracts to testnet and mainnet in the Hiro Platform.\"\n  />\n  <Card\n    href=\"/stacks/platform/guides/devnet\"\n    title=\"Running Devnet\"\n    description=\"Learn how to use devnet to test your smart contracts in a local environment.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Archive a project",
    "description": "Discover how to archive your projects in the Hiro Platform.",
    "slug": "/stacks/platform/examples/archive-project",
    "content": "\n## Archive a project\n\nSometimes, you may find it necessary to archive a project from your project list. It is important to understand that archiving a project is not the same as deleting a project. Archiving a project means you wish to move the project status from an active project to one that is not active and visible in your project list.\n\nFollow the steps below to archive a project:\n\n1. Sign in to the [Hiro Platform](https://platform.hiro.so/).\n2. Once you are authenticated, you will be redirected to the project page.\n3. From your list of projects, find the project you wish to archive.\n4. Click on the far-right three dots and select \"Archive.\" This will remove the project from the project list and place it into an archive folder.\n\n![Archive project](../images/archive-project/archive.png)\n\n## Unarchive a project\n\nFollow the steps below to unarchive a project:\n\n1. From the projects page in the Hiro Platform, select the \"Archive\" button at the top right. and select the far-right three dots and select \"Unarchive.\"\n2. You will now see a list of archived projects. Select three-dots on the far right and click \"Unarchive\" for any project you want to unarchive.\n3. You will now see any unarchived projects back in your project list.\n\n![Unarchive project](../images/archive-project/unarchive.png)\n\n<Callout title=\"Note\" type=\"info\">\n  Deleting a project is not yet available in the BETA version.\n</Callout>\n"
  },
  {
    "title": "Request testnet STX",
    "description": "Easily request testnet STX, so you can deploy and interact with Stacks testnet.",
    "slug": "/stacks/platform/examples/faucet",
    "content": "\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nThe Stacks Testnet Faucet is a dedicated utility for developers building on the Stacks blockchain. To aid you in deploying and running smart contracts on Stacks testnet, we've provided this faucet that offers easy access to testnet STX tokens.\n\n![Create Chainhook Window](../images/faucet/request.png)\n\n## Why use the Stacks Testnet Faucet?\n\nBuilding and testing on a blockchain requires a certain amount of native tokens to facilitate various operations, from contract deployments to transaction executions. However, sourcing these tokens can often be cumbersome. The Stacks Testnet Faucet simplifies this by offering a hassle-free way to acquire STX tokens for testing purposes.\n\n## How to request testnet STX\n\n1. **Visit the faucet page**: Navigate to [platform.hiro.so/faucet](https://platform.hiro.so/faucet).\n2. **Select the token**: Select which token you want, either STX or sBTC.\n3. **Request tokens**: You'll find a straightforward interface with a button to request tokens. Simply click on the button \"Receive x STX/sBTC.\"\n4. **Receive 500 STX tokens or 1 sBTC**: By clicking the button, you'll receive 500 STX tokens or 1 sBTC to your testnet account.\n\n## Frequently Asked Questions\n\n\n<Accordions>\n<Accordion title=\"What is a faucet?\">\nA faucet is an application that dispenses free tokens on a Testnet (a blockchain network used for development and testing). The Stacks faucet provides developers with free test tokens for deploying, testing, and optimizing smart contracts that leverage STX and sBTC.\n\n**It's important to remember that Testnet tokens have no real-world value and cannot be sold or used on the main Stacks network.**\n</Accordion>\n<Accordion title=\"How does the faucet work?\">\nSelect the type of test token you wish to receive and enter the wallet address where you want to receive them. The faucet will create a transaction on the Stacks Testnet that sends a small amount of test tokens to the provided address.\n\nIf you're curious, you can track the transaction's status using [Stacks Explorer](https://explorer.stacks.so/).\n</Accordion>\n<Accordion title=\"Is it secure?\">\nWe securely handle the wallet address you provide while processing your request. This data is not used or shared with any other Hiro services.\n</Accordion>\n<Accordion title=\"Is there a limit for the number of tokens I can request?\">\nYou can make up to 5 requests every 5 minutes. For more details, see our [rate limiting policies](/stacks/rate-limiting).\n</Accordion>\n<Accordion title=\"How long does it take for the Testnet tokens to arrive in my account?\">\nThe time for tokens to arrive to your wallet depends on how busy the network is. On average, it should take x amount of time. If the transaction seems stuck, feel free to reach out to us on our [support channel](https://stacks.chat/).\n</Accordion>\n</Accordions>\n\n<Callout type=\"info\">\n  **Daily Limit**: To ensure fair distribution and availability for all\n  developers, there's a limit of one request per day. Plan your testing\n  accordingly!\n</Callout>{\" \"}\n"
  },
  {
    "title": "Using devnet",
    "description": "Test and validate your code using devnet's private blockchain environment.",
    "slug": "/stacks/platform/examples/devnet",
    "content": "\nDevnet is a personal blockchain environment that lets you test and validate your contract code before deploying on a public network like testnet or mainnet. In this guide, you'll learn how to interact with devnet in the Hiro Platform to expedite your development.\n\n## What is devnet?\n\nDevnet is a private blockchain environment that lets you test and validate smart contracts quickly. Think of it as your personal sandbox: no one else can see your devnet instance, you don't have to worry about breaking it, and you can stop and restart it as many times as you need.\n\nWhile developers can run devnet locally using Clarinet, the Hiro Platform provides a hosted version that eliminates the need to manage blockchain nodes and miners on your machine. The Platform-hosted devnet still produces blocks and processes transactions, but offloads the computational overhead to our infrastructure while providing a more intuitive interface for development.\n\nDevnet provides a risk-free testing ground with the convenience of rapid prototyping, cost savings, and privacy.\n\n## Benefits of devnet on the Hiro Platform\n\nThe Platform-hosted devnet offers several advantages:\n\n- **Zero local setup**: No need to configure or maintain blockchain nodes locally\n- **Resource-efficient**: Offloads computational demands to our infrastructure\n- **Rapid prototyping**: Quick iterations with immediate feedback\n- **Cost-efficiency**: No real cryptocurrency expenses for testing\n- **Seamless local integration**: Connect your local development environment to the hosted devnet\n- **Isolated development**: A personal sandbox for confidential and secure testing\n\n## Using devnet in the Hiro Platform\n\nFirst, log into the [Hiro Platform](https://platform.hiro.so/). After [setting up your project](/stacks/platform/guides/create-project), navigate to the project page where you can select the \"Devnet\" tab to manage your devnet instance.\n\n## Starting and managing devnet\n\nIn your project page, you'll click on the \"Devnet\" tab to start and manage your devnet instance. Initially, it should read \"Inactive.\" Click on the \"Start Devnet\" button to start your private devnet instance.\n\n![Dashboard](../images/devnet/dev1.png)\n\n<Callout title=\"Programmatic API\">\n  You can also start and stop devnet programmatically via the [Platform API](/stacks/platform-api/devnet).\n</Callout>\n\nIf you want to configure your devnet (like you can locally using `clarinet devnet start` in the terminal), open your project's `devnet.toml` file in the platform VS Code editor before you start devnet. From there, you can configure the settings to match your development needs.\n\nOnce you start devnet, it will take a few moments to spin up. The status indicator on the project dashboard will keep you updated on the progress.\n\n## Active session management\n\nWhen devnet is ready, the status will change to 'Active'.\n\nIf needed, you can restart devnet to refresh the timer. Keep in mind that only one devnet instance can run at a time per user account. If you need to work on a different project, simply start devnet within that project to seamlessly transition your session. There is also a monthly limit of 100 devnet sessions per account, so plan your development schedule accordingly.\n\n## Exploring the devnet dashboard\n\nThe Platform's devnet dashboard provides a comprehensive interface for monitoring and interacting with your private blockchain. You can:\n\n- Track real-time block production through the visual \"assembly line\"\n- Inspect block contents and transaction details\n- Search through blocks efficiently\n- Monitor contract deployments and function calls\n- Mint new blocks on demand\n\n![Devnet Dashboard](../images/devnet/dev2.png)\n\n## Additional devnet features\n\nOn the dashboard, you can also click the \"Interact with devnet\" button to call contract functions, make API requests, view devnet wallets, and more.\n\nFor more information on devnet features, [start here](https://www.hiro.so/blog/5-ways-to-interact-with-devnet-in-the-hiro-platform).\n"
  },
  {
    "title": "Monitor contracts",
    "description": "Learn how to monitor your contract with custom alerts after you deploy to mainnet.",
    "slug": "/stacks/platform/examples/contract-monitoring",
    "content": "\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\nThis feature goes beyond just security—it's also a way to better understand how your contracts are being used. You can also set up alerts for various public functions in your smart contract to gain insight on which functions are receiving the most calls and how users are interacting with your contract.\n\n## Set up contract monitoring\n\n<Callout title=\"Note\">\n  Make sure to have successfully deployed your contracts to the Stacks mainnet if you plan on setting up alert monitoring for your own contracts.\n</Callout>\n\nIf you have successfully deployed your contracts or want to set up alert monitoring for other contracts on mainnet, toggle to the Monitor tab after logging into the [Hiro Platform](https://platform.hiro.so).\n\n![Start monitoring](../images/contract-monitoring/start-monitoring.png)\n\n## Add contract for monitoring\n\nAfter clicking on the 'Add contract' button, a slideout modal will appear with fields for you to look up any smart contract on mainnet using the contract's principal and contract name. All contracts deployed to mainnet are public, and you can monitor and set up alerts for any of them, regardless of whether you are the deployer.\n\nAlternatively, you can also connect your wallet to view your deployment history and choose any contracts you’ve previously deployed in order to set up alerts for them.\n\n![Add contract](../images/contract-monitoring/add-contract.png)\n\nYour contract will then appear under Contract Monitoring. Once you are monitoring a particular contract, you can view its transaction history and any pending transactions in the mempool. Click on \"Create an alert\" to create a specific alert you want to monitor for. \n\n![Added contract](../images/contract-monitoring/added-contract.png)\n\n## Add custom alert\n\nYou can configure alerts for any contract calls on mainnet, whether that’s a `set-contract-owner` function, a transfer/mint/burn function, or anything else you’ve implemented that you want to monitor.\n\nOnce you identify the function calls you want to monitor, you can further hone in on the specific calls by creating filters for argument values and the address of the wallet which called the function. \n\nThe specific conditions you can choose to monitor for include:\n\n- When a particular function is called\n- When a particular function is called with a specified argument\n- When a particular function is called by a specified address\n\nYou can monitor these alerts in the Hiro Platform, and you can also choose to receive email alerts every time one of those alerts is triggered. Alternatively, you can configure webhook calls, which can be used for all kinds of customized alerting flows.\n\n![Create alert form](../images/contract-monitoring/create-alert-form.png)\n\n## Monitor your alerts\n\nWith each alert you set up, you can view the alert’s history and the response status from any webhook calls made. You also have the ability to edit existing alerts to change your alert conditions or notification preferences at any time.\n\n![View alerts page](../images/contract-monitoring/view-alerts-page.png)\n\n## What to expect from alerts\n\nIf you've specified an email as the notification type, alert notification emails will come from Hiro Platform `<platform@hiro.so>`.\n\nIf you've specified a webhook to send an alert to an API endpoint, then the alert payload will look like `sample-alert-payload.json` below.\n\n<Callout type=\"info\">\n  Note that `tx_status` will always return a \"pending\" status for monitor alert notifications. This is because contract monitoring alerts will only send notifications when your custom notification alert on a particular function hits the mempool, but not when it gets confirmed in the blockchain.\n</Callout>\n\n<Tabs items={['Sample Alert Payload', 'Alert Payload Interface']}>\n  <Tab value=\"Sample Alert Payload\">\n    ```json sample-alert-payload.json\n    {\n      \"tx_id\": \"0xa7f511b3f379efef6fe71d0de57712ed13a89c5b6e24dd049eb2cc9a7c24fcb5\",\n      \"nonce\": 5,\n      \"fee_rate\": \"250\",\n      \"sender_address\": \"SP2W9QYAHJNS7YTQY9EK2MSTQGX9E2NDMV766JP9Z\",\n      \"sponsored\": false,\n      \"post_condition_mode\": \"deny\",\n      \"post_conditions\": [\n        {\n          \"type\": \"stx\",\n          \"condition_code\": \"sent_equal_to\",\n          \"amount\": \"3000000\",\n          \"principal\": {\n            \"type_id\": \"principal_standard\",\n            \"address\": \"SP2W9QYAHJNS7YTQY9EK2MSTQGX9E2NDMV766JP9Z\"\n          }\n        }\n      ],\n      \"anchor_mode\": \"any\",\n      \"tx_status\": \"pending\",\n      \"receipt_time\": 1726104636,\n      \"receipt_time_iso\": \"2024-09-12T01:30:36.000Z\",\n      \"tx_type\": \"contract_call\",\n      \"contract_call\": {\n        \"contract_id\": \"SPHW0EJK5KPDMK03ZX792EMP0Q5J3A39ZMTVZZCY.sample-contract\",\n        \"function_name\": \"donate\",\n        \"function_signature\": \"(define-public (donate (amount uint)))\",\n        \"function_args\": [\n          {\n            \"hex\": \"0x01000000000000000000000000002dc6c0\",\n            \"repr\": \"u3000000\",\n            \"name\": \"amount\",\n            \"type\": \"uint\"\n          }\n        ]\n      }\n    }\n    ```\n  </Tab>\n  <Tab value=\"Alert Payload Interface\">\n  ```ts title=\"sample-alert-interface.ts\"\n  interface Body {\n  tx_id: string;\n  nonce: number;\n  fee_rate: string;\n  sender_address: string;\n  sponsored: boolean;\n  post_condition_mode: string;\n  post_conditions: Postcondition[];\n  anchor_mode: string;\n  tx_status: string;\n  receipt_time: number;\n  receipt_time_iso: string;\n  tx_type: string;\n  contract_call: Contractcall;\n  }\n  interface Contractcall {\n    contract_id: string;\n    function_name: string;\n    function_signature: string;\n    function_args: Functionarg[];\n  }\n  interface Functionarg {\n    hex: string;\n    repr: string;\n    name: string;\n    type: string;\n  }\n  interface Postcondition {\n    type: string;\n    condition_code: string;\n    amount: string;\n    principal: Principal;\n  }\n  interface Principal {\n    type_id: string;\n    address: string;\n  }\n  ```\n  </Tab>\n</Tabs>"
  },
  {
    "title": "Create a chainhook",
    "description": "Create a chainhook using the Hiro Platform.",
    "slug": "/stacks/platform/examples/create-chainhooks",
    "content": "\nWith Chainhook, you can automatically trigger an action in response to on-chain events on Stacks and Bitcoin, enabling you to use IFTTT (if_this, then_that) logic to power your applications. To learn more about Chainhook, refer to the [Chainhook overview](/stacks/chainhook).\n\n<Callout title=\"Programmatic API\">\n  You can also create and manage chainhooks via the [Platform API](/stacks/platform-api/chainhooks).\n</Callout>\n\nTo get started in the Hiro Platform, login and toggle to the Chainhook page. There are two ways to create a chainhook. You can either create a chainhook from scratch using the platform UI, or you can upload chainhooks that you have already defined in JSON.\n\n![Create Chainhook Window](../images/chainhook/select-chainhook-tab.png)\n\nSelect the \"New Chainhook\" button.\n\n![Create Chainhook Window](../images/chainhook/create-chainhook-window.png)\n\nThis will open a panel on the right to create a chainhook. Use the following fields to create a Chainhook:\n\n**Name**: Input the name of your chainhook.\n\n**Chain**: Select which chain you want to build a chainhook for (Bitcoin or Stacks).\n\n**Network**: Choose which network the chainhook will observe.\n\n**If-this**: Based on the selected chain, you will see a list of available scopes for the `If-this` condition (also called a \"predicate\").\n\n<Callout title=\"Available Predicate Scopes\">\n  -For Bitcoin, the available predicate options are `txid`,`outputs`, and\n  `stacks_protocols`.\n  \n  -For Stacks, the available predicate options are\n  `txid`, `block_height`, `fungible_token_event`, `non-fungible_token_event`,\n  `stx_event`, `print_event`, and `contract_deployment`.\n\n_Refer to the [Bitcoin predicates](/stacks/chainhook/concepts/bitcoin-predicates) and [Stacks predicates](/stacks/chainhook/concepts/stacks-predicates) documents to understand the available predicates and how to use them._\n\n</Callout>\n\n**Then-that**: This action is defaulted to `http_post` to allow the chainhook to post events to the URL specified in the next field below.\n\n**URL**: Specify a URL to post chainhook events to the HTTP_post method.\n\n**Authorization Header**: This field is optional to add a Secret to the `authorization` header when posting payloads.\n\n**Start Block**: This field must specify the start block to search the chain.\n\n**End Block**: It is optional to specify the end block. However, to optimize your scan time, we recommended you specify this field.\n\n**Expire After Occurrence**: You can specify the chainhook to expire after a specific number of occurrences (a number greater than or equal to 1). You can leave this blank if you don't want to set any limit.\n\n**Decode Clarity Values**: This is enabled by default for Stacks predicates to help you decode Clarity values in your contract.\n\nYou'll also see the following options for Bitcoin chainhooks:\n\n**Include Proof**: Enable this option when you have evidence that the transaction or block has been verified and authorized by the sender using their private key. This proof is generally a cryptographic signature to a transaction or block on the Bitcoin blockchain.\n\n**Include Inputs**: Enable this option to include Bitcoin transaction inputs in the payload. In a Bitcoin transaction, inputs are references to previous transactions' outputs (also known as unspent transaction outputs or UTXOs) that are being spent in the current transaction. These inputs provide evidence that the sender has the right to spend the funds.\n\n**Include Outputs**: Enable this option to include Bitcoin transaction outputs in the payload. Including outputs in a Bitcoin transaction refers to specifying the destinations and amounts of Bitcoin being sent as part of a transaction. Outputs in a Bitcoin transaction represent the recipients' addresses and the corresponding amounts of Bitcoin they are receiving.\n\n**Include Witness**: Enable this option to include Bitcoin transaction witness in the payload. The witness data for a transaction includes the cryptographic signatures and other related information placed alongside the transaction data in the block.\n\nOnce you define all the required fields, you can select \"Create Chainhook\", and you can now see your created chainhook on the Chainhook page.\n\n![Chainhook created](../images/chainhook/created.png)\n\nThe `NAME`, `CHAIN`, `START BLOCK`, `NETWORK`, `STATUS`, and `LAST UPDATED` headers are updated based on the selected fields used to create a Chainhook.\n\nBased on the chosen network, the respective status columns in the Chainhook list page will be updated to \"Deployed.\"\n\nNote: there may be other fields in the UI to create a Chainhook based on the predicates defined above.\n\n## Upload a chainhook\n\nTo upload a chainhook, you can either select the \"Upload Chainhook\" button and choose the .json file that has the chainhook(s) you want to upload, or you can drag and drop the .json file into the file upload area.\n\n![Upload Chainhook](../images/chainhook/upload.png)\n\nThe upload file must be a .json file containing either a single json object representing a Chainhook predicate, or an array of json objects representing one or more Chainhook predicates.\n\nRefer to the [Bitcoin predicates](/stacks/chainhook/concepts/bitcoin-predicates) and [Stacks predicates](/stacks/chainhook/concepts/stacks-predicates) documents to understand the available predicates and how to prepare your Chainhook predicate JSON for upload.\n\n## Edit a chainhook\n\nOnce a chainhook is created, you can edit the chainhook by clicking the ellipse on the specific chainhook you want to edit.\n\n![Edit chainhook](../images/chainhook/edit-chainhook.png)\n\nUpdate the fields to reflect your desired changes and then select \"Update chainhook.\"\n\n## Duplicate a chainhook\n\nSelect the ellipse on the chainhook you want to duplicate and select \"Duplicate.\" This opens a right pane with all the fields populated to use to create a duplicate Chainhook.\n\nYou can update any fields or publish a direct copy by clicking \"Create Chainhook.\"\n\n## Delete a chainhook\n\nSelect the ellipse on the chainhook you wish to delete and select \"Delete.\" You will see a confirmation window to confirm if you want to delete the Chainhook.\n\n## Chainhook status\n\nThe Chainhook page has a `STATUS` column that displays whether your chainhooks are in an active, inactive, or error state. Active means the Chainhook is actively scanning blocks against its defined predicate, inactive means the Chainhook has reached a terminal state (e.g. its end block has been reached, and it is no longer scanning blocks), and error means the Chainhook ran into an error during its execution.\n\nMore status info can be found by hovering over the status element. For example, to understand why the Chainhook is in an error state, hover over the status element to find out.\n\n![Chainhook status](../images/chainhook/status-info.png)\n\n## References\n\n- [Use Chainhooks with Bitcoin](/stacks/chainhook/concepts/bitcoin-predicates)\n- [Use Chainhooks with Stacks](/stacks/chainhook/concepts/stacks-predicates)\n- [Run Chainhook as a service using Bitcoind](/stacks/chainhook/guides/chainhook-as-a-service)\n- [Run Chainhook as a service using Stacks](/stacks/chainhook/guides/chainhook-as-a-service-with-stacks-node)\n"
  },
  {
    "title": "Quickstart",
    "description": "Create and deploy your first app in the Hiro Platform.",
    "slug": "/stacks/platform/quickstart",
    "content": "\nimport { Code, Terminal } from \"lucide-react\"\nimport { SmallCard } from \"@/components/card\"\n\nIn this quickstart guide, you will create a simple fundraising app using one of the app templates available. This app features a single page that displays a fundraising campaign, and functionality that handles campaign contributions, refunds, and withdrawal by the fundraiser.\n\n## Create your account\n\nStart by creating an account in the Hiro Platform. You can create an account with:\n\n- Email\n- Google\n- GitHub\n- Discord\n\n![Platform Login](./images/quickstart/q1.png)\n\nOnce signed in, you will see an onboarding screen showing all the Hiro Platform has to offer:\n\n![Platform Welcome Screen](./images/quickstart/q2.png)\n\n## Create your project\n\nIf you do not have any existing projects, you will be prompted to create one on the projects page. Click the \"Add a project\" button to get started.\n\n<Callout type=\"info\">\nIf you already have projects, you can find the \"Add a project\" button at the top right of the page.\n</Callout>\n\nFrom here, you have the option to choose from a set of templates or import an existing project from your GitHub account. For this quickstart, select the \"Fundraising App\" template, which is a starter project that comes equipped with both a frontend and smart contracts.\n\n![choose template](./images/quickstart/q5.png)\n\n<Callout type=\"info\">\nTo see a list of your repositories and import an existing project, you will first need to authorize with GitHub.\n</Callout>\n\n## Clone your project\n\nOnce you have selected your project, you will be presented with the full set of details for the project. From here, you can clone the project to your GitHub account by clicking the \"Clone\" button.\n\n![template details](./images/quickstart/q3.png)\n\n<Callout type=\"info\">\nYou will need to authorize with Github before being able to clone the project.\n</Callout>\n\nOnce the project is ready and available in your GitHub account, you will see instructions on how to clone the project to your local machine or develop in the browser via Github Codespaces.\n\n![template ready](./images/quickstart/q4.png)\n\nYou are now ready to start building!\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/platform/guides/deploy-contracts\"\n    title=\"Deploy contracts\"\n    description=\"Learn how to deploy your contracts to testnet and mainnet using deployment plans in the Hiro Platform.\"\n  />\n  <Card\n    href=\"/stacks/platform/guides/devnet\"\n    title=\"Running Devnet\"\n    description=\"Learn how to use devnet, a private blockchain environment, to test and interact with your app.\"\n  />\n  <Card\n    href=\"/stacks/platform/guides/create-chainhooks\"\n    title=\"Create and manage Chainhooks\"\n    description=\"Learn how to create custom event streams for Stacks or Bitcoin with Chainhook on the Platform.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Overview",
    "description": "Fetch data for any fungible, non-fungible, and semi-fungible token on Stacks.",
    "slug": "/stacks/token-metadata-api/index",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nThe Token Metadata API is a service that offers a REST API, so you can easily pull any data you need for any token on Stacks that follows SIP standards. Every token, one request away.\n\n## Popular endpoints\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/token-metadata-api/tokens/fungible-token-metadata\"\n    title=\"Get data for fungible tokens\"\n    description=\"Retrieve data related to fungible tokens.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/token-metadata-api/tokens/non-fungible-token-metadata\"\n    title=\"Get data for non-fungible tokens\"\n    description=\"Retrieve data related to non-fungible tokens.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/token-metadata-api/tokens/semi-fungible-token-metadata\"\n    title=\"Get data for semi-fungible tokens\"\n    description=\"Retrieve data related to semi-fungible tokens.\"\n  />\n</Cards>\n\n\n## Related tools\n\n- **[Hiro Archive](/stacks/archive)**: Bootstrap your own instance of the Token Metadata API with the Hiro Archive and save days of setup time.\n- **[Stacks Blockchain API](/stacks/api)**: Fetch on-chain data from the Stacks blockchain.\n- **[Stacks Explorer](https://explorer.hiro.so)**: Looking for a simpler way to verify token data on the Stacks blockchain? Try the Stacks Explorer.\n- **[Ordinals API](/bitcoin/ordinals/api)**: Get data for Bitcoin ordinals and BRC-20 tokens.\n\n<br />\n\n<Callout title=\"Need help building with the Token Metadata API?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#api</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>\n\n\n\n"
  },
  {
    "title": "Architecture",
    "description": "Understand the architecture of the Token Metadata API.",
    "slug": "/stacks/token-metadata-api/architecture",
    "content": "\n## Service architecture\n\nThis section gives you an overview of external and internal architectural diagrams.\n\n## External architecture\n\nThe external architectural diagram shows how the Token metadata API is connected to three systems: a Stacks node, a Stacks Blockchain API database, and a Postgres database.\n\n![Architecture](../../../../public/images/token-metadata-api/architecture.svg)\n\n1. The Token Metadata API interacts with the Stacks Blockchain API database (referred to as a \"Local Metadata DB\" in the diagram above) to import all historical smart contracts when booting up and to listen for new contracts that may be deployed afterwards. Read-only access is recommended as this service will never need to write anything to this database.\n2. A Stacks node responds to all read-only contract calls required when fetching token metadata (calls to get token count, token metadata URIs, etc.).\n3. A local Postgres DB stores all processed metadata info.\n\nThe service needs to fetch external metadata files (JSONs, images) from the internet, so it must have access to external networks.\n\n## Internal architecture\n\nThe following is the internal architectural diagram of the Token Metadata API.\n\n![Flowchart](../../../../public/images/token-metadata-api/flowchart.svg)\n"
  },
  {
    "title": "Info",
    "description": "Retrieves information about the Token Metadata API, including the server version.",
    "slug": "/stacks/token-metadata-api/info/index",
    "content": ""
  },
  {
    "title": "Get status",
    "description": "Retrieves information about the Token Metadata API, including the server version.",
    "slug": "/stacks/token-metadata-api/info/status",
    "content": "\n<APIPage\n  document=\"./openapi/token-metadata-api.json\"\n  operations={[{ path: '/metadata/v1/', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Usage",
    "description": "Go over the multiple ways to make requests to the Token Metadata API.",
    "slug": "/stacks/token-metadata-api/usage",
    "content": "\n## Making requests\n\nTo make a request to the Stacks API, you can paste the `curl` command below in your terminal.\n\n```terminal\n$ curl -L 'https://api.hiro.so/metadata/v1/' -H 'Accept: application/json'\n```\n\nIf you are using an `api-key`, you will need to replace `$HIRO_API_KEY` with your secret API key.\n\n```terminal\n$ curl -L 'https://api.hiro.so/metadata/v1/' \\\n  -H 'Accept: application/json' \\\n  -H 'X-API-Key: $HIRO_API_KEY'\n```\n\nYou should get a response back that resembles the following:\n\n```json\n{\n  \"server_version\": \"token-metadata-api v0.7.0 (master:1aa1603)\",\n  \"status\": \"ready\",\n  \"tokens\": {\n    \"ft\": 1309,\n    \"nft\": 545094,\n    \"sft\": 121\n  },\n  \"token_contracts\": {\n    \"sip-009\": 4791,\n    \"sip-010\": 1309,\n    \"sip-013\": 21\n  },\n  \"job_queue\": {\n    \"done\": 443257,\n    \"failed\": 108606\n  }\n}\n```\n\n## Making requests using API Client\n\nWe also maintain a standalone API client that you can use to make requests to the Stacks API. This client is available as a package and can be installed with the following command:\n\n```package-install title=\"Terminal\"\n@hirosystems/token-metadata-api-client\n```\n\nExample usage:\n\n```ts\nimport { Configuration, TokensApi } from \"@hirosystems/token-metadata-api-client\";\n\nconst config: Configuration = {}\nconst api = new TokensApi(config);\nconst result = await api.getFtMetadata(\n  'SP1H1733V5MZ3SZ9XRW9FKYGEZT0JDGEB8Y634C7R.miamicoin-token-v2'\n);\n```\n\n{/* For more information on the API client, you can check out the [API Client documentation](/stacks/token-metadata-api/client). */}"
  },
  {
    "title": "Tokens",
    "description": "Retrieves information about tokens on the Stacks blockchain.",
    "slug": "/stacks/token-metadata-api/tokens/index",
    "content": "\n"
  },
  {
    "title": "Get fungible token metadata",
    "description": "Retrieves metadata for a SIP-010 fungible token.",
    "slug": "/stacks/token-metadata-api/tokens/fungible-token-metadata",
    "content": "\n<APIPage\n  document=\"./openapi/token-metadata-api.json\"\n  operations={[{ path: '/metadata/v1/ft/{principal}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get semi-fungible token metadata",
    "description": "Retrieves information about semi-fungible tokens.",
    "slug": "/stacks/token-metadata-api/tokens/semi-fungible-token-metadata",
    "content": "\n<APIPage\n  document=\"./openapi/token-metadata-api.json\"\n  operations={[{ path: '/metadata/v1/sft/{principal}/{token_id}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get fungible tokens",
    "description": "Retrieves information about fungible tokens.",
    "slug": "/stacks/token-metadata-api/tokens/fungible-tokens",
    "content": "\n<APIPage\n  document=\"./openapi/token-metadata-api.json\"\n  operations={[{ path: '/metadata/v1/ft', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get non-fungible token metadata",
    "description": "Retrieves metadata for a SIP-009 non-fungible token.",
    "slug": "/stacks/token-metadata-api/tokens/non-fungible-token-metadata",
    "content": "\n<APIPage\n  document=\"./openapi/token-metadata-api.json\"\n  operations={[{ path: '/metadata/v1/nft/{principal}/{token_id}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Overview",
    "description": "Interact with the Stacks blockchain using a Javascript client library.",
    "slug": "/stacks/token-metadata-api/client/index",
    "content": "\nimport { Accordion, Accordions } from \"fumadocs-ui/components/accordion\";\nimport { Blocks, Braces, CircleUserRound } from 'lucide-react';\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\nThe `@stacks/blockchain-api-client` library provides a robust interface for interacting with the Stacks Blockchain API by offering type-safe methods to access REST and WebSocket endpoints.\n\nThe client includes automatically generated HTTP API methods, comprehensive Schemas for Clarity smart contract values, and a WebSocket client for real-time data streaming.\n\n```ts\nimport { AccountsApi } from '@stacks/blockchain-api-client';\n\nconst accounts = new AccountsApi(apiConfig);\n\nawait accounts.getAccountTransactions({\n  principal: 'ST000000000000000000002AMW42H',\n});\n```"
  },
  {
    "title": "Quickstart",
    "description": "Create your first project in less than 2 minutes",
    "slug": "/stacks/token-metadata-api/client/quickstart",
    "content": "\nThe Usage section should focus on practical, hands-on instructions for getting started with the API. This includes:\nAuthentication: How to authenticate with the API (e.g., API keys, OAuth tokens).\nMaking Requests: Basic examples of making requests to the API, including request format, essential headers, and parameters.\nHandling Responses: Information on response structure, understanding status codes, and error handling.\nRate Limits: If applicable, explain any rate limits and best practices for avoiding them.\nThe goal of the \"Usage\" section is to equip developers with the knowledge to make successful API calls and handle responses effectively.\n\n## Using Websockets\n\nThe WebSocket components enable you to subscribe to specific updates, providing a near real-time display of updates on transactions and accounts.\n\n```ts\nimport { connectWebSocketClient } from '@stacks/blockchain-api-client';\nconst client = await connectWebSocketClient('ws://api.hiro.so/');\nconst sub = await client.subscribeAddressTransactions(contractCall.txId, event => {\n  console.log(event);\n});\n\nawait sub.unsubscribe();\n```"
  },
  {
    "title": "Tokens",
    "description": "Manage token metadata, including token IDs, token URIs, and token traits.",
    "slug": "/stacks/token-metadata-api/client/tokens/index",
    "content": ""
  },
  {
    "title": "Get Fungible Token Metadata",
    "description": "Retrieves a list of all assets events associated with an account or a Contract Identifier.",
    "slug": "/stacks/token-metadata-api/client/tokens/get-ft-metadata",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\n<Root>\n\n<API className='api my-3'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`getAccountAssets`</h2>\n\nThis API endpoint retrieves a comprehensive list of asset events associated with a specific account or Contract Identifier, including asset transfers and mints. It is essential for tracking asset movements and changes in ownership within the Stacks blockchain.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"principal\"} type={\"string\"}>\nThe account address or contract identifier whose asset events are to be retrieved.\n</Property>\n\n<Property required={false} deprecated={false} name={\"initOverrides\"} type={\"RequestInit\"}>\nOptional overrides for the request initialization settings.\n</Property>\n\n</div>\n\n<APIExample>\n\n<Tabs defaultValue=\"get-assets\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"get-assets\" className='tab group'>\n      <Badge className='badge transition-colors'>Retrieve Account Assets</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"get-assets\">\n    ```tsx\n    import { Configuration, AccountsApi } from '@stacks/blockchain-api-client';\n    \n    const apiConfig = new Configuration({\n      basePath: 'https://api.testnet.hiro.so',\n    });\n\n    const accountsApi = new AccountsApi(apiConfig);\n    const principal = 'ST000000000000000000002AMW42H';\n    // Retrieve all asset events for the specified account or contract identifier\n    const assets = await accountsApi.getAccountAssets({\n      principal: principal,\n    });\n    ```\n\n    <Accordions>\n\n    <Accordion title={\"Full Code Sample\"}>\n      ```tsx\n      import {\n        UserSession,\n        makeAuthRequest,\n        AppConfig\n      } from '@stacks/auth';\n\n      const appDomain = 'https://www.myapp.com';\n\n      const appConfig = new AppConfig(['store_write'], appDomain);\n      const userSession = new UserSession({ appConfig });\n\n      // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n      const transitKey = userSession.generateAndStoreTransitKey();\n      \n      // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n      const redirectUri = 'https://www.myapp.com/auth';\n\n      // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n      const manifestUri = 'https://www.myapp.com/manifest.json';\n\n      // Generate the authentication request payload\n      const authRequest = userSession.makeAuthRequest(\n        transitKey,\n        redirectUri,\n        manifestUri\n      );\n      \n      ```\n    </Accordion>\n\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='api my-3'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`UserSession`</h2>\n\nThe Stacks authentication process enables secure user sign-in for web apps by generating and handling encrypted authentication requests. It involves setting up an app domain, configuring permissions, and creating a UserSession to manage user data.\n\n## Functions\n\n<Property required={false} deprecated={false} name={\"isSignInPending\"} type={\"function\"}>\n\nDetermines if there is an incoming authentication response.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"handlePendingSignIn\"} type={\"function\"}>\n\nProcesses the response and provides a `userData` object containing the user's identity, BNS username and profile information.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"isUserSignedIn\"} type={\"function\"}>\n\nChecks if the user is already authenticated.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"loadUserData\"} type={\"function\"}>\n\nRetrieves the user's profile data if the user is already authenticated.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"encryptContent\"} type={\"function\"}>\n\nEncrypts user data for secure storage.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"decryptContent\"} type={\"function\"}>\n\nDecrypts user data for secure storage.\n\n</Property>\n\n</div>\n\n<APIExample>\n<Tabs defaultValue=\"pending\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"pending\" className='tab group'>\n      <Badge className='badge transition-colors'>Handle incoming authentication response</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"status\" className='tab group'>\n      <Badge className='badge transition-colors'>Check if a user is signed in</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"user-data\" className='tab group'>\n      <Badge className='badge transition-colors'>Load data for signed in user</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"sign-out\" className='tab group'>\n      <Badge className='badge transition-colors'>Signing out a user</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"encrypt\" className='tab group'>\n      <Badge className='badge transition-colors'>Encrypting user data</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"decrypt\" className='tab group'>\n      <Badge className='badge transition-colors'>Decrypting user data</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"pending\">\n    ```tsx\n    const isPending = userSession.isSignInPending();\n\n    if (isPending) {\n      userSession.handlePendingSignIn().then(userData => {\n        // Do something with userData\n      });\n    }\n    ```\n  </TabsContent>\n  <TabsContent value='status'>\n    ```tsx\n    const isSignedIn = userSession.isUserSignedIn();\n    ```\n  </TabsContent>\n  <TabsContent value='user-data'>\n    ```tsx\n    const isSignedIn = userSession.isUserSignedIn();\n\n    if (isSignedIn) {\n      // Do something with the signed in user\n      const userData = userSession.loadUserData();\n    }\n    ```\n  </TabsContent>\n  <TabsContent value='sign-out'>\n    ```tsx\n    function logout() {\n      userSession.signUserOut();\n    }\n    ```\n  </TabsContent>\n  <TabsContent value='encrypt'>\n    ```tsx\n    const message = 'My secret message';\n\n    const cipherText = await userSession.encryptContent(message);\n    ```\n  </TabsContent>\n  <TabsContent value='decrypt'>\n    ```tsx\n    const message = 'My secret message';\n\n    const cipherText = await userSession.encryptContent(message);\n    const plainText = await userSession.decryptContent(cipherText);\n    ```\n  </TabsContent>\n</Tabs>\n\n<Accordions>\n\n<Accordion title={\"Notes\"}>\n  Note that encryption here uses the user's private key associated with your app only. If you need to share this data with another app or other users, you should use the equivalent methods from `@stacks/encryption` and provide a custom private key.\n</Accordion>\n\n</Accordions>\n\n</APIExample>\n\n</API>\n\n</Root>"
  },
  {
    "title": "Build a custom blockchain API",
    "description": "Learn how to build a custom API with Chainhook.",
    "slug": "/stacks/hacks/archive/build-a-custom-api",
    "content": "\nimport { HackBadge } from \"@/components/badge\";\n\n<Callout title=\"Inactive\" type=\"warn\">\nThis hack has been archived. Feel free to continue to use the code in this guide as a reference for your own projects.\n</Callout>\n\n## Introduction\n\nIn the previous hacks, you built some pretty complex smart contracts. But building a robust UI/UX around these smart contracts and their on-chain data can be challenging due to the nature of blockchains.\n\nLet's take the [decentralized grants program](/stacks/hacks/build-a-decentralized-grants-program) hack as an example. In this project, anyone can propose a grant, and these proposals are voted on by token holders. The details of each proposal, including the title, description, and the proposal contract, are stored on the blockchain.\n\nHowever, directly querying the blockchain for this data every time you want to display it in your application's UI can be slow and inefficient. And that information might not always be formatted and organized in a way that makes sense for your use case.\n\nThis is where [Chainhook](/stacks/chainhook) comes in. Chainhook allows you to listen for specific on-chain events, such as the submission of a new grant proposal, and trigger actions in response - like inserting specific data into a database to query off-chain.\n\nIn this guide, you'll build a custom API with Chainhook using the [Hiro Platform](https://platform.hiro.so/), with a focus on integrating it with the contracts you built for the decentralized grants program hack.\n\n## Creating a server\n\nIn this section, we'll briefly discuss setting up an Express server to handle incoming event data from Chainhook. While a detailed walkthrough of setting up an Express server is beyond the scope of this guide, you can reference an example app [here](https://github.com/hirosystems/examples/tree/main/apps/chainhook).\n\nTo illustrate how to handle this event data, here is an example `server.ts` file:\n\n```typescript\nconst express = require(\"express\")\nconst app = express()\napp.use(express.json())\n\napp.post(\"/api/events\", (req, res) => {\n  const events = req.body\n  // Process the event data here\n  res.status(200).send({ message: \"Event received\" })\n})\n\napp.listen(3000, () => {\n  console.log(\"Server is running on port 3000\")\n})\n```\n\nIn this example, the server listens for POST requests at the `/api/events` route. When a request is received from your chainhook (which you will set up in the next section), you can extract the event data from the request body and process it.\n\n## Parsing the event data\n\nThe Chainhook payload comes with a lot of information, so let's break down some of the more important parts inside of the `req.body` for this guide.\n\nHere is a truncated look at the payload structure from Chainhook:\n\n```json\n{\n  \"apply\": [\n    {\n      \"transactions\": [\n        {\n          \"metadata\": {\n            \"receipt\": \"...\"\n          },\n          \"operations\": [\n            {\n              \"...\": \"...\"\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n```\n\nEach item in the `apply` array should contain a `transactions` array. Each `transaction` object should have a `metadata` object with a `receipt` attribute and an `operations` array.\n\n- `transaction.metadata.receipt`: This attribute contains information about any events that were triggered from the function.\n- `transaction.operations`: This is an array that contains more specific information about what happened as a result of the function call. For instance if a _token transfer_ occured, each object inside this array would contain various attributes and information regarding the account, amount, type, and status of the token transfer.\n\nHere's what your POST route might look like after filtering for the relevant data in your `server.ts` file:\n\n```typescript\napp.post(\"/api/events\", async (req, res) => {\n  const events = req.body\n  // Loop through each item in the apply array\n  events.apply.forEach((item: any) => {\n    // Loop through each transaction in the item\n    item.transactions.forEach((transaction: any) => {\n      // If the transaction has operations, loop through them\n      if (transaction.operations) {\n        transaction.operations.forEach((operation: any) => {\n          // Log the operation\n          console.log({ operation })\n        })\n      }\n    })\n  })\n\n  // Send a response back to Chainhook to acknowledge receipt of the event\n  res.status(200).send({ message: \"Proposal added!\" })\n})\n```\n\nFor the next section, you will need to expose your local server via `https` so that Chainhook can deliver the `payload`. To do that, run the following command:\n\n```terminal\n$ npx localtunnel --port <your-port-number>\n```\n\n> _**Note**_\n>\n> There are several tools for exposing localhost to the world so choose the one you prefer. For more information on `localtunnel`, click [here](https://github.com/localtunnel/localtunnel).\n\n## Integrating with Chainhook\n\nIn this section, you will integrate Chainhook with your smart contracts. This involves creating a chainhook predicate that matches the specific on-chain events you want to respond to. For this process, you'll use the [Hiro Platform](https://platform.hiro.so/), which provides a user-friendly interface for creating and managing your chainhooks. By the end of this section, you'll have a chainhook set up and ready to trigger actions in response to on-chain events.\n\n## Deploying your contracts to testnet\n\nIn order to create your chainhook, you need to deploy your contracts to `testnet`. From your projects page, click on the Deploy button near the top right of your screen. You'll see your deployment options: choose \"Generate for Testnet.\"\n\n> _**Note**_\n>\n> The Platform will provide a step for requesting Testnet STX, but you can also go straight to the [Stacks Testnet Faucet](https://explorer.hiro.so/sandbox/faucet?chain=testnet). Once you have testnet STX tokens, you can deploy your contracts to testnet using the same methods you used for devnet, but with the network parameter set to testnet.\n\n## Creating a Chainhook\n\nNow it's time to create your first Chainhook. Start by creating a predicate that matches the `propose` function in your `proposal-submission` contract. This function is called when a new grant proposal is submitted.\n\nHere's an example of how you might define this `predicate.json` file for your contract:\n\n```json\n{\n  \"chain\": \"stacks\",\n  \"uuid\": \"1\",\n  \"name\": \"New Grant Proposal\",\n  \"version\": 1,\n  \"networks\": {\n    \"testnet\": {\n      \"if_this\": {\n        \"scope\": \"contract_call\",\n        \"contract_identifier\": \"ST2BSV94A650WGZ2YZ5Y8HM93W01NGT4GY0MGJECG.proposal-submission\",\n        \"method\": \"propose\"\n      },\n      \"then_that\": {\n        \"http_post\": {\n          \"url\": \"<your-https-server-url>\",\n          \"authorization_header\": \"Bearer 12345\"\n        }\n      },\n      \"start_block\": 138339\n    }\n  }\n}\n```\n\n<Callout title=\"Note\" type=\"info\">\n  Make sure to swap out the details in your `predicate.json` file to match your\n  contracts ABI.\n</Callout>\n\nThe `if_this` section specifies the conditions for the events that this Chainhook will respond to. In this case, it's looking for calls to the `propose` method in the `proposal-submission` contract on the Stacks testnet.\n\nThe `then_that` section specifies what action the Chainhook should take when it detects an event that matches the `if_this` conditions. Here, it's set up to send a POST request to your specified URL with the event data.\n\nThe `start_block` field is used to specify the starting block for the Chainhook to start listening from. This is useful for ignoring blocks that were mined before the Chainhook was set up.\n\nOnce you have created a similar file for your specific contract. select the _Chainhooks_ tab inside your project and upload your predicate file using the _Upload Chainhook_ option. For more information, you can follow the [Create Chainhooks](/stacks/platform/guides/create-chainhooks) section.\n\n## Testing your chainhook\n\nOnce you've successfully uploaded your chainhook predicate, it's time to test it out. You can do this by performing an action that aligns with your `if_this` - `then_that` logic.\n\nFor instance, if your Chainhook is set up to respond to a specific contract call, you can trigger that call and then check your `/api/post` endpoint. If everything is set up correctly, you should see any information you've requested to be logged.\n\nThe next section presents several challenges that will help you put the finishing touches on your API. With the foundation you've built, you're well-equipped to take on these challenges and continue your journey in building robust, decentralized applications.\n\nCongratulations on reaching this point! You now have all the building blocks needed to create a custom API using Chainhook and integrate it with your smart contracts. This is a significant step towards enhancing the functionality and user experience of your decentralized applications.\n\n<Callout title=\"Note\" type=\"warn\">\n  This is a crucial step in verifying that your Chainhook is working as\n  expected. If you don't see the expected output, you may need to revisit your\n  predicate and ensure it's correctly configured.\n</Callout>\n\n## Challenges\n\nThe following challenges are additional features you can implement to further explore building on Stacks. Feel free to add any other features you want.\n\n<HackBadge variant=\"starter\" />\n\n**Create more than 1 chainhook**: Don't stop at just 1! Follow the process above to create more than 1 chainhook for your dApp and parse the data accordingly.\n\n<HackBadge variant=\"intermediate\" />\n\n**Create consumer-facing API endpoints**: Up until now, we've shown you how to capture and process the initial `payload` data sent from a chainhook. However, to provide a robust user experience, you'll want to do more than just output raw data. The challenge here is to create additional API endpoints that present the filtered and extracted data from the initial `/api/events` payload in a consumer-friendly format. This could involve adding a database layer for organizing the data, adding additional context, or transforming the data to match the needs of your application's frontend. For a quick db setup, you can try using something like [Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/reactjs).\n\n```typescript\n// Example using Supabase\n\nconst supabase = createClient(\n  \"https://<project>.supabase.co\",\n  \"<your-anon-key>\"\n)\n\napp.post(\"/api/events\", async (req, res) => {\n  // ...\n\n  item.transactions.forEach((transaction: any) => {\n    if (transaction.operations) {\n      transaction.operations.forEach((operation: any) => {\n        const data = operation // Parse out the data you want\n        // Insert and save it to db\n        const { error } = await supabase.from(\"proposals\").insert(data)\n      })\n    }\n  })\n\n  // ...\n})\n```\n\n<HackBadge variant=\"advanced\" />\n\n**UI integration**: The final challenge is to integrate your consumer-facing API into your frontend. This involves taking the data you've processed and organized in your API and displaying it in a meaningful and user-friendly way in your application. This could involve creating dynamic components that update in response to new data, adding interactive elements that allow users to explore the data, or incorporating visualizations to help users understand the data.\n"
  },
  {
    "title": "Build a decentralized grants program",
    "description": "Learn how to build a decentralized grants program with governance, submissions, and voting.",
    "slug": "/stacks/hacks/archive/build-a-decentralized-grants-program",
    "content": "\nimport { HackBadge } from \"@/components/badge\";\n\n<Callout title=\"Inactive\" type=\"warn\">\nThis hack has been archived. Feel free to continue to use the code in this guide as a reference for your own projects.\n</Callout>\n\n## Introduction\n\nWelcome to a world where funding for innovative projects is fluid and controlled by a community of token holders, not just a select few. This is the value proposition of a decentralized grants program. In this guide, you will build such a program using the [ExecutorDAO](https://github.com/MarvinJanssen/executor-dao) protocol on the Stacks blockchain.\n\nKey features of this project include:\n\n**Decentralized Governance**: Anyone holding a `membership-token` can vote on grant proposals.\n\n**Open Proposal Submission**: Anyone can propose a grant, encouraging a wide range of ideas and projects.\n\n**Smart Contract Automation**: All aspects of the grants program, from proposal submission to voting and fund distribution, are automated through smart contracts, ensuring transparency and tamper-proof processes.\n\nThis Hack walks you through the basics of building a decentralized grants program. Over the course of this hack, you will deploy your own functioning grants program.\n\nThere are also optional challenges at the end to further stretch your skills.\n\nNow it's time to hack. First, we'll cover the basics of the core functionalities of our grants program and look at 4 contracts. Let's dive in.\n\n## Understanding the ExecutorDAO protocol\n\nExecutorDAO is a powerful and flexible protocol that allows for the creation of decentralized autonomous organizations (DAOs) with a high degree of modularity and customization. ExecutorDAO operates on three core tenets:\n\n**Proposals are smart contracts**:\nProposals in ExecutorDAO are expressed as smart contracts, allowing for precise, logical descriptions of the operations, duties, and members of the DAO. In our case, each grant application is a proposal expressed as a smart contract.\n\n**The core executes, the extensions give form**:\nExecutorDAO starts with a single core contract whose sole purpose is to execute proposals and keep a list of authorized `extensions`. Extensions are contracts that can be enabled or disabled by proposals and add specific features to the DAO - like _proposing grants_, _voting on grants_, _distributing funds_, and more.\n\n**Ownership control happens via sending context**:\nExecutorDAO follows a single-address ownership model. The core contract is the de facto owner of external ownable contracts. This allows any proposal or extension to act upon it, like the `membership-token` we will build out in the sections below.\n\nFor more details, you can [view the standard contracts](https://github.com/MarvinJanssen/executor-dao/tree/main/contracts) in the ExecutorDAO repository.\n\n## Clone the starter template\n\nStart by setting up your development environment. We've prepared a repository that includes an initialized Clarinet project and a React frontend with some boilerplate code and all the required packages.\n\nTo clone the repository, open your terminal and run the following command:\n\n```terminal\n$ git clone https://github.com/hirosystems/hiro-hacks-template.git\n$ cd hiro-hacks-template\n```\n\n## Establishing your core contract\n\nBefore creating your core contract, you need to create `trait` contracts that you'll be implementing for your grants program.\n\nTraits in Clarity define a set of functions that a contract must implement. In this case, any contract that wants to be a `proposal` or an `extension` must implement the functions defined in the `proposal-trait` and `extension-trait` respectively.\n\nIn your project's directory, run the following command:\n\n```terminal\n$ clarinet contract new extension-trait && clarinet contract new proposal-trait\n```\n\nNow in your contracts, respectively, add the following code:\n\n```clarity extension-trait.clar\n(define-trait extension-trait\n  (\n    (callback (principal (buff 34)) (response bool uint))\n  )\n)\n```\n\n```clarity proposal-trait.clar\n(define-trait proposal-trait\n  (\n    (execute (principal) (response bool uint))\n  )\n)\n```\n\nNow that you've defined how your set of functions must be implemented, you can begin to create your core contract. First run the following command:\n\n```terminal\n$ clarinet contract new core\n```\n\nThis will create a new contract in the `contracts` directory called `core.clar`.\n\nInside your `core.clar` contract, add the two trait contracts you've just created from the steps above:\n\n```clarity core.clar\n(use-trait proposal-trait .proposal-trait.proposal-trait)\n(use-trait extension-trait .extension-trait.extension-trait)\n```\n\n## Error handling and state management\n\nNext, you need to define some basic error handling and variables for managing your contracts:\n\n```clarity core.clar\n(define-constant ERR_UNAUTHORIZED (err u1000))\n(define-constant ERR_ALREADY_EXECUTED (err u1001))\n(define-constant ERR_INVALID_EXTENSION (err u1002))\n\n(define-data-var executive principal tx-sender)\n(define-map executedProposals principal uint)\n(define-map extensions principal bool)\n```\n\nThese constants represent error codes that the contract can return. The variables store the executive principal (the owner of the grants program), a map of executed proposals, and a map of authorized extensions.\n\n## Authorization check\n\nThe `is-self-or-extension` function is a private function that checks if the caller of a function is the contract itself or an authorized extension:\n\n```clarity core.clar\n(define-private (is-self-or-extension)\n  (ok (asserts! (or (is-eq tx-sender (as-contract tx-sender)) (is-extension contract-caller)) ERR_UNAUTHORIZED))\n)\n\n(define-read-only (is-extension (extension principal))\n  (default-to false (map-get? extensions extension))\n)\n\n(define-read-only (executed-at (proposal <proposal-trait>))\n  (map-get? executedProposals (contract-of proposal))\n)\n```\n\n## Extension management\n\nHere's a function to enable or disable an extension (`set-extension`):\n\n```clarity core.clar\n(define-public (set-extension (extension principal) (enabled bool))\n  (begin\n    (try! (is-self-or-extension))\n    (print {event: \"extension\", extension: extension, enabled: enabled})\n    (ok (map-set extensions extension enabled))\n  )\n)\n```\n\n## Proposal execution\n\nThe `execute` function allows for the execution of a proposal:\n\n```clarity core.clar\n(define-public (execute (proposal <proposal-trait>) (sender principal))\n  (begin\n    (try! (is-self-or-extension))\n    (asserts! (map-insert executedProposals (contract-of proposal) block-height) ERR_ALREADY_EXECUTED)\n    (print {event: \"execute\", proposal: proposal})\n    (as-contract (contract-call? proposal execute sender))\n  )\n)\n```\n\nThis function checks if the caller is authorized, inserts the proposal into the `executedProposals` map, and then calls the `execute` function of the proposal contract.\n\n## Bootstrap\n\nThe `construct` function is used to bootstrap the grants program:\n\n```clarity core.clar\n(define-public (construct (proposal <proposal-trait>))\n  (let\n    (\n      (sender tx-sender)\n    )\n    (asserts! (is-eq sender (var-get executive)) ERR_UNAUTHORIZED)\n    (var-set executive (as-contract tx-sender))\n    (as-contract (execute proposal sender))\n  )\n)\n```\n\nThis function checks if the caller is the executive, sets the executive to the contract itself, and then executes the provided proposal.\n\n## Extension requests\n\nThe request-extension-callback function allows an extension to request a callback:\n\n```clarity core.clar\n(define-public (request-extension-callback (extension <extension-trait>) (memo (buff 34)))\n  (let\n    (\n      (sender tx-sender)\n    )\n    (asserts! (is-extension contract-caller) ERR_INVALID_EXTENSION)\n    (asserts! (is-eq contract-caller (contract-of extension)) ERR_INVALID_EXTENSION)\n    (as-contract (contract-call? extension callback sender memo))\n  )\n)\n```\n\nThis function checks if the caller is an authorized extension and then calls the `callback` function of the extension contract.\n\nThese are the key components of the ExecutorDAO core contract. Understanding these will help you in building your own extensions and proposals.\n\n## Create your membership token\n\nIn this section, you will create your first `extension`, a non-transferable membership token, which will be used to grant voting rights on proposals. The token will be initially distributed to certain addresses during the bootstrapping process. However, new minting (distribution) and burning (removal) of tokens can be managed through proposals.\n\nTo create your membership token, navigate to your project's directory and run the following command:\n\n```terminal\n$ clarinet contract new membership-token\n```\n\nThis will create a new contract in the contracts directory called `membership-token.clar`.\n\nLet's walk through the key components of this contract.\n\n## Constants and variables\n\nThe contract defines some constants and variables:\n\n```clarity membership-token.clar\n(define-constant ERR_UNAUTHORIZED (err u2000))\n(define-constant ERR_NOT_TOKEN_OWNER (err u2001))\n(define-constant ERR_MEMBERSHIP_LIMIT_REACHED (err u2002))\n\n(define-fungible-token sGrant)\n\n(define-data-var tokenName (string-ascii 32) \"sGrant\")\n(define-data-var tokenSymbol (string-ascii 10) \"SGT\")\n(define-data-var tokenUri (optional (string-utf8 256)) none)\n(define-data-var tokenDecimals uint u6)\n```\n\nThese constants represent error codes that the contract can return. The variables store the token name, symbol, URI, and decimals. The define-fungible-token function is used to define our sGrant token.\n\n## Authorization check\n\nThe `is-dao-or-extension`, function is a private function that checks if the caller of a function is the core contract itself or an authorized extension:\n\n```clarity membership-token.clar\n(define-public (is-dao-or-extension)\n  (ok (asserts! (or (is-eq tx-sender .core) (contract-call? .core is-extension contract-caller)) ERR_UNAUTHORIZED))\n)\n```\n\nThis function will allow you to distribute (or burn) tokens to new members, granting them the ability to vote on future grant proposals.\n\n## Token minting and burning\n\nThe contract provides functions to `mint` and `burn` tokens:\n\n```clarity membership-token.clar\n(define-public (mint (amount uint) (recipient principal))\n  (begin\n    (try! (is-dao-or-extension))\n    (ft-mint? sGrant amount recipient)\n  )\n)\n\n(define-public (burn (amount uint) (owner principal))\n  (begin\n    (try! (is-dao-or-extension))\n    (ft-burn? sGrant amount owner)\n  )\n)\n```\n\nThese functions check if the caller is authorized and then mint or burn the specified amount of sGrant tokens. And as you can see, these functions must be executed either through an approved grant proposal or an enabled `extension` (more on this later).\n\n## Token information\n\nThe contract provides functions to get the token's name (`get-name`), symbol (`get-symbol`), decimals (`get-decimals`), balance (`get-balance`), total supply (`get-total-supply`), and URI (`get-token-uri`):\n\n```clarity membership-token.clar\n(define-read-only (get-name)\n  (ok (var-get tokenName))\n)\n\n(define-read-only (get-symbol)\n  (ok (var-get tokenSymbol))\n)\n\n(define-read-only (get-decimals)\n  (ok (var-get tokenDecimals))\n)\n\n(define-read-only (get-balance (who principal))\n  (ok (ft-get-balance sGrant who))\n)\n\n(define-read-only (get-total-supply)\n  (ok (ft-get-supply sGrant))\n)\n\n(define-read-only (get-token-uri)\n  (ok (var-get tokenUri))\n)\n```\n\nThese functions return the corresponding information about the `sGrant` token.\n\nThese are the key components of the `sGrant` token contract. Understanding these will help you in managing the distribution and burning of tokens through proposals.\n\n## Proposal submission contract (extension)\n\nIn this section, you will create your second `extension`, a proposal submission contract. This contract will allow anyone to propose a grant, which will then be voted on by the token holders.\n\nTo create your proposal submission contract, navigate to your project's directory and run the following command:\n\n```terminal\n$ clarinet contract new proposal-submission\n```\n\nThis will create a new contract in the contracts directory called proposal-submission.clar.\n\nLet's walk through the key components of this contract.\n\n## Traits and constants\n\nFirst, you need to implement the `extension-trait` and use the `proposal-trait`:\n\n```clarity proposal-submission.clar\n(impl-trait .extension-trait.extension-trait)\n(use-trait proposal-trait .proposal-trait.proposal-trait)\n```\n\nNext, define some constants that represent error codes:\n\n```clarity proposal-submission.clar\n(define-constant ERR_UNAUTHORIZED (err u3000))\n(define-constant ERR_UNKNOWN_PARAMETER (err u3001))\n```\n\n## Variables\n\nFirst, define a map to store the parameters of your contract:\n\n```clarity proposal-submission.clar\n(define-map parameters (string-ascii 34) uint)\n```\n\nSet the proposal-duration parameter to a default value. This value represents the duration of a proposal in blocks. For example, if a block is mined approximately every 10 minutes, a proposal-duration of 1440 would be approximately 10 days.\n\n```clarity proposal-submission.clar\n(map-set parameters \"proposal-duration\" u1440) ;; ~10 days based on a ~10 minute block time.\n```\n\n## Authorization check\n\nThe `is-dao-or-extension` function is a private function that checks if the caller of a function is the core contract itself or an authorized extension:\n\n```clarity proposal-submission.clar\n(define-public (is-dao-or-extension)\n  (ok (asserts! (or (is-eq tx-sender .core) (contract-call? .core is-extension contract-caller)) ERR_UNAUTHORIZED))\n)\n```\n\n## Parameters\n\nThe get-parameter function is a read-only function that returns the value of a parameter:\n\n```clarity proposal-submission.clar\n(define-read-only (get-parameter (parameter (string-ascii 34)))\n  (ok (unwrap! (map-get? parameters parameter) ERR_UNKNOWN_PARAMETER))\n)\n```\n\n## Proposals\n\nThe propose function allows anyone to propose a grant:\n\n```clarity proposal-submission.clar\n(define-public (propose (proposal <proposal-trait>) (title (string-ascii 50)) (description (string-utf8 500)))\n  (begin\n    (contract-call? .proposal-voting add-proposal\n      proposal\n      {\n        end-block-height: (+ block-height (try! (get-parameter \"proposal-duration\"))),\n        proposer: tx-sender,\n        title: title,\n        description: description\n      }\n    )\n  )\n)\n```\n\nThis function calls the add-proposal function of the proposal-voting contract, passing the proposal contract, the current block height as the start block height, the current block height plus the proposal-duration as the end block height, the sender as the proposer, and the title and description of the proposal.\n\n## Extension callback\n\nThe callback function allows the core contract to request a callback:\n\n```clarity proposal-submission.clar\n(define-public (callback (sender principal) (memo (buff 34)))\n  (ok true)\n)\n```\n\nThese are the key components of the proposal submission contract. Understanding these will help you in managing the submission of proposals.\n\n## Proposal voting contract (extension)\n\nIn this section, you will create your third extension, a proposal voting contract. This contract will allow token holders to vote on the proposed grants.\n\nTo create your proposal voting contract, navigate to your project's directory and run the following command:\n\n```terminal\n$ clarinet contract new proposal-voting\n```\n\nThis will create a new contract in the contracts directory called proposal-voting.clar.\n\nLet's walk through the key components of this contract.\n\n## Traits and constants\n\nFirst, you need to implement the extension-trait and use the proposal-trait:\n\n```clarity proposal-voting.clar\n(impl-trait .extension-trait.extension-trait)\n(use-trait proposal-trait .proposal-trait.proposal-trait)\n```\n\nNext, define some constants that represent error codes:\n\n```clarity proposal-voting.clar\n(define-constant ERR_UNAUTHORIZED (err u3000))\n(define-constant ERR_PROPOSAL_ALREADY_EXECUTED (err u3002))\n(define-constant ERR_PROPOSAL_ALREADY_EXISTS (err u3003))\n(define-constant ERR_UNKNOWN_PROPOSAL (err u3004))\n(define-constant ERR_PROPOSAL_ALREADY_CONCLUDED (err u3005))\n(define-constant ERR_PROPOSAL_INACTIVE (err u3006))\n(define-constant ERR_PROPOSAL_NOT_CONCLUDED (err u3007))\n(define-constant ERR_NO_VOTES_TO_RETURN (err u3008))\n(define-constant ERR_END_BLOCK_HEIGHT_NOT_REACHED (err u3009))\n(define-constant ERR_DISABLED (err u3010))\n```\n\n## Variables\n\nYou need to define a map to store the proposals and another map to store the total votes of each member:\n\n```clarity proposal-voting.clar\n(define-map proposals\n  principal\n  {\n    votes-for: uint,\n    votes-against: uint,\n    end-block-height: uint,\n    concluded: bool,\n    passed: bool,\n    proposer: principal,\n    title: (string-ascii 50),\n    description: (string-utf8 500)\n  }\n)\n\n(define-map member-total-votes {proposal: principal, voter: principal} uint)\n```\n\n## Authorization check\n\nThe `is-dao-or-extension` function is a private function that checks if the caller of a function is the core contract itself or an authorized extension:\n\n```clarity proposal-voting.clar\n(define-public (is-dao-or-extension)\n  (ok (asserts! (or (is-eq tx-sender .core) (contract-call? .core is-extension contract-caller)) ERR_UNAUTHORIZED))\n)\n```\n\n## Proposals\n\nThe add-proposal function allows the core contract or an authorized extension to add a new proposal:\n\n```clarity proposal-voting.clar\n(define-public (add-proposal (proposal <proposal-trait>) (data {end-block-height: uint, proposer: principal, title: (string-ascii 50), description: (string-utf8 500)}))\n  (begin\n    (try! (is-dao-or-extension))\n    (asserts! (is-none (contract-call? .core executed-at proposal)) ERR_PROPOSAL_ALREADY_EXECUTED)\n    (print {event: \"propose\", proposal: proposal, proposer: tx-sender})\n    (ok (asserts! (map-insert proposals (contract-of proposal) (merge {votes-for: u0, votes-against: u0, concluded: false, passed: false} data)) ERR_PROPOSAL_ALREADY_EXISTS))\n  )\n)\n```\n\n## Votes\n\nThe vote function allows a token holder to vote on a proposal. It checks if the voter has at least 1 membership-token:\n\n```clarity proposal-voting.clar\n(define-public (vote (amount uint) (for bool) (proposal principal))\n  (let\n    (\n      (proposal-data (unwrap! (map-get? proposals proposal) ERR_UNKNOWN_PROPOSAL))\n    )\n    (asserts! (>= (unwrap-panic (contract-call? .membership-token get-balance tx-sender)) u1) ERR_UNAUTHORIZED)\n    (map-set member-total-votes {proposal: proposal, voter: tx-sender}\n      (+ (get-current-total-votes proposal tx-sender) amount)\n    )\n    (map-set proposals proposal\n      (if for\n        (merge proposal-data {votes-for: (+ (get votes-for proposal-data) amount)})\n        (merge proposal-data {votes-against: (+ (get votes-against proposal-data) amount)})\n      )\n    )\n    (ok (print {event: \"vote\", proposal: proposal, voter: tx-sender, for: for, amount: amount}))\n  )\n)\n\n(define-read-only (get-current-total-votes (proposal principal) (voter principal))\n  (default-to u0 (map-get? member-total-votes {proposal: proposal, voter: voter}))\n)\n```\n\n## Conclusion\n\nThe `conclude` function allows the core contract or an authorized extension to conclude a proposal:\n\n```clarity proposal-voting.clar\n(define-public (conclude (proposal <proposal-trait>))\n  (let\n    (\n      (proposal-data (unwrap! (map-get? proposals (contract-of proposal)) ERR_UNKNOWN_PROPOSAL))\n      (passed (> (get votes-for proposal-data) (get votes-against proposal-data)))\n    )\n    (asserts! (not (get concluded proposal-data)) ERR_PROPOSAL_ALREADY_CONCLUDED)\n    (asserts! (>= block-height (get end-block-height proposal-data)) ERR_END_BLOCK_HEIGHT_NOT_REACHED)\n    (map-set proposals (contract-of proposal) (merge proposal-data {concluded: true, passed: passed}))\n    (print {event: \"conclude\", proposal: proposal, passed: passed})\n    (and passed (try! (contract-call? .core execute proposal tx-sender)))\n    (ok passed)\n  )\n)\n```\n\nThis function concludes a proposal. It first retrieves the proposal data and checks if the proposal has more votes for than against. It then asserts that the proposal has not already been concluded and that the current block height is greater than or equal to the end block height of the proposal. If these conditions are met, it sets the concluded and passed fields of the proposal data and prints an event. If the proposal passed, it also tries to execute the proposal. The function returns whether the proposal passed.\n\n## Extension callback\n\nThe callback function allows the core contract to request a callback:\n\n```clarity proposal-voting.clar\n(define-public (callback (sender principal) (memo (buff 34)))\n  (ok true)\n)\n```\n\nCongratulations! You've successfully created the foundations for a decentralized grants program!\n\n## Challenges\n\nThe following challenges are additional features you can implement to continue building and sharpening your skills.\n\n<HackBadge variant=\"starter\" />\n\n**Initialize your grants program**: Now that you have your core extension contracts, you can initialize the project. The way you do this is through the `construct` function you wrote inside your `core.clar` contract. Create your first proposal enabling your extensions (`membership-token`, `proposal-submission`, `proposal-voting`) and distribute the initial token allocation to addresses responsible for voting on grants. If you need a little more guidance, check out the example [here](https://github.com/MarvinJanssen/executor-dao/blob/main/contracts/proposals/edp000-bootstrap.clar).\n\n<HackBadge variant=\"starter\" />\n\n**Create grant proposals**: After initializing your grants program, the next step is to create grant proposals. This involves using the `propose` function in the `proposal-submission` contract. This function allows anyone to propose a grant, which will then be voted on by the token holders. The proposal includes details such as the title, description, and the proposal contract. Once a proposal is submitted, it can be voted on during the voting period defined by the `proposal-duration` parameter.\n\n<HackBadge variant=\"intermediate\" />\n\n**Implement milestone-based funding**: To implement milestone-based funding, you'll need to create a new extension contract that tracks the progress of each grant proposal. This extension will manage the milestones for each grant, allowing funds to be released as each milestone is achieved. To enable this extension, you'll need to create a proposal using the propose function in the `proposal-submission` contract. Once enabled, the milestone-based funding extension will provide a more structured and accountable way to distribute funds, ensuring that the grant recipients are making progress before they receive their next round of funding.\n\n<HackBadge variant=\"advanced\" />\n\n**UI integration**: Using the provided starter template, integrate your contracts using Stacks.js. This will allow users to submit proposals, vote on them, and view the status of their proposals directly from the UI.\n\n```tsx\nimport { callReadOnlyFunction, standardPrincipalCV } from \"@stacks/transactions\"\n\nconst senderAddress = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\"\nconst contractAddress = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\"\nconst contractName = \"core\"\nconst functionName = \"is-extension\"\nconst extensionAddress =\n  \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.membership-token\"\n\nconst functionArgs = [standardPrincipalCV(extensionAddress)]\n\nawait callReadOnlyFunction({\n  network,\n  contractAddress,\n  contractName,\n  functionName,\n  functionArgs,\n  senderAddress\n})\n```\n"
  },
  {
    "title": "AI x Stacks",
    "description": "Build something that combines AI capabilities with Stacks.",
    "slug": "/stacks/hacks/archive/ai",
    "content": "\n## January: AI x Stacks\n\n*Build something that combines AI capabilities with Stacks blockchain technology*\n\n**Timeline**: January 22-28, 2025\n\nThis month's challenge invites you to explore the intersection of artificial intelligence and blockchain technology. Create innovative solutions that leverage both AI capabilities and the Stacks blockchain.\n\nSubmit your project [here](https://hirohacks25.paperform.co/).\n\n<iframe width=\"770\" height=\"315\" src=\"https://www.youtube.com/embed/GiKRSAMQNqo?si=EQ74OTyTsOzcPIK-\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerPolicy=\"strict-origin-when-cross-origin\" allowFullScreen></iframe>\n\n## Example project ideas\n\n### 1. AI Contract Analyzer\n- Build a tool that uses LLMs to audit and explain [Clarity contracts](/stacks/clarity)\n- Help developers understand and improve their smart contracts through AI-powered analysis\n- Provide suggestions for security improvements and optimizations\n\n### 2. Smart Wallet Assistant  \n- Create an AI-powered [wallet](/stacks/stacks.js) that helps users make informed decisions\n- Analyze transaction history and provide personalized insights\n- Offer predictive analytics and spending recommendations\n\n### 3. Chain Detective\n- Develop an AI tool that analyzes on-chain data to discover interesting patterns\n- Use [Chainhook](/stacks/chainhook) to stream and analyze blockchain events in real-time\n- Generate visualizations and reports of blockchain activity\n\n_Review the [submission guidelines](/stacks/hacks/#rules) for project requirements and join the [Stacks Discord](https://stacks.chat) to connect with other builders._\n\n---\n\n## Resources\n\n- [Clarity Codex](https://github.com/leahjlou/clarity-codex/)\n- [Stacks Discord](https://stacks.chat)"
  },
  {
    "title": "Build a Friend.tech clone",
    "description": "Learn how to build a decentralized social network.",
    "slug": "/stacks/hacks/archive/build-a-friend-tech-clone",
    "content": "\nimport { HackBadge } from \"@/components/badge\";\n\n<Callout title=\"Inactive\" type=\"warn\">\nThis hack has been archived. Feel free to continue to use the code in this guide as a reference for your own projects.\n</Callout>\n\n## Introduction\n\nWhat if we could gamify—and reward—being a friend? That's the idea behind Friend.tech, the decentralized social network that took Web3 by storm. In this hack, you'll recreate Friend.tech on the Stacks blockchain.\n\nThere are a few key components to this hack: namely, **subjects** that have **keys** that anyone can buy. These keys start off low in price, but as people buy more keys, the price goes up faster and faster, rewarding friends who bought keys early. Key owners can sell their keys for a profit, or they can hold on to them to signal their friendship and build reputation. These keys can also be used to access exclusive chatrooms with their corresponding subject, receive exclusive airdrops, and more\n\nThis Hack walks you through the basics of building a Friend.tech clone. There are also challenges at the end, which are opportunities to stretch your skills and keep learning.\n\n## Clone the starter template\n\nStart by setting up your development environment. We've prepared a repository that includes an initialized Clarinet project and a React frontend with some boilerplate code and all the required packages.\n\nTo clone the repository, open your terminal and run the following command:\n\n```terminal\n$ git clone https://github.com/hirosystems/hiro-hacks-template.git\n$ cd hiro-hacks-template\n```\n\n## Create your contract\n\nBefore you begin, we're assuming that you have `clarinet` installed and a basic understanding of how to use it. If you haven't installed `clarinet` yet, you can do so by referring to our [installation guide](/stacks/clarinet/installation).\n\nTo create your contract, navigate to your project's directory and run the following command:\n\n```terminal\n$ clarinet contract new keys\n```\n\nThis will create a new contract in the `contracts` directory called `keys.clar`.\n\n<Callout type=\"info\">\n  If you don't want to clone the provided starter template, you can create your\n  `Clarinet` project manually by running `clarinet new friendtech && cd\n  friendtech`.\n</Callout>\n\n## Defining `key` balances and supply\n\nInside your `keys.clar` contract, you need to keep track of the balance of `keys` for each user (or _holder_) and the total supply of `keys` for each subject. You can do this using Clarity's `define-map` function:\n\n```clarity keys.clar\n(define-map keysBalance { subject: principal, holder: principal } uint)\n(define-map keysSupply { subject: principal } uint)\n```\n\nThe `keysBalance` stores each holder's `key` balance for a given subject and the `keysSupply` stores the total supply for each subject. These maps will be used in your contract's functions to manage the creation, buying, and selling of `keys`.\n\n## Calculating `key` prices\n\nThe next thing you need to do is define a function that calculates the price of `keys` for a given a `supply` and `amount`. You can do this by defining a `get-price` function:\n\n```clarity keys.clar\n(define-read-only (get-price (supply uint) (amount uint))\n  (let (\n    (base-price u10) ;; Base price per key in micro-STX\n    (price-change-factor u100) ;; Factor to control the rate of price change\n  )\n  ;; Average price per token over the range of supply\n  (/\n    (+\n      (* base-price amount)\n      (* amount (/ (+ (* supply supply) (* supply amount) (* amount amount)) (* u3 price-change-factor)))\n    )\n    amount\n  )\n))\n```\n\nThe `get-price` function calculates the price of `keys` using a formula that calculates the average price per token over the range of supply affected. This can be done by integrating the price function over the range of supply and dividing by the amount.\n\n## Creating, buying, and selling `keys`\n\nThese functions form the core of the contract's operations, enabling users to manage keys through buying and selling.\n\nLet's first take a look at the `buy-keys` function:\n\n```clarity keys.clar\n(define-public (buy-keys (subject principal) (amount uint))\n  (let\n    (\n      (supply (default-to u0 (map-get? keysSupply { subject: subject })))\n      (price (get-price supply amount))\n    )\n    (if (or (> supply u0) (is-eq tx-sender subject))\n      (begin\n        (match (stx-transfer? price tx-sender (as-contract tx-sender))\n          success\n          (begin\n            (map-set keysBalance { subject: subject, holder: tx-sender }\n              (+ (default-to u0 (map-get? keysBalance { subject: subject, holder: tx-sender })) amount)\n            )\n            (map-set keysSupply { subject: subject } (+ supply amount))\n            (ok true)\n          )\n          error\n          (err u2)\n        )\n      )\n      (err u1)\n    )\n  )\n)\n```\n\nThis function allows subjects to create their first `keys`, initiating their supply in the contract. The transaction only succeeds if the _subject_ is creating the initial `keys` or if there are already `keys` in circulation, ie `principal-a` cannot buy the initial `keys` for `principal-b`.\n\nNext up, the `sell-keys` function:\n\n```clarity keys.clar\n(define-public (sell-keys (subject principal) (amount uint))\n  (let\n    (\n      (balance (default-to u0 (map-get? keysBalance { subject: subject, holder: tx-sender })))\n      (supply (default-to u0 (map-get? keysSupply { subject: subject })))\n      (price (get-price (- supply amount) amount))\n      (recipient tx-sender)\n    )\n    (if (and (>= balance amount) (or (> supply u0) (is-eq tx-sender subject)))\n      (begin\n        (match (as-contract (stx-transfer? price tx-sender recipient))\n          success\n          (begin\n            (map-set keysBalance { subject: subject, holder: tx-sender } (- balance amount))\n            (map-set keysSupply { subject: subject } (- supply amount))\n            (ok true)\n          )\n          error\n          (err u2)\n        )\n      )\n      (err u1)\n    )\n  )\n)\n```\n\nThis is more or less the same logic as the `buy-keys` function, but instead you deduct the `keysBalance` and `keysSupply` and check if the seller owns enough keys and if they are authorized to sell.\n\n## Verifying keyholders\n\nNow that you have the ability to buy and sell `keys`, you need a way to verify if a user is a keyholder. You can do this by defining an `is-keyholder` read-only function:\n\n```clarity keys.clar\n(define-read-only (is-keyholder (subject principal) (holder principal))\n  (>= (default-to u0 (map-get? keysBalance { subject: subject, holder: holder })) u1)\n)\n```\n\nThis function checks if the `keysBalance` for a given `subject` and `holder` is greater than or equal to 1. If it is, then the user `is-keyholder`.\n\n## Testing locally\n\nMake sure your contract is valid and doesn't have any errors. To do this, run the following command:\n\n```terminal\n$ clarinet check\n```\n\nNext, check some of your contract functionality inside `clarinet console`:\n\n```clarity keys.clar\n;; Get the price of 100 keys when the supply is 0\n(contract-call? .keys get-price u0 u100) ;; u10010\n\n;; Initial purchase of keys\n(contract-call? .keys buy-keys tx-sender u100)\n\n;; Check if the sender is a keyholder\n(contract-call? .keys is-keyholder tx-sender tx-sender) ;; true\n\n(contract-call? .keys is-keyholder tx-sender  'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5) ;; false\n```\n\nCongratulations! You've successfully created your contract. You've laid the groundwork for a decentralized social network, just like Friend.tech.\n\n## Challenges\n\nThe following challenges are additional features you can implement to keep learning and building on Stacks.\n\n<HackBadge variant=\"starter\" />\n\n**Balance and supply query functions**: Add two new read-only functions: `get-keys-balance` and `get-keys-supply`. These functions will provide valuable information to users about the distribution and availability of `keys`, and can be used in various parts of your application to display this information to users.\n\n```clarity keys.clar\n(define-read-only (get-keys-balance (subject principal) (holder principal))\n  ;; Return the keysBalance for the given subject and holder\n)\n\n(define-read-only (get-keys-supply (subject principal))\n  ;; Return the keysSupply for the given subject\n)\n```\n\n<HackBadge variant=\"starter\" />\n\n**Price query functions**: Add two new read-only functions: `get-buy-price` and `get-sell-price`. These helper functions will allow users to query the current price for buying or selling a specific amount of `keys` for a given `subject`.\n\n```clarity keys.clar\n(define-read-only (get-buy-price (subject principal) (amount uint))\n  ;; Implement buy price logic\n)\n\n(define-read-only (get-sell-price (subject principal) (amount uint))\n  ;; Implement sell price logic\n)\n```\n\n<HackBadge variant=\"intermediate\" />\n\n**Fee management**: When a user buys or sells `keys`, you might want to introduce a fee, either at the protocol or subject level that can be distributed accordingly. Add a `protocolFeePercent` and/or `subjectFeePercent` variable, as well as a destination Stacks principal `protocolFeeDestination` for this new revenue. Now make sure to update the `buy-keys` and `sell-keys` functions to incorporate these fees and `stx-transfer?` into the buying and selling logic.\n\n```clarity keys.clar\n;; Change the fee values as you wish\n(define-data-var protocolFeePercent uint u200) ;; or subjectFeePercent\n(define-data-var protocolFeeDestination principal tx-sender)\n```\n\n<HackBadge variant=\"intermediate\" />\n\n**Access control**: In a real-world application, you might need to adjust the `protocolFeePercent`, `subjectFeePercent`, or `protocolFeeDestination` values over time. However, you wouldn't want just anyone to be able to make these changes. This is where access control comes in. Specifically, you should add a set-fee function (or functions) that allows only a designated `contractOwner` to change the `protocolFeePercent`, `subjectFeePercent`, or `protocolFeeDestination` values.\n\n```clarity keys.clar\n(define-public (set-protocol-fee-percent (feePercent uint))\n  ;; Check if the caller is the contractOwner\n  ;; Update the protocolFeePercent value\n)\n```\n\nThink about how you can verify whether the caller of the function is indeed the `contractOwner`. Also, consider what kind of feedback the function should give when someone else tries to call it. Test your implementation to ensure it works as expected.\n\n<HackBadge variant=\"intermediate\" />\n\n**UI integration**: Using the provided [starter template](#clone-the-starter-template), integrate your contract using [Stacks.js](/stacks/stacks.js). For example, if you were calling the `is-keyholder` function, your code might look something like this:\n\n```tsx\nimport { callReadOnlyFunction, standardPrincipalCV } from \"@stacks/transactions\"\n\nconst senderAddress = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\"\nconst contractAddress = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\"\nconst contractName = \"keys\"\nconst functionName = \"is-keyholder\"\n\nconst functionArgs = [standardPrincipalCV(senderAddress)]\n\nawait callReadOnlyFunction({\n  network,\n  contractAddress,\n  contractName,\n  functionName,\n  functionArgs,\n  senderAddress\n})\n```\n\nBy using a similar pattern to the code above, you will be able to **show/hide chatrooms based on keyholdings**, **create an exchange for buying/selling keys**, or **add a search for displaying subject keyholdings**.\n\n> _**Note**_\n>\n> If you are planning to experiment with your contract on `devnet`, make sure to run `clarinet devnet start` [to deploy and test your contract locally](/stacks/clarinet/guides/run-a-local-devnet). You can then use the `devnet` network when calling your contract in the [Leather wallet](https://leather.io/install-extension).\n\n<HackBadge variant=\"advanced\" />\n\n**Message signature**: To further enhance the security and authenticity of your app, try to implemement a _login_ feature using [message signing](/stacks/connect/guides/sign-messages).\n\n```tsx\nimport { openSignatureRequestPopup } from \"@stacks/connect\"\nimport { verifyMessageSignatureRsv } from \"@stacks/encryption\"\nimport { StacksMocknet } from \"@stacks/network\"\nimport { getAddressFromPublicKey } from \"@stacks/transactions\"\n\nconst message = \"Log in to chatroom\"\nconst network = new StacksMocknet()\n\nopenSignatureRequestPopup({\n  message,\n  network,\n  onFinish: async ({ publicKey, signature }) => {\n    const verified = verifyMessageSignatureRsv({\n      message,\n      publicKey,\n      signature\n    })\n    if (verified) {\n      // The signature is verified, so now we can check if the user is a keyholder\n      const address = getAddressFromPublicKey(publicKey, network.version)\n      const isKeyHolder = await checkIsKeyHolder(address)\n      if (isKeyHolder) {\n        // The user is a keyholder, so they are authorized to access the chatroom\n      }\n    }\n  }\n})\n```\n\nThe signed message will serve as a _proof of identity_ - similar to a login, verifying that the user is indeed who they claim to be. This can be particularly useful in a chatroom setting, where only `is-keyholder` users are allowed to send messages.\n"
  },
  {
    "title": "Create a recipe for the Hiro Cookbook",
    "description": "Create your own recipe for the Hiro Cookbook and share it with the community.",
    "slug": "/stacks/hacks/recipes",
    "content": "\n## February: Create your own recipe for the Hiro Cookbook\n\n*Create your own recipe that you think will help other developers build on Stacks*\n\n**Timeline**: February 19-25, 2025\n\nThis month's challenge invites you to create your own recipe for the [Hiro Cookbook](/cookbook) and share it with the community. Each recipe is a reusable code snippet that handles some specific function, and each recipe has written annotations, so readers know exactly how the code in a given recipe works and what parameters you can customize. Your submission should be a recipe that you think will help other developers build on Stacks.\n\nSubmit your project [here](https://hirohacks25.paperform.co/).\n\n<iframe width=\"770\" height=\"315\" src=\"https://www.youtube.com/embed/z9ULVhygKCE\" title=\"Hiro Hacks: Cookbook\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerPolicy=\"strict-origin-when-cross-origin\" allowFullScreen></iframe>\n\n## Some example recipe ideas to explore\n\n- Using the `Cl` parse helper function to convert string values into Clarity Values\n- Creating and signing a message for smart contract verification\n- How to construct a non-sequential multisig transaction\n- Create a helper function to determine if a transaction has been signed\n\n_For this month's submission, provide a link to your recipe in a PR to the [Recipes](https://github.com/hirosystems/recipes) repo. To review the general submission guidelines, see the [Hiro Hacks](/stacks/hacks) page._\n\n---\n\n## Resources\n\n- [Hiro Cookbook](/cookbook)\n- [Recipes repo](https://github.com/hirosystems/recipes)\n- [Submission form](https://hirohacks25.paperform.co/)\n- [Stacks Discord](https://stacks.chat)\n"
  },
  {
    "title": "Overview",
    "description": "A series of coding challenges to sharpen your skills.",
    "slug": "/stacks/hacks/index",
    "content": "\nimport { Code } from 'lucide-react';\nimport { SecondaryCard } from '@/components/card';\n\nHiro Hacks are monthly hackathons designed to bring together the most innovative builders in the Stacks ecosystem. Each month features a unique theme, challenging you to stretch your creativity, show off your skills, and learn from other devs in the process.\n\nHave fun. Build something new. Compete against other devs for Hiro swag and your seat in a [hacker house](#prizes) coming later this year.\n\nTo submit your projects each month, [complete this form](https://hirohacks25.paperform.co/) before midnight ET on the last day of that month's hack.\n\n## Schedule\n\n| Week | Theme | Description |\n| --- | --- | --- |\n| Jan 22-28 | [AI x Stacks](/stacks/hacks/archive/ai) | Build something that combines AI capabilities with Stacks. |\n| Feb 19-25 | [Create your own recipe](/stacks/hacks/recipes) | Create your own recipe for the Hiro Cookbook and share it with the community. |\n| Mar 19-25 | TBA | Coming soon |\n| Apr 23-29 | TBA | Coming soon |\n| May 21-27 | TBA | Coming soon |\n| Jun 18-24 | TBA | Coming soon |\n| ??? | ??? | ??? |\n\n## Prizes\n\nAt the end of each monthly hack, Hiro will host a livestream on X going over submissions and announcing that month's winning developer. The prize? Fame, glory and Hiro swag.\n\nTop developers from these monthly hacks will be invited to participate in a Hiro hacker house tied to one of the year's biggest conferences, key expenses covered. We'll share more details on that house soon, so stay tuned.\n\n## Resources\n\nNeed help hacking on your project? [Join the Stacks Discord](https://stacks.chat) and get help from other devs in the #builder-general channel. If you're having problems using Hiro tools, you can also reach out to our team in the relevant tool channel in the Hiro Developer Tools section.\n\nAnd don't forget to take advantage of all of the resources in our docs as well as [Stacks docs](https://docs.stacks.co/).\n\n## Rules\n\nTo be eligible for swag and the hacker house, you must submit your project through [this paperform](https://hirohacks25.paperform.co/) before midnight ET on the last day of that month's hack.\n\nIn that submission, we expect to see:\n\n- A link to your project (if applicable)\n- A link to your code with a clear README (or link to a PR if submitting a recipe)\n- A description that covers the problem being solved, the technical approach, and future improvements for the project\n\nIn terms of selecting winners, submissions will be evaluated on their technical implementation, their innovation/creativity, and their documentation/presentation. To learn more about the rules, read [Hiro Hacks Terms & Conditions](https://www.hiro.so/hiro-hacks-rules).\n"
  },
  {
    "title": "Overview",
    "description": "Explore and verify data on the Stacks blockchain.",
    "slug": "/stacks/explorer/index",
    "content": "\nimport Link from \"next/link\";\nimport { Button } from \"@/components/ui/button\"\n\nThe Stacks Explorer lets you explore on-chain data, troubleshoot pending transactions, edit and deploy contracts via the sandbox, discover new tokens, and more. We maintain and support the [Stacks Explorer](https://explorer.hiro.so) as a service for the community, but you can also run your own instance of the explorer.\n\n<div className=\"flex gap-4\">\n  <Button className=\"bg-orange-500 hover:bg-orange-600\">\n    <a href=\"https://explorer.hiro.so\" target=\"_blank\" className=\"no-underline\">\n      View Stacks Explorer\n    </a>\n  </Button>\n  {/* <Button variant=\"outline\">\n    <Link\n      href=\"/stacks/explorer/guides/build-explorer\"\n      className=\"no-underline\"\n    >\n      Set up your own explorer\n    </Link>\n  </Button> */}\n</div>\n\n## Related tools\n\n- **[Stacks Blockchain API](/stacks/api)**: Looking for on-chain data without the front end? Leverage the Stacks Blockchain API.\n- **[Ordinals Explorer](/bitcoin/explorer)**: Explore Bitcoin Ordinals and BRC-20 tokens via the Ordinals Explorer.\n\n---\n\nNeed help building with Stacks Explorer? Reach out to us on the `#stacks-explorer` channel on Discord under the [Hiro Developer Tools section](https://stacks.chat/). There’s also a [weekly office hours](https://events.stacks.co/event/HD16484710) on Discord every Thursday at 11am ET.\n"
  },
  {
    "title": "Build a Stacks Explorer",
    "description": "Run a local instance of the Stacks Explorer.",
    "slug": "/stacks/explorer/guides/build-explorer",
    "content": "\nThe Stacks Explorer frontend user interface is built with [React](https://reactjs.org/), [next.js](https://github.com/vercel/next.js) and [@stacks/ui](https://github.com/hirosystems/ui).\n\nBefore you can run the explorer on your machine locally, you must first clone the [Stacks Explorer](https://github.com/hirosystems/explorer) repository to obtain all of the necessary files and libraries needed.\n\n# Project dependencies\n\nOnce you have cloned the Stacks Explorer repositories, you will need to install the following project dependencies:\n\n- [NodeJS](https://nodejs.dev/en/) that includes `npm`\n- [PNPM](https://pnpm.io/installation/)\n- [Homebrew](https://brew.sh/)\n\n> **_NOTE:_**\n>\n> Although Homebrew is not required to install and operate the Stacks Explorer, it is highly recommended.\n\nOpen your terminal window, and make sure you are in the `/explorer` folder. Run the below command to install the dependencies:\n\n`pnpm i`\n\nAfter installing and configuring your environment, you can run the Stacks Explorer locally if you wish by running the following command:\n\n`pnpm dev`\n\n## Building for production\n\nYou may also build a production version of the Stacks Explorer. To do that, simply run the following command:\n\n`pnpm build`\n\n> **NOTE:**\n>\n> Running `pnpm build` also run the default next.js build task.\n"
  },
  {
    "title": "Bit manipulation",
    "description": "Using bit manipulation for compact data storage and flags in Clarity smart contracts.",
    "slug": "/stacks/clarity/bit-manipulation",
    "content": "\nBit manipulation functions in Clarity provide powerful tools for efficient data storage and flag management in smart contracts. These functions allow developers to pack multiple pieces of information into a single integer, saving storage space and potentially reducing gas costs.\n\n## Why these functions matter\n\nClarity's bit manipulation functions are designed with several important considerations in mind:\n\n1. Efficiency: They allow for compact data storage, potentially reducing contract storage costs.\n2. Versatility: These functions enable the implementation of bitfields, flags, and other low-level data structures.\n3. Performance: Bit operations are generally faster than higher-level data manipulations.\n4. Interoperability: They facilitate working with data from other systems that use bitwise representations.\n\n## Core Bit Manipulation Functions\n\n### 1. bit-and\n\n**What**: Performs a bitwise AND operation on two or more integers.\n**Why**: Useful for checking if specific bits are set or for clearing certain bits.\n**When**: Use when you need to isolate specific bits or apply a bitmask.\n**How**: \n```clarity\n(bit-and i1 i2...)\n```\n\n**Best Practices**: \n- Use to check if a specific flag is set in a bitfield.\n- Combine with bit-or for more complex flag manipulations.\n\n**Example Use Case**: Checking if a user has a specific permission in a compact permission system.\n\n```clarity\n(define-constant PERMISSION_READ u1)  ;; 0001\n(define-constant PERMISSION_WRITE u2) ;; 0010\n(define-constant PERMISSION_EXEC u4)  ;; 0100\n\n(define-public (has-permission? (user-permissions uint) (required-permission uint))\n  (is-eq (bit-and user-permissions required-permission) required-permission))\n\n;; Usage\n(has-permission? u3 PERMISSION_READ)  ;; Returns true (3 & 1 == 1)\n(has-permission? u3 PERMISSION_EXEC)  ;; Returns false (3 & 4 == 0)\n```\n\n### 2. bit-or\n\n**What**: Performs a bitwise OR operation on two or more integers.\n**Why**: Useful for setting specific bits or combining flags.\n**When**: Use when you need to add flags or set specific bits.\n**How**: \n```clarity\n(bit-or i1 i2...)\n```\n\n**Best Practices**: \n- Use to add new permissions or flags to an existing set.\n- Combine with bit-and for more complex flag manipulations.\n\n**Example Use Case**: Adding a new permission to a user's existing permissions.\n\n```clarity\n(define-public (add-permission (current-permissions uint) (new-permission uint))\n  (ok (bit-or current-permissions new-permission)))\n\n;; Usage\n(add-permission u3 PERMISSION_EXEC)  ;; Returns (ok u7)\n```\n\n### 3. bit-not\n\n**What**: Performs a bitwise NOT operation on an integer.\n**Why**: Useful for inverting all bits in a value.\n**When**: Use when you need to flip all bits or create a bitmask.\n**How**: \n```clarity\n(bit-not i1)\n```\n\n**Best Practices**: \n- Use carefully with signed integers, as it affects the sign bit.\n- Combine with bit-and to clear specific bits.\n\n**Example Use Case**: Creating a bitmask to clear specific permissions.\n\n```clarity\n(define-public (remove-permission (current-permissions uint) (permission-to-remove uint))\n  (ok (bit-and current-permissions (bit-not permission-to-remove))))\n\n;; Usage\n(remove-permission u7 PERMISSION_WRITE)  ;; Returns (ok u5)\n```\n\n## Practical Example: Compact User Profile Flags\n\nLet's implement a system that stores multiple user profile settings in a single integer using bit flags:\n\n```clarity\n(define-constant SETTING_NEWSLETTER u1)    ;; 0001\n(define-constant SETTING_2FA u2)           ;; 0010\n(define-constant SETTING_PRIVATE_PROFILE u4) ;; 0100\n(define-constant SETTING_DARK_MODE u8)     ;; 1000\n\n(define-map user-settings principal uint)\n\n(define-public (update-setting (setting uint) (enabled bool))\n  (let ((current-settings (default-to u0 (map-get? user-settings tx-sender))))\n    (if enabled\n        (map-set user-settings tx-sender (bit-or current-settings setting))\n        (map-set user-settings tx-sender (bit-and current-settings (bit-not setting))))\n    (ok true)))\n\n(define-read-only (has-setting? (user principal) (setting uint))\n  (let ((user-settings (default-to u0 (map-get? user-settings user))))\n    (is-eq (bit-and user-settings setting) setting)))\n\n(define-read-only (get-all-settings (user principal))\n  (default-to u0 (map-get? user-settings user)))\n```\n\nThis example demonstrates:\n1. Using bit constants to define individual settings.\n2. Updating settings using bit-or to set flags and bit-and with bit-not to clear flags.\n3. Checking individual settings with bit-and.\n4. Storing all user settings compactly in a single uint.\n\n## Conclusion\n\nBit manipulation functions in Clarity provide powerful tools for efficient data storage and flag management in smart contracts. By understanding when and how to use these functions, developers can create more storage-efficient contracts and implement complex flag systems with ease. Always consider the trade-off between storage efficiency and code readability when using these techniques.\n"
  },
  {
    "title": "Basic arithmetic",
    "description": "Brief overview of arithmetic operations in Clarity and their importance in smart contract development.",
    "slug": "/stacks/clarity/basic-arithmetic",
    "content": "\nSmart contracts often need to perform calculations, whether it's for token balances, voting weights, or complex financial operations. Understanding Clarity's arithmetic functions is crucial for implementing these features efficiently and securely.\n\n## Why these functions matter\nClarity's arithmetic functions are designed with blockchain-specific considerations in mind:\n\n1. Overflow protection: Unlike some languages, Clarity prevents integer overflow by default, enhancing contract security.\n2. Precision: Clarity uses 128-bit integers, allowing for high-precision calculations crucial in financial applications.\n3. Determinism: The behavior of these functions is consistent across all nodes, ensuring blockchain consensus.\n\n## Core functions\n\n### 1. Addition (+)\n\n**What**: Adds two or more integers.\n\n**Why**: Essential for calculations involving cumulative values.\n\n**When**: Use when you need to increase values, combine quantities, or perform any additive calculation.\n\n**Best practices**: \n- Consider overflow protection\n- Use with uint for non-negative values like token amounts\n\n**Example use case**: Calculating total rewards in a stacking system.\n\n```clarity\n(define-map StackingRewards principal uint)\n\n(define-public (add-stacking-reward (stacker principal) (newReward uint))\n  (let\n    (\n      (currentRewards (default-to u0 (map-get? StackingRewards stacker)))\n    )\n    (map-set StackingRewards stacker (+ currentRewards newReward))\n    (ok true)\n  )\n)\n```\n\n### 2. Subtraction (-)\n\n**What**: Subtracts integers from the first argument.\n\n**Why**: Crucial for calculations involving decreasing values or finding differences.\n\n**When**: Use when you need to decrease values, calculate differences, or perform any subtractive operation.\n\n**Best practices**: \n- Guard against underflow\n- Consider using uint for values that shouldn't go negative\n\n**Example use case**: Updating user points in a rewards system.\n\n```clarity\n(define-map UserPoints principal uint)\n\n(define-public (deduct-points (amount uint))\n  (let\n    (\n      (currentPoints (default-to u0 (map-get? UserPoints tx-sender)))\n    )\n    (asserts! (>= currentPoints amount) (err u1))\n    (map-set UserPoints tx-sender (- currentPoints amount))\n    (ok true)\n  )\n)\n\n(define-read-only (get-points (user principal))\n  (default-to u0 (map-get? UserPoints user))\n)\n```\n\n### 3. Multiplication (*)\n\n**What**: Multiplies two or more integers.\n\n**Why**: Important for calculations involving scaling, rates, or proportions.\n\n**When**: Use when you need to scale values, calculate rates, or perform any multiplicative operation.\n\n**Best practices**: \n- Consider overflow protection\n- Use with uint for non-negative values like token amounts\n\n**Example use case**: Calculating rewards based on stacking amount and duration.\n\n```clarity\n(define-public (calculate-rewards (amount uint) (days uint))\n  (let\n    (\n      (rewardRate u10) ;; 10 tokens per day per 1000 stacked\n      (rewards (* amount days rewardRate))\n    )\n    (ok (/ rewards u1000))\n  )\n)\n```\n\n### 4. Division (/)\n\n**What**: Performs integer division.\n\n**Why**: Crucial for calculations involving rates, proportions, or sharing.\n\n**When**: Use when you need to divide values, calculate rates, or perform any division operation.\n\n**Best practices**: \n- Guard against division by zero\n- Consider using uint for non-negative values like token amounts\n\n**Example use case**: Calculating price per item when buying in bulk.\n\n```clarity\n(define-read-only (calculate-price-per-item (totalPrice uint) (itemCount uint))\n  (if (> itemCount u0)\n    (ok (/ totalPrice itemCount))\n    (err u0)\n  )\n)\n```\n\n## Best practices and considerations\n\n1. **Order of operations**: Clarity doesn't have operator precedence. Use parentheses to explicitly define the order of operations.\n\n2. **Handling remainders**: When using division, consider how to handle remainders. You might need to use combination of division and modulo.\n\n3. **Scaling for precision**: When dealing with percentages or fractions, consider scaling up your numbers to maintain precision.\n\n4. **Guarding against division by zero**: Always check for zero before performing division to avoid runtime errors.\n\n5. **Using uint vs int**: Choose `uint` for values that can't be negative (like token amounts) and `int` when negative values are possible.\n\n## Practical example: simple interest calculator\n\nLet's combine these functions to create a simple interest calculator:\n\n```clarity\n(define-public (calculate-interest (principal uint) (rate uint) (time uint))\n  (let (\n    (scaled-rate (/ rate u100))  ;; Convert percentage to decimal\n    (interest (/ (* principal scaled-rate time) u365))  ;; Simple interest formula\n  )\n  (ok interest))\n)\n\n;; Usage: calculate interest for 1000 tokens at 5% APR for 30 days\n(calculate-interest u1000 u5 u30)\n```\n\nThis example demonstrates how to combine multiple arithmetic operations while handling precision (scaling the rate) and using integer division appropriately.\n\n## Conclusion\n\nMastering Clarity's arithmetic functions is essential for building robust smart contracts. By understanding these operations and their nuances, you can implement complex financial logic, manage token economics, and create secure, efficient blockchain applications.\n"
  },
  {
    "title": "Introduction",
    "description": "Explore and master Clarity's built-in functions for smart contract development.",
    "slug": "/stacks/clarity/index",
    "content": "\nimport { Code } from 'lucide-react';\nimport { SecondaryCard } from '@/components/card';\n\n<Callout title=\"New series\" type=\"info\">\nWe're introducing a new series of guides that explore Clarity functions in depth, focusing on their practical applications in blockchain development.\n</Callout>\n\nEach page in this section covers one or more related Clarity functions, explaining their purpose, demonstrating implementation with code samples, and discussing best practices. Ready to enhance your Clarity smart contract development skills?\n\n## Explore guides\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/clarity/basic-arithmetic\"\n    title=\"Arithmetic operations\"\n    description=\"Master basic and advanced arithmetic functions for precise calculations in smart contracts.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/clarity/access-control\"\n    title=\"Access control\"\n    description=\"Manage permissions and control access for smart contracts.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/clarity/handling-optionals-and-errors\"\n    title=\"Handling optionals and errors\"\n    description=\"Safely handling optional values and error cases in Clarity smart contracts.\"\n  />\n</Cards>\n\nNeed help or have questions? Join the discussion in the [#clarity channel](https://stacks.chat) on Discord and connect with other Clarity developers.\n"
  },
  {
    "title": "Map functions",
    "description": "Optimizing storage and retrieval with map functions in Clarity.",
    "slug": "/stacks/clarity/optimizations",
    "content": "\nMap functions in Clarity provide powerful tools for efficient data storage and retrieval in smart contracts. These functions allow developers to create key-value stores that can be used to maintain complex state in a gas-efficient manner.\n\n## Why these functions matter\n\nClarity's map functions are designed with blockchain-specific considerations in mind:\n\n1. Efficiency: Maps provide O(1) lookup time, making them ideal for storing and retrieving data in smart contracts.\n2. Flexibility: They allow for complex data structures to be stored and accessed easily.\n3. Gas Optimization: Using maps can significantly reduce gas costs compared to other data storage methods.\n4. State Management: Maps are crucial for maintaining contract state across multiple transactions.\n5. Scalability: They enable contracts to handle large amounts of data without significant performance degradation.\n\n## Core Map Functions\n\n### 1. define-map\n\n**What**: Defines a new map with a specified key and value type.\n**Why**: Essential for creating structured data storage in your contract.\n**When**: Use when you need to store and retrieve data associated with unique keys.\n**How**: \n```clarity\n(define-map map-name {key-type} {value-type})\n```\n\n**Best Practices**: \n- Choose appropriate key and value types to represent your data efficiently.\n- Consider using composite keys (tuples) for more complex data relationships.\n\n**Example Use Case**: Creating a user balance tracker.\n\n```clarity\n(define-map user-balances principal uint)\n```\n\n### 2. map-set\n\n**What**: Sets the value for a given key in the map.\n**Why**: Allows updating or inserting data into the map.\n**When**: Use when you need to store or update a value associated with a key.\n**How**: \n```clarity\n(map-set map-name key value)\n```\n\n**Best Practices**: \n- Always check if the key exists before updating to avoid unintended overwrites.\n- Use in conjunction with appropriate access controls.\n\n**Example Use Case**: Updating a user's balance.\n\n```clarity\n(define-public (update-balance (user principal) (new-balance uint))\n  (begin\n    (asserts! (is-eq tx-sender user) (err u1))\n    (ok (map-set user-balances user new-balance))))\n```\n\n### 3. map-get?\n\n**What**: Retrieves the value associated with a given key in the map.\n**Why**: Allows reading data from the map efficiently.\n**When**: Use when you need to retrieve stored data based on a key.\n**How**: \n```clarity\n(map-get? map-name key)\n```\n\n**Best Practices**: \n- Always handle the case where the key might not exist (returns none).\n- Use `unwrap!` or `unwrap-panic` when you're certain the key exists.\n\n**Example Use Case**: Retrieving a user's balance.\n\n```clarity\n(define-read-only (get-balance (user principal))\n  (default-to u0 (map-get? user-balances user)))\n```\n\n### 4. map-delete\n\n**What**: Removes the entry for a given key from the map.\n**Why**: Allows removing data from the map when it's no longer needed.\n**When**: Use when you need to delete stored data associated with a key.\n**How**: \n```clarity\n(map-delete map-name key)\n```\n\n**Best Practices**: \n- Be cautious when deleting data, as it can't be recovered once deleted.\n- Consider using a \"soft delete\" approach for data that might need to be referenced later.\n\n**Example Use Case**: Removing a user's account.\n\n```clarity\n(define-public (delete-account (user principal))\n  (begin\n    (asserts! (is-eq tx-sender user) (err u1))\n    (ok (map-delete user-balances user))))\n```\n\n## Practical Example: Simple Voting System\n\nLet's implement a basic voting system using map functions to demonstrate their practical use:\n\n```clarity\n;; Define maps for votes and voter registration\n(define-map votes { proposal: uint } { yes: uint, no: uint })\n(define-map voters principal bool)\n\n;; Function to register a voter\n(define-public (register-voter)\n  (ok (map-set voters tx-sender true)))\n\n;; Function to cast a vote\n(define-public (cast-vote (proposal uint) (vote bool))\n  (let ((proposal-votes (default-to { yes: u0, no: u0 } (map-get? votes { proposal: proposal }))))\n    (asserts! (is-some (map-get? voters tx-sender)) (err u1))\n    (asserts! (is-none (map-get? votes { proposal: proposal })) (err u2))\n    (if vote\n        (map-set votes { proposal: proposal } \n          (merge proposal-votes { yes: (+ (get yes proposal-votes) u1) }))\n        (map-set votes { proposal: proposal } \n          (merge proposal-votes { no: (+ (get no proposal-votes) u1) })))\n    (ok true)))\n\n;; Function to get vote count\n(define-read-only (get-votes (proposal uint))\n  (default-to { yes: u0, no: u0 } (map-get? votes { proposal: proposal })))\n```\n\nThis example demonstrates:\n1. Using `define-map` to create data structures for votes and voter registration.\n2. Using `map-set` to register voters and record votes.\n3. Using `map-get?` to check voter registration and retrieve vote counts.\n4. Combining map functions with other Clarity features for a complete voting system.\n\n## Conclusion\n\nMap functions in Clarity provide a powerful and efficient way to store and retrieve data in smart contracts. By understanding when and how to use these functions, developers can create more efficient, scalable, and gas-optimized contracts. Always consider the specific requirements of your application when designing your data storage strategy using map functions.\n"
  },
  {
    "title": "Cryptographic functions",
    "description": "Brief overview of cryptographic functions in Clarity and their importance in smart contract development.",
    "slug": "/stacks/clarity/cryptographic-functions",
    "content": "\nCryptographic functions are essential in blockchain smart contracts for ensuring data integrity, creating secure hashes, and verifying signatures. Clarity provides several built-in cryptographic functions that are crucial for these purposes.\n\n## Why these functions matter\n\nClarity's cryptographic functions are designed with blockchain-specific considerations in mind:\n\n1. Security: These functions provide cryptographic primitives essential for building secure smart contracts.\n2. Data Integrity: They allow for the creation and verification of unique identifiers for data, ensuring data hasn't been tampered with.\n3. Authentication: Cryptographic functions enable signature verification, crucial for authenticating transactions and messages.\n4. Determinism: The behavior of these functions is consistent across all nodes, ensuring blockchain consensus.\n5. Interoperability: Some functions (like keccak256) provide compatibility with other blockchain systems.\n\n## Core Cryptographic Functions\n\n### 1. sha256\n\n**What**: Computes the SHA256 hash of the input.\n**Why**: SHA256 is widely used for creating unique, fixed-size representations of data, crucial for data integrity checks.\n**When**: Use when you need to create a unique identifier for data or verify data integrity.\n**How**: \n```clarity\n(sha256 value)\n```\n**Best Practices**: \n- Use for creating unique identifiers for data\n- Combine with other data before hashing to prevent rainbow table attacks\n\n**Example Use Case**: Creating a unique identifier for a document or transaction.\n\n```clarity\n(define-public (submit-document-hash (document-hash (buff 32)))\n  (let ((user-submission-id (sha256 (concat document-hash tx-sender))))\n    (map-set document-submissions user-submission-id true)\n    (ok user-submission-id)))\n```\n\n### 2. keccak256\n\n**What**: Computes the Keccak256 hash of the input.\n**Why**: Keccak256 is another cryptographic hash function, often used in Ethereum-compatible systems.\n**When**: Use when interoperability with Ethereum systems is needed or when an alternative to SHA256 is required.\n**How**: \n```clarity\n(keccak256 value)\n```\n**Best Practices**: \n- Use when SHA256 is not suitable for your specific use case\n- Be aware of the differences in output compared to SHA256\n\n**Example Use Case**: Creating a hash for Ethereum address compatibility.\n\n```clarity\n(define-read-only (get-eth-address (public-key (buff 33)))\n  (let ((hashed-key (keccak256 (unwrap-panic (secp256k1-recover? message-hash signature public-key)))))\n    (buff-to-hex-string (unwrap-panic (slice? hashed-key u12 u32)))))\n```\n\n### 3. secp256k1-recover?\n\n**What**: Recovers the public key from a signed message and signature.\n**Why**: Essential for verifying signatures without needing the public key in advance.\n**When**: Use when implementing signature verification schemes, especially for transactions or messages.\n**How**: \n```clarity\n(secp256k1-recover? message-hash signature)\n```\n**Best Practices**: \n- Always check the return value as it's an optional type\n- Use in combination with `secp256k1-verify` for complete signature verification\n\n**Example Use Case**: Verifying a signed message in a decentralized voting system.\n\n```clarity\n(define-public (submit-vote (vote uint) (signature (buff 65)) (message-hash (buff 32)))\n  (let ((signer (unwrap! (secp256k1-recover? message-hash signature) (err u1))))\n    (asserts! (is-eq (principal-of? signer) (some tx-sender)) (err u2))\n    (map-set votes tx-sender vote)\n    (ok true)))\n\n## Practical Example: Document Verification System\n\nLet's implement a basic document verification system that demonstrates the use of Clarity's cryptographic functions. This system will allow users to submit document hashes, sign them, and later verify the authenticity of the document and the signer.\n\n```clarity\n;; Define a map to store document hashes and their signers\n(define-map documents\n  { doc-hash: (buff 32) }\n  { signer: principal, eth-compatible-hash: (buff 32) })\n\n;; Function to submit a document hash\n(define-public (submit-document (doc-hash (buff 32)))\n  (let\n    (\n      (submission-id (sha256 (concat doc-hash tx-sender)))\n      (eth-hash (keccak256 doc-hash))\n    )\n    (map-set documents { doc-hash: submission-id }\n                       { signer: tx-sender, eth-compatible-hash: eth-hash })\n    (ok submission-id)))\n\n;; Function to sign a document hash\n(define-public (sign-document (doc-hash (buff 32)) (signature (buff 65)))\n  (let\n    ((submission-id (sha256 (concat doc-hash tx-sender))))\n    (match (map-get? documents { doc-hash: submission-id })\n      doc-info\n        (let\n          ((signer (unwrap! (secp256k1-recover? doc-hash signature) (err u1))))\n          (asserts! (is-eq (principal-of? signer) (some tx-sender)) (err u2))\n          (ok true))\n      (err u3))))\n\n;; Function to verify a document and its signer\n(define-read-only (verify-document (doc-hash (buff 32)) (signature (buff 65)))\n  (let\n    ((submission-id (sha256 (concat doc-hash tx-sender))))\n    (match (map-get? documents { doc-hash: submission-id })\n      doc-info\n        (let\n          ((signer (unwrap! (secp256k1-recover? doc-hash signature) (err u1))))\n          (if (is-eq (some (get signer doc-info)) (principal-of? signer))\n              (ok true)\n              (err u2)))\n      (err u3))))\n\n;; Function to get Ethereum-compatible hash\n(define-read-only (get-eth-hash (doc-hash (buff 32)))\n  (match (map-get? documents { doc-hash: doc-hash })\n    doc-info (ok (get eth-compatible-hash doc-info))\n    (err u1)))\n```\n\n## Conclusion\n\nCryptographic functions in Clarity provide powerful tools for ensuring data integrity and implementing secure signature schemes. By understanding when and how to use these functions, developers can create robust smart contracts that maintain the security and trustlessness essential to blockchain applications. Always consider the specific security requirements of your application when choosing and implementing these cryptographic functions."
  },
  {
    "title": "Access control",
    "description": "Manage permissions and access control with principal functions.",
    "slug": "/stacks/clarity/access-control",
    "content": "\nPrincipal functions in Clarity are essential tools for implementing robust access control and permission management in smart contracts. These functions allow you to identify, authenticate, and authorize different entities interacting with the contract, ensuring that only the right parties can perform specific actions or access certain data.\n\n## Why these functions matter\n\nClarity's principal functions are designed with blockchain-specific considerations in mind. They can:\n\n1. Identify and authenticate users and contracts interacting with your smart contract.\n2. Implement role-based access control for different contract functions.\n3. Ensure that only authorized entities can perform certain actions or access specific data.\n4. Create multi-signature schemes for enhanced security.\n\n## Key elements for access control\n\n### 1. asserts!\n\n**What**: A function that checks a condition and throws an error if it's not met.\n\n**Why**: Essential for enforcing access control rules and validating conditions.\n\n**When**: Use when you need to ensure a condition is true before proceeding with a function.\n\n**Best practices**: \n- Use `asserts!` to enforce access control rules and validate conditions.\n- Consider using `asserts!` in combination with other principal functions for robust access control.\n\n**Example use case**: Using `asserts!` to check if a user has sufficient balance before performing a transfer.\n\n```clarity\n;; Define a map to store user balances\n(define-map Balances principal uint)\n\n;; Function to transfer tokens\n(define-public (transfer (amount uint) (recipient principal))\n  (let\n    (\n      (senderBalance (default-to u0 (map-get? Balances tx-sender)))\n    )\n    ;; Assert that the sender has sufficient balance\n    (asserts! (>= senderBalance amount) (err u1))\n    \n    ;; If assertion passes, proceed with the transfer\n    (map-set Balances tx-sender (- senderBalance amount))\n    (map-set Balances recipient (+ (default-to u0 (map-get? Balances recipient)) amount))\n    (ok true)\n  )\n)\n\n;; Function to check balance\n(define-read-only (get-balance (user principal))\n  (default-to u0 (map-get? Balances user))\n)\n```\n\n### 2. tx-sender\n\n**What**: A keyword that represents the current transaction sender.\n\n**Why**: Important for identifying who is calling a contract function.\n\n**When**: Use when you need to check permissions or record actions associated with the caller.\n\n**Best practices**: \n- Always validate `tx-sender` before performing sensitive operations.\n- Don't rely solely on `tx-sender` for complex authentication schemes.\n\n**Example use case**: Restricting a function to be called only by the contract owner.\n\n```clarity\n(define-data-var contractOwner principal tx-sender)\n\n(define-public (restricted-function)\n  (begin\n    (asserts! (is-eq tx-sender (var-get contractOwner)) (err u1))\n    ;; Function logic here\n    (ok true)\n  )\n)\n```\n\n### 3. contract-caller\n\n**What**: A keyword that represents the immediate caller of the current contract.\n\n**Why**: Allows for more granular control in contract-to-contract interactions.\n\n**When**: Use when your contract might be called by other contracts and you need to distinguish between the original sender and the immediate caller.\n\n**Best practices**: \n- Use in conjunction with `tx-sender` for comprehensive access control.\n- Be cautious of potential confusion between `tx-sender` and `contract-caller` in complex call chains.\n\n**Example use case**: Implementing a whitelist for contracts allowed to call a function.\n\n```clarity\n(define-map AllowedCallers principal bool)\n\n(define-public (whitelisted-function)\n  (begin\n    (asserts! (default-to false (map-get? AllowedCallers contract-caller)) (err u2))\n    ;; Function logic here\n    (ok true)\n  )\n)\n```\n\n### 4. is-eq\n\n**What**: Checks if two values are equal.\n\n**Why**: Crucial for comparing principals and implementing access control logic.\n\n**When**: Use when you need to verify if a caller matches a specific principal or if two principals are the same.\n\n**Best practices**: \n- Use for exact matching of principals.\n- Consider using in combination with other checks for more robust authentication.\n\n**Example use case**: Multi-signature functionality requiring approval from specific principals.\n\n```clarity\n(define-constant APPROVER_ONE 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5)\n(define-constant APPROVER_TWO 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG)\n  \n(define-public (approve-transaction (transactionId uint))\n  (begin\n    (asserts! (or (is-eq tx-sender APPROVER_ONE) (is-eq tx-sender APPROVER_TWO)) (err u3))\n    ;; Approval logic here\n    (ok true)\n  )\n)\n```\n\n## Practical example: simple governance contract\n\nLet's implement a basic governance contract that demonstrates role-based access control using principal functions. This contract will have an owner, administrators, and regular members, each with different permissions.\n\n```clarity\n;; Define maps to store roles\n(define-map Administrators principal bool)\n(define-map Members principal bool)\n\n;; Define data variables\n(define-data-var contractOwner principal tx-sender)\n(define-data-var proposalCounter uint u0)\n\n;; Define a map to store proposals\n(define-map Proposals\n  uint\n  {\n    title: (string-ascii 50),\n    proposer: principal,\n    votesFor: uint,\n    votesAgainst: uint\n  }\n)\n\n;; Function to add an administrator (only owner can do this)\n(define-public (add-administrator (newAdmin principal))\n  (begin\n    (asserts! (is-eq tx-sender (var-get contractOwner)) (err u1))\n    (ok (map-set Administrators newAdmin true))\n  )\n)\n\n;; Function to add a member (only Administrators can do this)\n(define-public (add-member (newMember principal))\n  (begin\n    (asserts! (default-to false (map-get? Administrators contract-caller)) (err u2))\n    (ok (map-set Members newMember true))\n  )\n)\n\n;; Function to create a proposal (only members can do this)\n(define-public (create-proposal (title (string-ascii 50)))\n  (let\n    (\n      (proposalId (var-get proposalCounter))\n    )\n    (asserts! (default-to false (map-get? Members tx-sender)) (err u3))\n    (map-set Proposals proposalId\n      {\n        title: title,\n        proposer: tx-sender,\n        votesFor: u0,\n        votesAgainst: u0\n      })\n    (var-set proposalCounter (+ proposalId u1))\n    (ok proposalId)\n  )\n)\n\n;; Function to vote on a proposal (only members can do this)\n(define-public (vote (proposalId uint) (voteFor bool))\n  (let\n    (\n      (proposal (unwrap! (map-get? Proposals proposalId) (err u4)))\n    )\n    (asserts! (default-to false (map-get? Members tx-sender)) (err u5))\n    (if voteFor\n      (map-set Proposals proposalId (merge proposal { votesFor: (+ (get votesFor proposal) u1) }))\n      (map-set Proposals proposalId (merge proposal { votesAgainst: (+ (get votesAgainst proposal) u1) }))\n    )\n    (ok true)\n  )\n)\n\n;; Function to transfer ownership (only current owner can do this)\n(define-public (transfer-ownership (newOwner principal))\n  (begin\n    (asserts! (is-eq tx-sender (var-get contractOwner)) (err u6))\n    (var-set contractOwner newOwner)\n    (ok true)\n  )\n)\n```\n\n## Conclusion\n\nPrincipal functions in Clarity provide powerful tools for implementing secure and flexible access control in smart contracts. By understanding when and how to use these functions, you can create robust permission systems, ensuring that only authorized entities can perform specific actions or access certain data. Always consider the specific security requirements of your application when implementing access control mechanisms using these principal functions.\n"
  },
  {
    "title": "list",
    "description": "Construct lists in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/list",
    "content": "\n## Function Signature\n\n```clarity\n(list expr1 expr2 expr3 ...)\n```\n\n- Input: `A, ...`\n- Output: `(list A)`\n\n## Why it matters\n\nThe `list` function is crucial for:\n\n1. Constructing lists of elements in Clarity.\n2. Enabling the use of lists for data storage and manipulation.\n3. Simplifying the creation of sequences of values.\n4. Facilitating operations on collections of data.\n\n## When to use it\n\nUse `list` when you need to:\n\n- Construct a list of elements.\n- Store and manipulate sequences of values.\n- Pass lists as arguments to functions.\n- Perform operations on collections of data.\n\n## Best Practices\n\n- Ensure all elements in the list are of the same type.\n- Use meaningful variable names for better readability.\n- Combine with other list functions for comprehensive list handling.\n- Be aware of the maximum length of lists in Clarity.\n\n## Practical Example: Creating a List of Integers\n\nLet's implement a function that creates a list of integers and returns its length:\n\n```clarity\n(define-read-only (create-list)\n  (let\n    (\n      (numbers (list 1 2 3 4 5))\n    )\n    (len numbers)\n  )\n)\n\n;; Usage\n(create-list) ;; Returns u5\n```\n\nThis example demonstrates:\n1. Using `list` to create a list of integers.\n2. Binding the list to a variable using `let`.\n3. Returning the length of the list using `len`.\n\n## Common Pitfalls\n\n1. Using `list` with elements of different types, causing type errors.\n2. Assuming the list will always be within a certain length, leading to unhandled cases.\n3. Not handling all possible conditions, resulting in incomplete list checks.\n4. Overlooking the need for comprehensive validation and error checking.\n\n## Related Functions\n\n- `len`: Returns the length of a list.\n- `append`: Adds an element to the end of a list.\n- `concat`: Concatenates multiple lists.\n\n## Conclusion\n\nThe `list` function is a fundamental tool for constructing lists in Clarity smart contracts. It allows you to create sequences of values, enabling robust and comprehensive list handling and manipulation. When used effectively, `list` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage collections of data.\n"
  },
  {
    "title": "tuple",
    "description": "Use tuples to group data values with named fields in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/tuple",
    "content": "\n## Type Definition\n\n```clarity\n{label-0: value-type-0, label-1: value-type-1, ...}\n```\n\n- Input: `various types`\n- Output: `tuple`\n\n## Why it matters\n\nThe `tuple` type is crucial for:\n\n1. Grouping related data values with named fields.\n2. Implementing complex data structures in smart contracts.\n3. Ensuring data integrity by providing a clear structure for related values.\n4. Simplifying the process of handling grouped data in smart contracts.\n\n## When to use it\n\nUse `tuple` when you need to:\n\n- Group related data values with named fields.\n- Implement complex data structures in your smart contract.\n- Ensure data integrity by providing a clear structure for related values.\n- Handle grouped data in your smart contract.\n\n## Best Practices\n\n- Use descriptive names for tuple fields for better readability.\n- Ensure the types of the tuple fields are appropriate for the data they represent.\n- Combine with other data types and functions for comprehensive data management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Using Tuples to Store User Information\n\nLet's implement a function that stores and retrieves user information using tuples:\n\n```clarity\n(define-map UserInfo { userId: principal } { name: (string-ascii 20), age: uint })\n\n(define-public (set-user-info (user principal) (name (string-ascii 20)) (age uint))\n  (begin\n    (map-set UserInfo { userId: user } { name: name, age: age })\n    (ok true)\n  )\n)\n\n(define-read-only (get-user-info (user principal))\n  (map-get? UserInfo { userId: user })\n)\n\n;; Usage\n(set-user-info tx-sender \"Alice\" u30) ;; Sets the user info\n(get-user-info tx-sender) ;; Returns (some { name: \"Alice\", age: u30 })\n```\n\nThis example demonstrates:\n1. Using tuples to store user information with named fields.\n2. Implementing functions to set and get user information using tuples.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using non-descriptive names for tuple fields, causing confusion.\n2. Assuming the tuple structure will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `map-set`: Sets a value in a map.\n- `map-get?`: Retrieves a value from a map.\n- `default-to`: Provides a default value if an optional is `none`.\n\n## Conclusion\n\nThe `tuple` type is a fundamental tool for grouping related data values with named fields in Clarity smart contracts. It allows you to implement complex data structures, ensuring data integrity and simplifying data management. When used effectively, `tuple` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle grouped data.\n"
  },
  {
    "title": "sha256",
    "description": "Compute the SHA-256 hash of a value in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/sha256",
    "content": "\n## Function Signature\n\n```clarity\n(sha256 value)\n```\n\n- Input: `buff | uint | int`\n- Output: `(buff 32)`\n\n## Why it matters\n\nThe `sha256` function is crucial for:\n\n1. Computing the SHA-256 hash of a given value.\n2. Implementing cryptographic operations in smart contracts.\n3. Ensuring data integrity by generating unique hashes.\n4. Simplifying the process of handling cryptographic hashing in smart contracts.\n\n## When to use it\n\nUse `sha256` when you need to:\n\n- Compute the SHA-256 hash of a given value.\n- Implement cryptographic operations in your smart contract.\n- Generate unique hashes to ensure data integrity.\n- Handle cryptographic hashing operations.\n\n## Best Practices\n\n- Ensure the input value is correctly formatted and valid.\n- Use meaningful variable names for better readability.\n- Combine with other cryptographic functions for comprehensive security management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Computing a SHA-256 Hash\n\nLet's implement a function that computes the SHA-256 hash of a given buffer:\n\n```clarity\n(define-read-only (compute-sha256 (input (buff 32)))\n  (sha256 input)\n)\n\n;; Usage\n(compute-sha256 0x68656c6c6f20776f726c64000000000000000000000000000000000000000000)\n;; Returns 0x28effae679c457da1e5158c063b3dfa78d0ade721b9aa9f1fc3f46dba4c0ea15\n```\n\nThis example demonstrates:\n1. Using `sha256` to compute the hash of a given buffer.\n2. Implementing a public function to handle the hash computation.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `sha256` with incorrectly formatted or invalid input values, causing the operation to fail.\n2. Assuming the hash will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete cryptographic hashing.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `sha512`: Computes the SHA-512 hash of the input.\n- `sha512/256`: Computes the SHA-512/256 hash of the input.\n- `keccak256`: Computes the KECCAK-256 hash of the input.\n\n## Conclusion\n\nThe `sha256` function is a fundamental tool for computing SHA-256 hashes in Clarity smart contracts. It allows you to implement cryptographic operations, ensuring data integrity and simplifying cryptographic hashing. When used effectively, `sha256` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle cryptographic hashing operations.\n"
  },
  {
    "title": "unwrap!",
    "description": "Unpack optional and response types in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/unwrap",
    "content": "\n## Function Signature\n\n```clarity\n(unwrap! option-input thrown-value)\n```\n\n- Input: `(optional A) | (response A B), C`\n- Output: `A`\n\n## Why it matters\n\nThe `unwrap!` function is crucial for:\n\n1. Unpacking optional and response types to access their inner values.\n2. Implementing logic that requires handling optional and response types.\n3. Ensuring data integrity by validating the unpacking process.\n4. Simplifying the process of handling optional and response types in smart contracts.\n\n## When to use it\n\nUse `unwrap!` when you need to:\n\n- Unpack optional and response types to access their inner values.\n- Implement logic that requires handling optional and response types.\n- Validate the unpacking process to ensure data integrity.\n- Handle optional and response types in your smart contract.\n\n## Best Practices\n\n- Ensure the input value is an optional or response type.\n- Use meaningful variable names for better readability.\n- Combine with other error handling functions for comprehensive error management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Unpacking an Optional Value\n\nLet's implement a function that retrieves a value from a map and unpacks it using `unwrap!`:\n\n```clarity\n(define-map UserInfo { userId: principal } { name: (string-ascii 20), age: uint })\n\n(define-public (get-user-age (user principal))\n  (let\n    (\n      (userData (unwrap! (map-get? UserInfo { userId: user }) (err \"User not found\")))\n    )\n    (ok (get age userData))\n  )\n)\n\n;; Usage\n(map-set UserInfo { userId: tx-sender } { name: \"Alice\", age: u30 })\n(get-user-age tx-sender) ;; Returns (ok u30)\n(get-user-age 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR) ;; Returns (err \"User not found\")\n```\n\nThis example demonstrates:\n1. Using `unwrap!` to unpack an optional value from a map.\n2. Implementing a public function to handle the unpacking process.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `unwrap!` with values that are not optional or response types, causing runtime errors.\n2. Assuming the unpacking will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete error management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `try!`: Unpacks optional and response types, returning `none` or the `err` value if unpacking fails.\n- `unwrap-panic`: Unpacks optional and response types, throwing a runtime error if unpacking fails.\n- `default-to`: Provides a default value if an optional is `none`.\n\n## Conclusion\n\nThe `unwrap!` function is a fundamental tool for unpacking optional and response types in Clarity smart contracts. It allows you to implement logic that requires handling optional and response types, ensuring data integrity and simplifying the unpacking process. When used effectively, `unwrap!` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle optional and response types.\n"
  },
  {
    "title": "contract-call?",
    "description": "Execute public functions in other smart contracts from within a Clarity smart contract.",
    "slug": "/stacks/clarity/functions/contract-call",
    "content": "\n## Function Signature\n\n```clarity\n(contract-call? .contract-name function-name arg0 arg1 ...)\n```\n\n- Input: \n  - `.contract-name`: The name of the contract to call\n  - `function-name`: The name of the public function to execute\n  - `arg0, arg1, ...`: Arguments to pass to the function\n- Output: `(response A B)` where A and B are the types returned by the called function\n\n## Why it matters\n\nThe `contract-call?` function is crucial for:\n\n1. Enabling inter-contract communication and composability.\n2. Allowing contracts to leverage functionality from other contracts.\n3. Building complex systems of interacting smart contracts.\n4. Implementing upgradeable contract patterns.\n\n## When to use it\n\nUse the `contract-call?` function when you need to:\n\n- Call a public function in another contract.\n- Interact with standardized contracts (e.g., token contracts).\n- Split complex logic across multiple contracts for better organization.\n- Implement upgradeable systems by calling into newer contract versions.\n\n## Best Practices\n\n- Always check the return value of `contract-call?` as it returns a response type.\n- Be aware that `contract-call?` cannot be used to call functions within the same contract.\n- Consider the gas costs of external contract calls in your overall transaction budget.\n- Use `as-contract` when appropriate to make calls with the contract's own principal.\n\n## Practical Example: Interacting with a Token Contract\n\nLet's implement a function that transfers tokens using a standard token contract:\n\n```clarity\n(define-public (transfer-tokens (amount uint) (recipient principal))\n  (contract-call? .token-contract transfer amount tx-sender recipient)\n)\n\n;; Usage\n(transfer-tokens u100 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM)\n```\n\nThis example demonstrates:\n1. Using `contract-call?` to interact with another contract (`.token-contract`).\n2. Passing arguments to the called function, including the current `tx-sender`.\n3. Returning the response from the called function directly.\n\n## Common Pitfalls\n\n1. Forgetting to handle the response from `contract-call?`, which can lead to unexpected behavior.\n2. Attempting to use `contract-call?` to call functions within the same contract, which is not allowed.\n3. Not considering the possibility of the called contract changing or being upgraded.\n\n## Related Functions\n\n- `as-contract`: Often used in combination with `contract-call?` to make calls as the contract principal.\n- `try!`: Useful for handling the response from `contract-call?` and propagating errors.\n- `unwrap!`: Can be used to extract the success value from a `contract-call?` response or return an error.\n\n## Conclusion\n\nThe `contract-call?` function is a fundamental building block for creating complex, interacting systems of smart contracts on the Stacks blockchain. By enabling contracts to call functions in other contracts, this function promotes code reuse, modularity, and upgradability. However, you must be careful to handle responses correctly and consider the implications of external calls on your contract's behavior and gas usage.\n"
  },
  {
    "title": "buff-to-int-be",
    "description": "Convert a byte buffer to a signed integer using big-endian encoding in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/buff-to-int-be",
    "content": "\n## Function Signature\n\n```clarity\n(buff-to-int-be (buff 16))\n```\n\n- Input: A byte buffer of up to 16 bytes\n- Output: A signed integer (`int`)\n\n## Why it matters\n\nThe `buff-to-int-be` function is crucial for:\n\n1. Converting byte data to signed integers in smart contracts.\n2. Handling data from external sources or other contracts that use big-endian encoding.\n3. Implementing protocols or algorithms that require big-endian integer representation.\n4. Interoperating with systems that use big-endian byte order.\n\n## When to use it\n\nUse the `buff-to-int-be` function when you need to:\n\n- Convert a big-endian encoded byte buffer to a signed integer.\n- Process input data that represents signed integers in big-endian format.\n- Implement cryptographic or mathematical operations that expect big-endian integer inputs.\n- Ensure compatibility with external systems using big-endian encoding.\n\n## Best Practices\n\n- Ensure the input buffer is no larger than 16 bytes to avoid errors.\n- Be aware that smaller buffers are zero-padded on the left, affecting the resulting integer value.\n- Consider using `buff-to-uint-be` for unsigned integers if the sign is not needed.\n- Handle potential errors when the input buffer might be invalid or empty.\n\n## Practical Example: Decoding a Signed Integer from External Data\n\nLet's implement a function that processes external data containing a big-endian encoded signed integer:\n\n```clarity\n(define-read-only (process-external-data (data (buff 16)))\n  (let\n    (\n      (value (buff-to-int-be data))\n    )\n    (if (< value 0)\n      (err \"Negative value not allowed\")\n      (ok value)\n    )\n  )\n)\n\n;; Usage\n(process-external-data 0x0000000000000001) ;; Returns (ok 1)\n(process-external-data 0xffffffffffffffff) ;; Returns (err \"Negative value not allowed\")\n(process-external-data 0x7fffffffffffffff) ;; Returns (ok 9223372036854775807)\n```\n\nThis example demonstrates:\n1. Using `buff-to-int-be` to convert external data to a signed integer.\n2. Handling both positive and negative values resulting from the conversion.\n3. Implementing input validation based on the converted integer value.\n\n## Common Pitfalls\n\n1. Forgetting that the function interprets the input as big-endian, which might lead to unexpected values if the data is actually little-endian.\n2. Not handling potential negative values when working with signed integers.\n3. Assuming a specific buffer length, which could lead to unexpected results with shorter inputs due to left-padding.\n\n## Related Functions\n\n- `buff-to-int-le`: Converts a byte buffer to a signed integer using little-endian encoding.\n- `buff-to-uint-be`: Converts a byte buffer to an unsigned integer using big-endian encoding.\n- `int-to-ascii`: Converts an integer to its ASCII string representation.\n\n## Conclusion\n\nThe `buff-to-int-be` function is a powerful tool for working with big-endian encoded signed integers in Clarity smart contracts. By understanding its behavior with different input sizes and potential sign issues, you can effectively process and validate external data, implement complex algorithms, and ensure compatibility with big-endian systems in your smart contract applications.\n"
  },
  {
    "title": "int-to-ascii",
    "description": "Convert integers to ASCII string representations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/int-to-ascii",
    "content": "\n## Function Signature\n\n```clarity\n(int-to-ascii value)\n```\n\n- Input: `int | uint`\n- Output: `(string-ascii 40)`\n\n## Why it matters\n\nThe `int-to-ascii` function is crucial for:\n\n1. Converting integer values to their string representations.\n2. Facilitating the display and logging of numeric data.\n3. Enabling the use of numeric values in contexts that require strings.\n4. Simplifying the process of creating human-readable outputs from numeric data.\n\n## When to use it\n\nUse `int-to-ascii` when you need to:\n\n- Convert an integer or unsigned integer to a string.\n- Display numeric values in a human-readable format.\n- Log or store numeric data as strings.\n- Prepare numeric data for concatenation with other strings.\n\n## Best Practices\n\n- Ensure the integer value is within the range that can be represented as a string.\n- Use meaningful variable names for better readability.\n- Combine with other string functions for more complex string manipulations.\n- Be aware of the maximum length of the resulting string (40 characters).\n\n## Practical Example: Logging a User's Balance\n\nLet's implement a function that logs a user's balance as a string:\n\n```clarity\n(define-map UserBalances { userId: principal } { balance: uint })\n\n(define-public (log-balance (user principal))\n  (let\n    (\n      (balance (default-to u0 (map-get? UserBalances { userId: user })))\n      (balanceStr (int-to-ascii balance))\n    )\n    (print balanceStr)\n  )\n)\n\n;; Usage\n(map-set UserBalances { userId: tx-sender } { balance: u100 })\n(log-balance tx-sender) ;; Logs \"100\"\n```\n\nThis example demonstrates:\n1. Using `int-to-ascii` to convert a user's balance to a string.\n2. Logging the string representation of the balance using `print`.\n3. Handling the case where the user has no balance set.\n\n## Common Pitfalls\n\n1. Assuming the resulting string will always fit within 40 characters.\n2. Forgetting to handle cases where the integer value is not set or is zero.\n3. Using `int-to-ascii` in performance-critical sections without considering the overhead.\n4. Not combining with other string functions for more complex manipulations.\n\n## Related Functions\n\n- `print`: Used to log or display string values.\n- `concat`: Used to concatenate multiple strings.\n- `default-to`: Used to provide default values for optional types.\n\n## Conclusion\n\nThe `int-to-ascii` function is a powerful tool for converting integer values to their string representations in Clarity smart contracts. This function enables you to create human-readable outputs from numeric data, facilitating logging, display, and storage of numeric values as strings. When used effectively, `int-to-ascii` enhances the readability and usability of numeric data within your smart contract code.\n"
  },
  {
    "title": "map-delete",
    "description": "Remove an entry from a map in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/map-delete",
    "content": "\n## Function Signature\n\n```clarity\n(map-delete map-name key-tuple)\n```\n\n- Input: `MapName, tuple`\n- Output: `bool`\n\n## Why it matters\n\nThe `map-delete` function is crucial for:\n\n1. Removing entries from a map.\n2. Managing and updating the state of data stored in maps.\n3. Ensuring data integrity by allowing the deletion of obsolete or incorrect entries.\n4. Simplifying the process of maintaining clean and accurate data in smart contracts.\n\n## When to use it\n\nUse `map-delete` when you need to:\n\n- Remove an entry from a map.\n- Manage and update the state of data stored in maps.\n- Ensure data integrity by deleting obsolete or incorrect entries.\n- Maintain clean and accurate data in your smart contract.\n\n## Best Practices\n\n- Ensure the key-tuple accurately identifies the entry to be deleted.\n- Use meaningful variable names for better readability.\n- Combine with other map functions for comprehensive map management.\n- Be aware of the performance implications of frequent deletions in large maps.\n\n## Practical Example: Deleting a User's Data\n\nLet's implement a function that deletes a user's data from a map:\n\n```clarity\n(define-map UserData { userId: principal } { data: (buff 32) })\n\n(define-public (delete-user-data (user principal))\n  (ok (map-delete UserData { userId: user }))\n)\n\n;; Usage\n(map-set UserData { userId: tx-sender } { data: 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef }) ;; Returns true\n(delete-user-data tx-sender) ;; Returns (ok true)\n```\n\nThis example demonstrates:\n1. Using `map-delete` to remove a user's data from the `UserData` map.\n2. Implementing a public function to delete the data.\n3. Handling the case where the user's data is present and needs to be removed.\n\n## Common Pitfalls\n\n1. Using `map-delete` with an incorrect key-tuple, causing the deletion to fail.\n2. Assuming the entry will always exist, leading to unhandled cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `map-set`: Sets the value associated with a key in a map.\n- `map-get?`: Retrieves an entry from a map.\n- `map-insert`: Inserts a value into a map if the key does not already exist.\n\n## Conclusion\n\nThe `map-delete` function is a fundamental tool for managing data in Clarity smart contracts. It allows you to remove entries from maps, ensuring data integrity and maintaining clean and accurate data. When used effectively, `map-delete` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage map entries.\n"
  },
  {
    "title": "contract-of",
    "description": "Retrieve the principal of a contract implementing a trait in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/contract-of",
    "content": "\n## Function Signature\n\n```clarity\n(contract-of <trait-reference>)\n```\n\n- Input: A trait reference\n- Output: The principal of the contract implementing the trait\n\n## Why it matters\n\nThe `contract-of` function is crucial for:\n\n1. Retrieving the principal (address) of a contract implementing a specific trait.\n2. Enabling dynamic interactions with contracts based on traits.\n3. Implementing contract-agnostic functions that work with any contract adhering to a specific interface.\n4. Enhancing interoperability between contracts in a composable ecosystem.\n\n## When to use it\n\nUse the `contract-of` function when you need to:\n\n- Get the actual contract address from a trait reference.\n- Perform operations that require the contract's principal, such as authorization checks.\n- Implement functions that can work with multiple contracts implementing the same trait.\n- Debug or log information about which contract is being interacted with.\n- Manage routing logic between different versions of contracts for upgradeable smart contracts.\n- Implement access control mechanisms to restrict function calls to designated contracts.\n\n## Best Practices\n\n- Use `contract-of` in combination with traits to create more flexible and composable smart contracts.\n- Remember that `contract-of` returns a principal, which can be used in other Clarity functions expecting a contract address.\n- Consider using `contract-of` when implementing proxy or router contracts that work with multiple similar contracts.\n- Be aware that `contract-of` can only be used with trait references, not with direct contract references.\n\n## Practical Example: Modular Approach to Extension Contracts\n\nLet's implement a system where specific functions can only be called by designated extension contracts:\n\n### Define the Extension Trait\n\nFirst, define a trait for the extension contract:\n\n```clarity\n(define-trait extension-trait\n\t(\n\t\t(callback (principal (buff 34)) (response bool uint))\n\t)\n)\n```\n\n### Implement the Main Contract\n\nNext, implement the main contract with the `request-extension-callback` function:\n\n```clarity\n(use-trait extensionTrait .extension-trait.extension-trait)\n(define-map Extensions principal bool)\n\n(define-public (set-extension (extension principal) (enabled bool))\n  (ok (map-set Extensions extension enabled))\n)\n\n(define-public (request-extension-callback (extension <extensionTrait>) (memo (buff 34)))\n  (let\n    (\n      (sender tx-sender)\n    )\n    (asserts! (and (is-extension contract-caller) (is-eq contract-caller (contract-of extension))) (err u1))\n    (as-contract (contract-call? extension callback sender memo))\n  )\n)\n\n(define-read-only (is-extension (extension principal))\n  (default-to false (map-get? Extensions extension))\n)\n```\n\n### Explanation\n\n1. **Define the Extension Trait**: The `extensionTrait` defines a `callback` function that the extension contract must implement.\n2. **Data Map for Valid Extensions**: `Extensions` is a map that stores the status (enabled/disabled) of extension contracts.\n3. **Public Function `set-extension`**: This function allows adding or removing an extension contract from the `Extensions` map.\n4. **Public Function `request-extension-callback`**: This function:\n   - Retrieves the principal of the extension contract using `contract-of`.\n   - Asserts that the caller is a valid extension and matches the extension principal.\n   - Calls the `callback` function on the extension contract using `contract-call?`.\n5. **Read-Only Function `is-extension`**: This function checks if a given contract principal is in the `Extensions` map and is enabled.\n\n### Usage\n\n1. **Set an Extension**:\n   ```clarity\n   (set-extension 'SP2J4ZQ6ZQ6ZQ6ZQ6ZQ6ZQ6ZQ6ZQ6ZQ6ZQ6ZQ6ZQ6 true)\n   ```\n\n2. **Request Extension Callback**:\n   ```clarity\n   (request-extension-callback .extension-contract (buff 34 \"example memo\"))\n   ```\n\nThis example demonstrates:\n1. Using `contract-of` to get the principal of the extension contract implementing the extension trait.\n2. Implementing a read-only function to check if the caller is a valid extension.\n3. Restricting access to certain functions based on the authorized extension contracts.\n4. Allowing the authorized extension contracts to call specific functions.\n\n## Common Pitfalls\n\n1. Attempting to use `contract-of` with a direct contract reference instead of a trait reference.\n2. Forgetting that `contract-of` returns a principal, not a contract reference itself.\n3. Not handling potential errors when working with trait references that might not be properly initialized.\n\n## Related Functions\n\n- `use-trait`: Used to define trait references that can be used with `contract-of`.\n- `contract-call?`: Often used in combination with `contract-of` to call functions on the retrieved contract.\n- `is-eq`: Can be used to compare the returned principal with known contract addresses.\n\n## Conclusion\n\nThe `contract-of` function is a powerful tool for creating flexible and interoperable smart contracts in Clarity. By allowing contracts to dynamically retrieve the principal of trait-implementing contracts, this function enables the creation of more generic and reusable code. When used effectively, `contract-of` can significantly enhance the composability and modularity of your smart contract ecosystem, especially in scenarios like access control management where restricting function calls to designated contracts is essential.\n"
  },
  {
    "title": "keccak256",
    "description": "Compute the Keccak-256 hash of a buffer in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/keccak256",
    "content": "\n## Function Signature\n\n```clarity\n(keccak256 value)\n```\n\n- Input: `buff`\n- Output: `(buff 32)`\n\n## Why it matters\n\nThe `keccak256` function is crucial for:\n\n1. Computing cryptographic hashes of data.\n2. Ensuring data integrity and authenticity.\n3. Implementing cryptographic operations in smart contracts.\n4. Creating unique identifiers for data.\n\n## When to use it\n\nUse `keccak256` when you need to:\n\n- Compute a cryptographic hash of a buffer.\n- Verify data integrity and authenticity.\n- Generate unique identifiers for data.\n- Implement cryptographic operations in your contract.\n\n## Best Practices\n\n- Ensure the input buffer is of the correct length and format.\n- Use meaningful variable names for better readability.\n- Combine with other cryptographic functions for more complex operations.\n- Be aware of the security implications of using cryptographic hashes.\n\n## Practical Example: Hashing a User's Data\n\nLet's implement a function that computes the Keccak-256 hash of a user's data:\n\n```clarity\n(define-map UserData { userId: principal } { data: (buff 32) })\n\n(define-public (hash-user-data (user principal))\n  (let\n    (\n      (data (default-to (buff 0) (map-get? UserData { userId: user })))\n      (hash (keccak256 data))\n    )\n    (ok hash)\n  )\n)\n\n;; Usage\n(map-set UserData { userId: tx-sender } { data: 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef })\n(hash-user-data tx-sender) ;; Returns the Keccak-256 hash of the data\n```\n\nThis example demonstrates:\n1. Using `keccak256` to compute the hash of a user's data.\n2. Implementing a public function to return the hash.\n3. Handling the case where the user's data is not set by providing a default value.\n\n## Common Pitfalls\n\n1. Using `keccak256` on non-buffer types, causing type errors.\n2. Not handling cases where the input buffer is empty or invalid.\n3. Overlooking the need for proper error handling and validation.\n4. Assuming the hash function is collision-resistant without understanding its limitations.\n\n## Related Functions\n\n- `sha256`: Computes the SHA-256 hash of a buffer.\n- `hash160`: Computes the RIPEMD-160 hash of the SHA-256 hash of a buffer.\n- `concat`: Concatenates multiple buffers.\n\n## Conclusion\n\nThe `keccak256` function is a powerful tool for computing cryptographic hashes in Clarity smart contracts. It allows you to ensure data integrity and authenticity, generate unique identifiers, and implement cryptographic operations. When used effectively, `keccak256` enhances the security and reliability of your smart contract code by providing a robust mechanism for hashing data.\n"
  },
  {
    "title": "define-constant",
    "description": "Define immutable constants in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/define-constant",
    "content": "\n## Function Signature\n\n```clarity\n(define-constant name expression)\n```\n\n- Input: \n  - `name`: The name of the constant\n  - `expression`: The value to be assigned to the constant\n- Output: Not applicable (definition statement)\n\n## Why it matters\n\nThe `define-constant` function is crucial for:\n\n1. Declaring immutable values that can be reused throughout the contract.\n2. Improving code readability by giving meaningful names to fixed values.\n3. Optimizing gas costs by avoiding repeated computations of fixed values.\n4. Ensuring certain values remain unchanged throughout the contract's lifecycle.\n\n## When to use it\n\nUse `define-constant` when you need to:\n\n- Define fixed values that won't change during contract execution.\n- Create named constants for magic numbers or frequently used values.\n- Declare contract-wide configuration parameters.\n- Optimize gas usage for values that are computed but never change.\n\n## Best Practices\n\n- Use uppercase names for constants to distinguish them from variables.\n- Place constant definitions at the top of your contract for better visibility.\n- Use constants for values that are used multiple times in your contract.\n- Consider using constants for contract configuration that might need to change between deployments.\n\n## Practical Example: Token Configuration\n\nLet's implement a simple token contract using constants for configuration:\n\n```clarity\n(define-constant TOKEN_NAME \"DOG-GO-TO-THE-MOON\")\n(define-constant TOKEN_SYMBOL \"DOG\")\n(define-constant TOKEN_DECIMALS u6)\n(define-constant TOKEN_SUPPLY u1000000000000) ;; 1 million tokens with 6 decimals\n\n(define-fungible-token DOG-GO-TO-THE-MOON TOKEN_SUPPLY)\n\n(define-read-only (get-name)\n  TOKEN_NAME\n)\n\n(define-read-only (get-symbol)\n  TOKEN_SYMBOL\n)\n\n(define-read-only (get-decimals)\n  TOKEN_DECIMALS\n)\n\n(define-read-only (get-balance (who principal))\n  (ok (ft-get-balance DOG-GO-TO-THE-MOON who))\n)\n```\n\nThis example demonstrates:\n1. Using `define-constant` to set up token configuration parameters.\n2. Referencing these constants in various parts of the contract.\n3. Improving readability and maintainability of the contract.\n\n## Common Pitfalls\n\n1. Attempting to modify a constant after it's defined, which is not allowed.\n2. Using `define-constant` for values that need to change during contract execution (use `define-data-var` instead).\n3. Overusing constants for values used only once, which can decrease readability.\n\n## Related Functions\n\n- `define-data-var`: Used for defining mutable variables.\n- `define-map`: Used for defining data maps.\n- `var-get`: Used to retrieve the value of a data variable (not needed for constants).\n\n## Conclusion\n\nThe `define-constant` function is a powerful tool for creating immutable, named values in Clarity smart contracts. By using constants effectively, you can improve code readability, optimize gas usage, and ensure certain values remain fixed throughout your contract's lifecycle. When designing your contract, consider which values should be constants and which might need to be mutable variables.\n"
  },
  {
    "title": "xor",
    "description": "Perform a bitwise exclusive OR operation in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/xor",
    "content": "\n## Function Signature\n\n```clarity\n(xor int1 int2)\n```\n\n- Input: `int, int`\n- Output: `int`\n\n## Why it matters\n\nThe `xor` function is crucial for:\n\n1. Performing bitwise operations essential for cryptographic functions.\n2. Implementing conditional logic that requires toggling between states.\n3. Enhancing data security through simple encryption mechanisms.\n4. Simplifying the process of handling bitwise operations in smart contracts.\n\n## When to use it\n\nUse `xor` when you need to:\n\n- Perform bitwise exclusive OR operations.\n- Implement simple encryption or decryption mechanisms.\n- Toggle between two states based on certain conditions.\n- Enhance the security of your smart contract through cryptographic operations.\n\n## Best Practices\n\n- Ensure the integers used with `xor` are within the valid range for your application.\n- Use meaningful variable names to enhance code readability.\n- Combine `xor` with other logical operations to implement complex conditions.\n- Handle possible edge cases to ensure robust contract behavior.\n\n## Practical Example: Simple Encryption\n\nLet's implement a simple encryption and decryption mechanism using the `xor` function:\n\n```clarity\n(define-public (encrypt (data int) (key int))\n  (ok (xor data key))\n)\n\n(define-public (decrypt (encryptedData int) (key int))\n  (ok (xor encryptedData key))\n)\n\n;; Usage\n(encrypt 42 123) ;; Encrypts 42 with key 123, returns (ok 81)\n(decrypt 165 123) ;; Decrypts 165 with key 123, returns (ok 222)\n```\n\nThis example demonstrates:\n1. Using `xor` to perform a bitwise exclusive OR operation.\n2. Implementing public functions to handle encryption and decryption.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `xor` with non-integer types, causing runtime errors.\n2. Misunderstanding the behavior of `xor`, leading to incorrect logic implementation.\n3. Not considering edge cases, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `and`: Performs a bitwise AND operation.\n- `or`: Performs a bitwise OR operation.\n- `not`: Performs a bitwise NOT operation.\n\n## Conclusion\n\nThe `xor` function is a powerful tool for performing bitwise exclusive OR operations in Clarity smart contracts. It allows you to implement cryptographic functions, conditional logic, and simple encryption mechanisms, enhancing the security and functionality of your smart contracts. When used effectively, `xor` simplifies the process of handling bitwise operations and ensures robust contract behavior.\n"
  },
  {
    "title": "principal-of?",
    "description": "Derive a principal from a public key in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/principal-of",
    "content": "\n## Function Signature\n\n```clarity\n(principal-of? public-key)\n```\n\n- Input: `(buff 33)`\n- Output: `(response principal uint)`\n\n## Why it matters\n\nThe `principal-of?` function is crucial for:\n\n1. Deriving a principal from a public key.\n2. Managing identities and permissions in smart contracts.\n3. Ensuring data integrity by validating public key to principal conversion.\n4. Simplifying the process of handling principals derived from public keys.\n\n## When to use it\n\nUse `principal-of?` when you need to:\n\n- Derive a principal from a public key.\n- Manage identities and permissions in your smart contract.\n- Validate the conversion of a public key to a principal.\n- Handle principal derivation operations.\n\n## Best Practices\n\n- Ensure the `public-key` is correctly formatted and valid.\n- Use meaningful variable names for better readability.\n- Combine with other principal functions for comprehensive identity management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Deriving a Principal\n\nLet's implement a function that derives a principal from a public key:\n\n```clarity\n(define-public (derive-principal (public-key (buff 33)))\n  (principal-of? public-key)\n)\n\n;; Usage\n(derive-principal 0x0390a5cac7c33fda49f70bc1b0866fa0ba7a9440d9de647fecb8132ceb76a94dfa) ;; Returns (ok 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM)\n```\n\nThis example demonstrates:\n1. Using `principal-of?` to derive a principal from a public key.\n2. Implementing a public function to handle the principal derivation.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `principal-of?` with an incorrectly formatted or invalid `public-key`, causing the operation to fail.\n2. Assuming the principal will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete principal management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `principal-construct?`: Constructs a principal from its components.\n- `principal-destruct?`: Decomposes a principal into its components.\n- `contract-caller`: Returns the caller of the current contract context.\n\n## Conclusion\n\nThe `principal-of?` function is a fundamental tool for deriving principals from public keys in Clarity smart contracts. It allows you to manage identities and permissions, ensuring data integrity and simplifying principal handling. When used effectively, `principal-of?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle principal derivation operations.\n"
  },
  {
    "title": "get-burn-block-info?",
    "description": "Fetch information about burnchain blocks in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/get-burn-block-info",
    "content": "\n## Function Signature\n\n```clarity\n(get-burn-block-info? prop-name block-height)\n```\n\n- Input: \n  - `prop-name`: A BurnBlockInfoPropertyName\n  - `block-height`: A uint representing the burnchain block height\n- Output: `(optional buff) | (optional (tuple (addrs (list 2 (tuple (hashbytes (buff 32)) (version (buff 1))))) (payout uint)))`\n\n## Why it matters\n\nThe `get-burn-block-info?` function is crucial for:\n\n1. Accessing historical data from the underlying burnchain (Bitcoin).\n2. Implementing cross-chain verification or logic based on Bitcoin block information.\n3. Retrieving PoX (Proof of Transfer) related data for advanced stacking operations.\n4. Enabling contracts to react to or validate burnchain events.\n\n## When to use it\n\nUse `get-burn-block-info?` when you need to:\n\n- Verify Bitcoin block hashes within your Stacks contract.\n- Access information about PoX payouts and addresses.\n- Implement logic that depends on burnchain block data.\n- Build cross-chain applications that reference Bitcoin state.\n\n## Best Practices\n\n- Always check if the returned value is `none`, as it will be for non-existent or future blocks.\n- Be aware of the potential for chain reorganizations when using recent block data.\n- Use the appropriate property name for the data you need to retrieve.\n- Consider caching results for frequently accessed block information to save on execution costs.\n\n## Practical Example: Verifying a Bitcoin Block Hash\n\nLet's implement a function that verifies if a given Bitcoin block hash matches a specific height:\n\n```clarity\n(define-read-only (verify-btc-block-hash (height uint) (expectedHash (buff 32)))\n  (match (get-burn-block-info? header-hash height) hash\n    (is-eq hash expectedHash)\n    false\n  )\n)\n\n;; Usage\n(verify-btc-block-hash u700000 0x00000000000000000009a11b3972c8e532e964e262c196556bd958b7fd0c55c3)\n```\n\nThis example demonstrates:\n1. Using `get-burn-block-info?` to retrieve the `header-hash` of a burnchain block.\n2. Handling the optional return value with `match`.\n3. Comparing the retrieved hash with an expected value.\n\n## Available Properties\n\n- `header-hash`: Returns a 32-byte buffer representing the header hash of the burnchain block.\n- `pox-addrs`: Returns a tuple containing PoX payout information:\n  - `addrs`: A list of up to two PoX addresses that received payouts.\n  - `payout`: The amount of burnchain tokens paid to each address.\n\n## Common Pitfalls\n\n1. Assuming all properties are available for all blocks.\n2. Not handling the `none` case when the block height is invalid or in the future.\n3. Misinterpreting the `pox-addrs` data, especially during different PoX phases.\n4. Overlooking the fact that burn addresses may be included in the `pox-addrs` list.\n\n## Related Functions\n\n- `get-block-info?`: Used to get information about Stacks blocks.\n- `burn-block-height`: Keyword that returns the current burn chain block height.\n\n## Conclusion\n\nThe `get-burn-block-info?` function is a powerful tool for accessing burnchain data in Clarity smart contracts. It allows you to incorporate Bitcoin blockchain information into your contract logic, enabling cross-chain verification and advanced PoX-related functionalities. When used correctly, this function provides valuable insights into the underlying Bitcoin blockchain's state and can be used to implement sophisticated, cross-chain aware contract behavior.\n"
  },
  {
    "title": "fold",
    "description": "Reduce a sequence to a single value in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/fold",
    "content": "\n## Function Signature\n\n```clarity\n(fold <function> <sequence> <initial-value>)\n```\n\n- Input: \n  - `<function>`: A function that takes two arguments and returns a single value\n  - `<sequence>`: A list, buffer, or string to iterate over\n  - `<initial-value>`: The starting value for the accumulation\n- Output: The final accumulated value\n\n## Why it matters\n\nThe `fold` function is crucial for:\n\n1. Aggregating values from a sequence into a single result.\n2. Performing complex computations on list elements.\n3. Transforming data structures efficiently.\n4. Implementing recursive-like operations without explicit recursion.\n\n## When to use it\n\nUse `fold` when you need to:\n\n- Calculate a sum, product, or other aggregate value from a list.\n- Transform a list into a single value or different data structure.\n- Apply a function to each element of a sequence while maintaining state.\n- Implement algorithms that would typically require recursion.\n\n## Best Practices\n\n- Ensure the function passed to `fold` is commutative if the order of operations doesn't matter.\n- Use meaningful initial values that make sense for your aggregation.\n- Consider using `fold` instead of explicit loops for cleaner, more functional code.\n- Be mindful of the performance implications when folding over large sequences.\n\n## Practical Example: Summing a List of Numbers\n\nLet's implement a function that sums all numbers in a list:\n\n```clarity\n(define-read-only (sum-list (numbers (list 10 uint)))\n  (fold + numbers u0)\n)\n\n;; Usage\n(sum-list (list u1 u2 u3 u4 u5)) ;; Returns u15\n```\n\nThis example demonstrates:\n1. Using `fold` with the built-in `+` function to sum numbers.\n2. Starting with an initial value of `u0`.\n3. Applying the operation to each element in the list.\n\n## Common Pitfalls\n\n1. Using an initial value of the wrong type or that doesn't make sense for the operation.\n2. Forgetting that `fold` processes elements from left to right, which matters for non-commutative operations.\n3. Overusing `fold` for operations that might be more clearly expressed with other functions like `map` or `filter`.\n\n## Related Functions\n\n- `map`: Applies a function to each element in a sequence, returning a new sequence.\n- `filter`: Selects elements from a sequence based on a predicate function.\n- `reduce`: Similar to `fold` in other languages, but Clarity uses `fold` for this operation.\n\n## Conclusion\n\nThe `fold` function is a powerful tool for aggregating and transforming data in Clarity smart contracts. It allows you to express complex computations on sequences in a concise and functional manner. When used effectively, `fold` can simplify code, improve readability, and provide an efficient way to process collections of data within smart contracts.\n"
  },
  {
    "title": "define-map",
    "description": "Define a data map in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/define-map",
    "content": "\n## Function Signature\n\n```clarity\n(define-map map-name key-type value-type)\n```\n\n- Input: \n  - `map-name`: The name of the map\n  - `key-type`: The type of the map's keys\n  - `value-type`: The type of the map's values\n- Output: Not applicable (definition statement)\n\n## Why it matters\n\nThe `define-map` function is crucial for:\n\n1. Creating key-value stores within smart contracts.\n2. Efficiently organizing and accessing structured data.\n3. Implementing complex data structures like mappings or dictionaries.\n4. Storing and retrieving contract-specific data associated with unique keys.\n\n## When to use it\n\nUse `define-map` when you need to:\n\n- Store and retrieve data associated with unique keys.\n- Implement lookup tables or dictionaries in your contract.\n- Organize data that needs to be accessed by a specific identifier.\n- Create data structures that can be efficiently updated and queried.\n\n## Best Practices\n\n- Choose appropriate types for keys and values to ensure efficient storage and retrieval.\n- Use meaningful names for your maps that reflect their purpose in the contract.\n- Consider using composite keys (tuples) for more complex data relationships.\n- Be mindful of the gas costs associated with map operations, especially for large datasets.\n\n## Practical Example: Simple User Profile System\n\nLet's implement a basic user profile system using `define-map`:\n\n```clarity\n(define-map UserProfiles principal { name: (string-ascii 50), age: uint, isActive: bool })\n\n(define-public (set-profile (name (string-ascii 50)) (age uint))\n  (ok (map-set UserProfiles tx-sender { name: name, age: age, isActive: true }))\n)\n\n(define-read-only (get-profile (user principal))\n  (default-to { name: \"\", age: u0, isActive: false } (map-get? UserProfiles user))\n)\n\n(define-public (deactivate-profile)\n  (match (map-get? UserProfiles tx-sender) profile\n    (ok (map-set UserProfiles tx-sender (merge profile { isActive: false })))\n    (err u404)\n  )\n)\n\n;; Usage\n(set-profile \"Ryan\" u38)\n(get-profile tx-sender)\n(deactivate-profile)\n```\n\nThis example demonstrates:\n1. Using `define-map` to create a user profile storage system.\n2. Implementing functions to set, get, and update profile data.\n3. Using map operations like `map-set`, `map-get?`, and `merge` to manipulate map data.\n4. Handling cases where a profile might not exist using `default-to`.\n\n## Common Pitfalls\n\n1. Forgetting that maps are not iterable in Clarity; you can't loop through all entries.\n2. Not handling cases where a key might not exist in the map.\n3. Overusing maps for data that might be better suited for other data structures.\n4. Not considering the gas costs of map operations in complex contracts.\n\n## Related Functions\n\n- `map-get?`: Used to retrieve a value from a map, returns an optional.\n- `map-set`: Used to set or update a value in a map.\n- `map-delete`: Used to remove a key-value pair from a map.\n- `map-insert`: Used to insert a new key-value pair only if the key doesn't already exist.\n- `merge`: Used to merge two maps, combining their key-value pairs.\n\n## Conclusion\n\nThe `define-map` function is a powerful tool for creating structured data storage in Clarity smart contracts. It allows you to implement efficient key-value stores, enabling complex data relationships and lookups. When used effectively, maps can significantly enhance the functionality and organization of data within your smart contracts.\n"
  },
  {
    "title": "stx-account",
    "description": "Query STX account information in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/stx-account",
    "content": "\n## Function Signature\n\n```clarity\n(stx-account principal)\n```\n\n- Input: `principal`\n- Output: `(tuple (balance uint) (nonce uint) (stx-locked uint))`\n\n## Why it matters\n\nThe `stx-account` function is crucial for:\n\n1. Querying detailed information about a STX account.\n2. Implementing logic that requires account balance, nonce, and locked STX information.\n3. Ensuring data integrity by providing accurate account details.\n4. Simplifying the process of handling account-related operations in smart contracts.\n\n## When to use it\n\nUse `stx-account` when you need to:\n\n- Query detailed information about a STX account.\n- Implement logic that requires account balance, nonce, and locked STX information.\n- Ensure accurate account details for data integrity.\n- Handle account-related operations in your smart contract.\n\n## Best Practices\n\n- Ensure the `principal` is correctly formatted and valid.\n- Use meaningful variable names for better readability.\n- Combine with other account functions for comprehensive account management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Querying STX Account Information\n\nLet's implement a function that queries the STX account information for a given principal:\n\n```clarity\n(define-read-only (get-stx-account-info (account principal))\n  (stx-account account)\n)\n\n;; Usage\n(get-stx-account-info 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR) \n;; Returns (tuple (balance u0) (nonce u0) (stx-locked u0))\n```\n\nThis example demonstrates:\n1. Using `stx-account` to query detailed information about a STX account.\n2. Implementing a public function to handle the account information query.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `stx-account` with an incorrectly formatted or invalid `principal`, causing the operation to fail.\n2. Assuming the account information will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete account management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `stx-get-balance`: Queries the STX balance of a principal.\n- `stx-transfer?`: Transfers STX from one principal to another.\n- `stx-burn?`: Burns STX from a principal's account.\n\n## Conclusion\n\nThe `stx-account` function is a fundamental tool for querying detailed STX account information in Clarity smart contracts. It allows you to implement logic that requires account balance, nonce, and locked STX information, ensuring data integrity and simplifying account-related operations. When used effectively, `stx-account` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle account information queries.\n"
  },
  {
    "title": "define-public",
    "description": "Define public functions in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/define-public",
    "content": "\n## Function Signature\n\n```clarity\n(define-public (function-name (arg-name-0 arg-type-0) ...) function-body)\n```\n\n- Input: \n  - `function-name`: The name of the public function\n  - `arg-name-N`: The name of each argument\n  - `arg-type-N`: The type of each argument\n  - `function-body`: The code to be executed when the function is called\n- Output: A ResponseType (using `ok` or `err`)\n\n## Why it matters\n\nThe `define-public` function is crucial for:\n\n1. Creating functions that can be called from outside the contract.\n2. Enabling interaction with the contract through transactions.\n3. Implementing the main entry points for contract functionality.\n4. Allowing other contracts to call this contract's functions.\n\n## When to use it\n\nUse `define-public` when you need to:\n\n- Create functions that users can directly interact with.\n- Implement core contract functionality that should be accessible externally.\n- Define functions that other contracts can call via `contract-call?`.\n- Create functions that modify contract state and need to be invoked through transactions.\n\n## Best Practices\n\n- Always return a response type (`(response T E)`) from public functions.\n- Use descriptive names for public functions to clearly indicate their purpose.\n- Implement proper access control for sensitive operations.\n- Handle potential errors and edge cases within the function.\n- Consider gas costs when designing public functions.\n\n## Practical Examples\n\n### Example 1: Simple Counter\n\nLet's implement a simple counter that can be incremented by users:\n\n```clarity\n(define-data-var counter int 0)\n\n(define-public (increment-counter)\n  (begin\n    (var-set counter (+ (var-get counter) 1))\n    (ok (var-get counter))\n  )\n)\n```\n\nThis example demonstrates:\n1. Using `define-public` to create a function that can be called externally.\n2. Incrementing a counter and returning the new value.\n3. Returning a response type to indicate success.\n\n### Example 2: Setting a Value\n\nLet's implement a function that sets a value if it meets certain conditions:\n\n```clarity\n(define-data-var storedValue uint u0)\n\n(define-public (set-value (value uint))\n  (if (> value u0)\n    (begin\n      (var-set storedValue value)\n      (ok value)\n    )\n    (err u1)\n  )\n)\n```\n\nThis example demonstrates:\n1. Using `define-public` to create a function that can be called externally.\n2. Setting a value only if it meets a condition.\n3. Returning a response type to indicate success or failure.\n\n## Common Pitfalls\n\n1. Forgetting to return a response type, which will cause a contract to be invalid.\n2. Not implementing proper access controls, potentially allowing unauthorized actions.\n3. Overlooking potential error conditions or edge cases.\n4. Creating functions that are too complex or gas-intensive for practical use.\n\n## Related Functions\n\n- `define-private`: Used to define private functions that can only be called within the contract.\n- `define-read-only`: Used to define public read-only functions that don't modify contract state.\n- `contract-call?`: Used by other contracts to call public functions defined with `define-public`.\n\n## Conclusion\n\nThe `define-public` function is a fundamental building block for creating interactive and composable smart contracts in Clarity. By defining public functions, you can create contracts that users and other contracts can interact with, enabling complex decentralized applications. However, it's crucial to design these functions with security, efficiency, and usability in mind.\n"
  },
  {
    "title": "define-data-var",
    "description": "Define mutable variables in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/define-data-var",
    "content": "\n## Function Signature\n\n```clarity\n(define-data-var name type value)\n```\n\n- Input: \n  - `name`: The name of the variable\n  - `type`: The type of the variable\n  - `value`: The initial value of the variable\n- Output: Not applicable (definition statement)\n\n## Why it matters\n\nThe `define-data-var` function is crucial for:\n\n1. Creating mutable state variables that can be updated throughout the contract's lifecycle.\n2. Storing and managing changeable data within the smart contract.\n3. Implementing counters, flags, or other dynamic values that need to be modified.\n4. Maintaining contract-wide state that can be accessed and modified by multiple functions.\n\n## When to use it\n\nUse `define-data-var` when you need to:\n\n- Create a variable that will change its value during contract execution.\n- Implement a counter or accumulator that needs to be updated.\n- Store temporary or intermediate state that may be modified by contract functions.\n- Maintain configurable parameters that can be updated by authorized parties.\n\n## Best Practices\n\n- Use `define-data-var` for values that need to change; for immutable values, use `define-constant` instead.\n- Initialize variables with meaningful default values.\n- Consider access control for functions that modify important data variables.\n- Use clear and descriptive names for your variables to enhance readability.\n\n## Practical Example: Simple Counter\n\nLet's implement a basic counter using `define-data-var`:\n\n```clarity\n(define-data-var counter uint u0)\n\n(define-public (increment)\n  (begin\n    (var-set counter (+ (var-get counter) u1))\n    (ok (var-get counter))\n  )\n)\n\n(define-public (decrement)\n  (begin\n    (asserts! (> (var-get counter) u0) (err u\"Counter cannot be negative\"))\n    (var-set counter (- (var-get counter) u1))\n    (ok (var-get counter))\n  )\n)\n\n(define-read-only (get-counter)\n  (ok (var-get counter))\n)\n```\n\nThis example demonstrates:\n1. Using `define-data-var` to create a mutable counter.\n2. Implementing functions to increment and decrement the counter.\n3. Using `var-get` and `var-set` to read and modify the variable's value.\n4. Adding a safety check to prevent the counter from becoming negative.\n\n## Common Pitfalls\n\n1. Forgetting that `define-data-var` creates mutable state, which can lead to unexpected behavior if not managed carefully.\n2. Not considering the initial value's impact on contract logic, especially if the contract relies on the variable's state.\n3. Overusing mutable variables when constants or maps might be more appropriate for the use case.\n\n## Related Functions\n\n- `var-get`: Used to retrieve the current value of a data variable.\n- `var-set`: Used to update the value of a data variable.\n- `define-constant`: Used for defining immutable values.\n- `define-map`: Used for defining key-value stores when more complex data structures are needed.\n\n## Conclusion\n\nThe `define-data-var` function is essential for creating mutable state in Clarity smart contracts. It allows you to implement dynamic behavior and maintain changeable data throughout your contract's lifecycle. When used judiciously, data variables can greatly enhance the functionality and flexibility of smart contracts. However, you should be mindful of the implications of mutable state and ensure proper access control and error handling when modifying these variables.\n"
  },
  {
    "title": "nft-transfer?",
    "description": "Transfer ownership of a non-fungible token (NFT) in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/nft-transfer",
    "content": "\n## Function Signature\n\n```clarity\n(nft-transfer? asset-class asset-identifier sender recipient)\n```\n\n- Input: `AssetName, A, principal, principal`\n- Output: `(response bool uint)`\n\n## Why it matters\n\nThe `nft-transfer?` function is crucial for:\n\n1. Changing the ownership of a non-fungible token (NFT).\n2. Implementing logic that depends on the transfer of NFTs.\n3. Ensuring data integrity by updating ownership records.\n4. Simplifying the process of transferring NFTs in smart contracts.\n\n## When to use it\n\nUse `nft-transfer?` when you need to:\n\n- Change the ownership of an NFT.\n- Implement logic that depends on the transfer of NFTs.\n- Update ownership records in your smart contract.\n- Handle NFT transfer operations.\n\n## Best Practices\n\n- Ensure the `sender` principal owns the NFT before attempting to transfer it.\n- Ensure the `sender` and `recipient` are different principals.\n- Use meaningful variable names for better readability.\n- Combine with other NFT functions for comprehensive NFT management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Transferring an NFT\n\nLet's implement a function that transfers an NFT from the sender to the recipient:\n\n```clarity\n(define-non-fungible-token Stackaroo (string-ascii 40))\n\n(define-public (transfer-nft (id (string-ascii 40)) (recipient principal))\n  (nft-transfer? Stackaroo id tx-sender recipient)\n)\n\n;; Usage\n(nft-mint? Stackaroo \"Roo\" tx-sender) ;; Returns (ok true)\n(transfer-nft \"Roo\" 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (ok true)\n(nft-transfer? Stackaroo \"Roo\" tx-sender 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (err u1) because the sender no longer owns the asset\n(nft-transfer? Stackaroo \"NonExistent\" tx-sender 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (err u2) because the asset does not exist\n```\n\nThis example demonstrates:\n1. Using `nft-transfer?` to transfer an NFT from the sender to the recipient.\n2. Implementing a public function to handle the transfer operation.\n3. Handling both the successful transfer and the case where the sender no longer owns the asset.\n4. Handling the case where the asset does not exist.\n\n## Common Pitfalls\n\n1. Using `nft-transfer?` without ensuring the `sender` owns the NFT, causing the operation to fail.\n2. Assuming the `sender` and `recipient` are the same principal, leading to an invalid transfer.\n3. Not handling all possible conditions, resulting in incomplete NFT management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `nft-mint?`: Mints a new non-fungible token.\n- `nft-get-owner?`: Retrieves the owner of a non-fungible token.\n- `nft-burn?`: Burns a non-fungible token.\n\n## Conclusion\n\nThe `nft-transfer?` function is a fundamental tool for transferring ownership of non-fungible tokens in Clarity smart contracts. It allows you to change NFT ownership, implement transfer logic, and ensure data integrity. When used effectively, `nft-transfer?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle NFT transfer operations.\n"
  },
  {
    "title": "multiply",
    "description": "Use the multiplication function for arithmetic operations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/multiply",
    "content": "\nThe multiplication function (`*`) in Clarity performs multiplication on a variable number of integer inputs. It's a fundamental arithmetic operation used in many smart contract calculations.\n\n## Function Signature\n\n```clarity\n(* i1 i2...)\n```\n\n- Input: Two or more integers (int or uint)\n- Output: A single integer (int or uint)\n\n## Why it matters\n\nThe multiplication function is crucial for:\n\n1. Performing basic arithmetic calculations within smart contracts.\n2. Scaling values, such as calculating fees or interest.\n3. Implementing more complex mathematical operations.\n4. Adjusting token amounts in financial contracts.\n\n## When to use it\n\nUse the multiplication function when you need to:\n\n- Perform basic multiplication in your contract logic.\n- Scale values proportionally.\n- Calculate compound values or rates.\n- Implement mathematical formulas that involve multiplication.\n\n## Best Practices\n\n- Always consider the possibility of overflow when multiplying large numbers.\n- Use appropriate types (int or uint) based on your needs and expected value ranges.\n- Consider using `mul-overflow?` for checked multiplication if overflow detection is needed.\n- Be aware that multiplying by zero will always return zero.\n\n## Practical Example: Token Vesting Contract\n\nLet's implement a simple token vesting contract that uses multiplication to calculate vested amounts:\n\n```clarity\n;; Define constants\n(define-constant VESTING_PERIOD u365)  ;; 1 year in days\n(define-constant TOTAL_ALLOCATION u1000000)  ;; Total tokens to vest\n\n;; Define data variables\n(define-data-var startTime uint u0)\n(define-data-var beneficiary principal tx-sender)\n\n;; Function to initialize vesting\n(define-public (start-vesting (recipient principal))\n  (begin\n    (asserts! (is-eq tx-sender (var-get beneficiary)) (err u1))\n    (var-set startTime block-height)\n    (var-set beneficiary recipient)\n    (ok true)\n  )\n)\n\n;; Function to calculate vested amount\n(define-read-only (get-vested-amount)\n  (let\n    (\n      (elapsed-time (- block-height (var-get startTime)))\n      (vesting-rate (/ TOTAL_ALLOCATION VESTING_PERIOD))\n    )\n    (if (>= elapsed-time VESTING_PERIOD)\n      TOTAL_ALLOCATION\n      (* vesting-rate elapsed-time)\n    )\n  )\n)\n\n;; Function to claim vested tokens\n(define-public (claim-tokens)\n  (let\n    (\n      (vested-amount (get-vested-amount))\n    )\n    (asserts! (> vested-amount u0) (err u2))\n    ;; Here you would typically transfer tokens\n    ;; For simplicity, we're just returning the amount\n    (ok vested-amount)\n  )\n)\n```\n\nThis example demonstrates:\n1. Using multiplication to calculate the vested amount based on elapsed time and vesting rate.\n2. Combining multiplication with division to implement a linear vesting schedule.\n3. Using multiplication as part of a larger mathematical formula in a smart contract context.\n\n## Common Pitfalls\n\n1. Overlooking potential overflow when multiplying large numbers.\n2. Not considering the effect of integer division when combined with multiplication.\n3. Assuming multiplication always increases a value (forgetting about multiplication by fractions < 1 in integer arithmetic).\n\n## Related Functions\n\n- `/`: Used for division operations.\n- `+`: Used for addition operations.\n- `-`: Used for subtraction operations.\n- `mul-overflow?`: Used for checked multiplication with overflow detection.\n\n## Conclusion\n\nThe multiplication function is a fundamental tool for performing arithmetic operations in Clarity smart contracts. By understanding its behavior with different types of inputs and potential edge cases, you can use it effectively to implement various mathematical operations in your contracts, from simple scaling to more complex financial calculations.\n"
  },
  {
    "title": "default-to",
    "description": "Provide a default value for optional types in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/default-to",
    "content": "\n## Function Signature\n\n```clarity\n(default-to default-value option-value)\n```\n\n- Input: \n  - `default-value`: A value of type A\n  - `option-value`: An optional value of type (optional A)\n- Output: A value of type A\n\n## Why it matters\n\nThe `default-to` function is crucial for:\n\n1. Safely handling optional values in smart contracts.\n2. Providing fallback values when dealing with potentially missing data.\n3. Simplifying code that works with map lookups or other operations that may return `none`.\n4. Improving readability by reducing nested conditionals for optional handling.\n\n## When to use it\n\nUse the `default-to` function when you need to:\n\n- Provide a default value for a map lookup that might return `none`.\n- Handle optional function parameters or return values.\n- Set a fallback value for potentially missing data in your contract logic.\n- Simplify error handling for operations that might not return a value.\n\n## Best Practices\n\n- Choose meaningful default values that make sense in the context of your contract logic.\n- Use `default-to` to make your code more concise and readable when dealing with optionals.\n- Consider the implications of using the default value in your contract's logic.\n- Combine `default-to` with other Clarity functions like `map-get?` for efficient data handling.\n\n## Practical Example: User Profile Lookup\n\nLet's implement a function that retrieves a user's profile information with default values:\n\n```clarity\n(define-map UserProfiles principal { name: (string-ascii 50), age: uint })\n\n(define-read-only (get-user-profile (user principal))\n  (let\n    (\n      (profile (map-get? UserProfiles user))\n    )\n    {\n      name: (default-to \"Anonymous\" (get name profile)),\n      age: (default-to u0 (get age profile))\n    }\n  )\n)\n\n;; Usage\n(map-set UserProfiles tx-sender { name: \"Alice\", age: u30 })\n(get-user-profile tx-sender) ;; Returns { name: \"Alice\", age: u30 }\n(get-user-profile 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5) ;; Returns { name: \"Anonymous\", age: u0 }\n```\n\nThis example demonstrates:\n1. Using `default-to` with `map-get?` to handle potentially missing user profiles.\n2. Providing default values for individual fields within the profile.\n3. Creating a safe way to retrieve user information without explicit null checks.\n\n## Common Pitfalls\n\n1. Forgetting that `default-to` only works with optional types, not with general error handling.\n2. Using default values that might be indistinguishable from valid data, leading to confusion.\n3. Overusing `default-to` where explicit error handling might be more appropriate.\n\n## Related Functions\n\n- `map-get?`: Often used in combination with `default-to` for safe map lookups.\n- `get`: Can return optional values that are then handled by `default-to`.\n- `some`: Used to create optional values that can be handled by `default-to`.\n\n## Conclusion\n\nThe `default-to` function is a powerful tool for handling optional values in Clarity smart contracts. By providing a clean way to specify fallback values, this function enhances code readability and safety when dealing with potentially missing data. When used judiciously, `default-to` can significantly simplify your contract logic and make it more robust against unexpected inputs or states.\n"
  },
  {
    "title": "get-stacks-block-info?",
    "description": "Fetch information about Stacks blocks in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/get-stacks-block-info",
    "content": "\n<Callout>\nIn Clarity 3, this function replaces the deprecated `get-block-info?` function.\n</Callout>\n\n## Function Signature\n\n```clarity\n(get-stacks-block-info? prop-name block-height)\n```\n\n- Input: \n  - `prop-name`: A StacksBlockInfoPropertyName\n  - `block-height`: A uint representing the Stacks block height\n- Output: `(optional buff) | (optional uint)` depending on the property\n\n## Why it matters\n\nThe `get-stacks-block-info?` function is crucial for:\n\n1. Accessing historical Stacks block data within smart contracts\n2. Retrieving globally unique block identifiers\n3. Implementing time-based logic using block information\n4. Verifying block-related properties for security or validation purposes\n\n## When to use it\n\nUse `get-stacks-block-info?` when you need to:\n\n- Retrieve unique identifiers for Stacks blocks\n- Access block timestamps for time-based logic\n- Verify block hashes for validation purposes\n- Implement logic that depends on block information\n\n## Best Practices\n\n- Always use `id-header-hash` when global uniqueness is required\n- Handle the `none` case for non-existent or future blocks\n- Be aware of the different timestamp sources before and after epoch 3.0\n- Consider caching frequently accessed block information\n\n## Practical Example: Block Hash Verification\n\n```clarity\n(define-read-only (verify-block-hash (blockHeight uint) (expectedHash (buff 32)))\n  (match (get-stacks-block-info? id-header-hash blockHeight)\n    hash (is-eq hash expectedHash)\n    false\n  )\n)\n\n;; Usage\n(verify-block-hash u100 0x374708fff7719dd5979ec875d56cd2286f6d3cf7ec317a3b25632aab28ec37bb)\n```\n\nThis example demonstrates:\n1. Retrieving a block's unique identifier\n2. Handling the optional return value\n3. Comparing block hashes for verification\n\n## Available Properties\n\n- `id-header-hash`: Returns the globally unique index block hash (buff 32)\n- `header-hash`: Returns the Stacks block's header hash (buff 32)\n- `time`: Returns the block time as Unix epoch timestamp (uint)\n\n## Common Pitfalls\n\n1. Using `header-hash` when global uniqueness is required (use `id-header-hash` instead)\n2. Not handling the `none` case for invalid or future block heights\n3. Assuming block times are exact (accuracy varies by epoch):\n   - Pre-epoch 3.0: Accurate within two hours\n   - Post-epoch 3.0: Must be greater than previous block and at most 15 seconds in the future\n4. Not considering the different timestamp sources across epochs\n\n## Related Functions\n\n- `get-tenure-info?`: Used to get information about block tenures\n- `block-height`: Returns the current block height\n- `at-block`: Used with `id-header-hash` for historical state access\n\n## Conclusion\n\nThe `get-stacks-block-info?` function, introduced in Clarity 3, provides essential access to Stacks block data in smart contracts. This function offers reliable ways to access block identifiers and timestamps, with important considerations for global uniqueness and time accuracy across different epochs. Understanding its properties and limitations is crucial for building robust smart contracts that interact with historical blockchain state.\n\n"
  },
  {
    "title": "map",
    "description": "Apply a function to each element of a list in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/map",
    "content": "\n## Function Signature\n\n```clarity\n(map function list)\n```\n\n- Input: `(function (A) => B)`, `(list A)`\n- Output: `(list B)`\n\n## Why it matters\n\nThe `map` function is crucial for:\n\n1. Applying a function to each element of a list.\n2. Transforming lists by applying operations to their elements.\n3. Simplifying the process of performing bulk operations on lists.\n4. Enhancing code readability and maintainability by abstracting repetitive operations.\n\n## When to use it\n\nUse `map` when you need to:\n\n- Apply a function to each element of a list.\n- Transform a list by applying operations to its elements.\n- Perform bulk operations on lists.\n- Simplify and abstract repetitive operations on list elements.\n\n## Best Practices\n\n- Ensure the function being applied is compatible with the elements of the list.\n- Use meaningful variable names for better readability.\n- Combine with other list functions for comprehensive list handling.\n- Be aware of the performance implications of applying functions to large lists.\n\n## Practical Example: Doubling Each Element in a List\n\nLet's implement a function that doubles each element in a list of integers:\n\n```clarity\n(define-private (double (n int))\n  (* n 2)\n)\n\n(define-read-only (double-elements (numbers (list 10 int)))\n  (map double numbers)\n)\n\n;; Usage\n(double-elements (list 1 2 3 4 5)) ;; Returns (list 2 4 6 8 10)\n```\n\nThis example demonstrates:\n1. Defining a private function `double` to double an integer.\n2. Using `map` to apply the `double` function to each element in a list.\n3. Implementing a read-only function to return the transformed list.\n4. Handling both small and large input lists.\n\n## Common Pitfalls\n\n1. Using `map` with incompatible function and list element types, causing type errors.\n2. Assuming the list will always be within a certain length, leading to unhandled cases.\n3. Not handling all possible conditions, resulting in incomplete list transformations.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `filter`: Filters elements of a list based on a predicate function.\n- `fold`: Reduces a list to a single value by applying a function.\n- `len`: Returns the length of a list.\n\n## Conclusion\n\nThe `map` function is a fundamental tool for applying functions to each element of a list in Clarity smart contracts. It allows you to transform lists, perform bulk operations, and simplify repetitive tasks. When used effectively, `map` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage list transformations.\n"
  },
  {
    "title": "sqrti",
    "description": "Calculate the integer square root of a number in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/sqrti",
    "content": "\n## Function Signature\n\n```clarity\n(sqrti n)\n```\n\n- Input: `int | uint`\n- Output: `int | uint`\n\n## Why it matters\n\nThe `sqrti` function is crucial for:\n\n1. Calculating the largest integer less than or equal to the square root of a number.\n2. Implementing mathematical operations in smart contracts.\n3. Ensuring data integrity by providing precise integer square root calculations.\n4. Simplifying the process of handling square root operations in smart contracts.\n\n## When to use it\n\nUse `sqrti` when you need to:\n\n- Calculate the integer square root of a number.\n- Implement mathematical operations in your smart contract.\n- Ensure precise integer square root calculations.\n- Handle square root operations.\n\n## Best Practices\n\n- Ensure the input value is non-negative to avoid runtime errors.\n- Use meaningful variable names for better readability.\n- Combine with other mathematical functions for comprehensive calculations.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Calculating Integer Square Roots\n\nLet's implement a function that calculates the integer square root of a given number:\n\n```clarity\n(define-read-only (calculate-sqrti (input uint))\n  (sqrti input)\n)\n\n;; Usage\n(calculate-sqrti u11) ;; Returns u3\n(calculate-sqrti u1000000) ;; Returns u1000\n(calculate-sqrti u1) ;; Returns u1\n(calculate-sqrti u0) ;; Returns u0\n```\n\nThis example demonstrates:\n1. Using `sqrti` to calculate the integer square root of a given number.\n2. Implementing a public function to handle the square root calculation.\n3. Handling both small and large input values.\n\n## Common Pitfalls\n\n1. Using `sqrti` with negative numbers, causing the operation to fail.\n2. Assuming the result will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete mathematical operations.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `*`: Multiplies two or more numbers.\n- `+`: Adds two or more numbers.\n- `-`: Subtracts one number from another.\n- `/`: Divides one number by another.\n\n## Conclusion\n\nThe `sqrti` function is a fundamental tool for calculating integer square roots in Clarity smart contracts. It allows you to implement precise mathematical operations, ensuring data integrity and simplifying square root calculations. When used effectively, `sqrti` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle integer square root operations.\n"
  },
  {
    "title": "log2",
    "description": "Calculate the base-2 logarithm of a number in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/log2",
    "content": "\n## Function Signature\n\n```clarity\n(log2 n)\n```\n\n- Input: `int | uint`\n- Output: `int | uint`\n\n## Why it matters\n\nThe `log2` function is crucial for:\n\n1. Calculating the base-2 logarithm of a number.\n2. Implementing mathematical operations that require logarithmic calculations.\n3. Simplifying the process of determining the power of 2 needed to obtain a given value.\n4. Facilitating operations that depend on logarithmic scaling.\n\n## When to use it\n\nUse `log2` when you need to:\n\n- Calculate the base-2 logarithm of an integer or unsigned integer.\n- Implement logic that depends on logarithmic calculations.\n- Determine the power of 2 needed to obtain a given value.\n- Simplify mathematical operations involving logarithms.\n\n## Best Practices\n\n- Ensure the input value is non-negative, as `log2` fails on negative numbers.\n- Use meaningful variable names for better readability.\n- Combine with other mathematical functions for comprehensive calculations.\n- Be aware of the integer rounding behavior of `log2`.\n\n## Practical Example: Calculating Logarithm of a Number\n\nLet's implement a function that calculates the base-2 logarithm of a given number:\n\n```clarity\n(define-read-only (calculate-log2 (n uint))\n  (log2 n)\n)\n\n;; Usage\n(calculate-log2 u8) ;; Returns u3\n(calculate-log2 u16) ;; Returns u4\n```\n\nThis example demonstrates:\n1. Using `log2` to calculate the base-2 logarithm of a given number.\n2. Implementing a read-only function to return the logarithm.\n3. Handling both small and large input values.\n\n## Common Pitfalls\n\n1. Using `log2` on negative numbers, causing the function to fail.\n2. Assuming the result will always be an integer, leading to incorrect expectations.\n3. Not handling all possible conditions, resulting in incomplete calculations.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `sqrti`: Returns the largest integer that is less than or equal to the square root of a number.\n- `pow`: Raises a number to the power of another number.\n- `sqrt`: Returns the square root of a number.\n\n## Conclusion\n\nThe `log2` function is a fundamental tool for calculating the base-2 logarithm of numbers in Clarity smart contracts. It allows you to perform logarithmic calculations, enabling robust and comprehensive mathematical operations. When used effectively, `log2` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage logarithmic calculations.\n"
  },
  {
    "title": "and",
    "description": "Use the and function for logical operations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/and",
    "content": "\nThe `and` function in Clarity performs a logical AND operation on two or more boolean inputs. It's a fundamental logical operation used in many smart contract conditions and control flows.\n\n## Function Signature\n\n```clarity\n(and b1 b2 ...)\n```\n\n- Input: Two or more boolean values\n- Output: A single boolean value\n\n## Why it matters\n\nThe `and` function is crucial for:\n\n1. Implementing complex conditional logic in smart contracts.\n2. Combining multiple conditions that all need to be true.\n3. Short-circuiting evaluations for efficiency.\n4. Creating sophisticated access control mechanisms.\n\n## When to use it\n\nUse the `and` function when you need to:\n\n- Check if multiple conditions are all true.\n- Implement multi-factor authentication or permissions.\n- Optimize condition checking by short-circuiting.\n- Combine the results of multiple comparison operations.\n\n## Best Practices\n\n- Leverage the short-circuiting behavior for efficiency.\n- Order conditions from most likely to fail to least likely for better performance.\n- Use parentheses to group complex logical expressions for clarity.\n- Consider breaking very complex `and` expressions into separate functions or variables for readability.\n\n## Practical Example: Simple Access Control\n\nLet's implement a simple access control function that uses the `and` function to check multiple conditions:\n\n```clarity\n(define-constant CONTRACT_OWNER tx-sender)\n(define-data-var isAdmin bool false)\n(define-data-var isActive bool true)\n\n(define-public (set-admin (enabled bool))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT_OWNER) (err u1))\n    (ok (var-set isAdmin enabled))\n  )\n)\n\n(define-public (perform-sensitive-action)\n  (begin\n    (asserts! (and (var-get isAdmin) (var-get isActive)) (err u2))\n    ;; Perform the sensitive action here\n    (ok true)\n  )\n)\n\n;; Usage\n(perform-sensitive-action) ;; Returns (err u2)\n(set-admin true) ;; Returns (ok true)\n(perform-sensitive-action) ;; Returns (ok true)\n```\n\nThis example demonstrates:\n1. Using `and` to check if the sender is an admin and if the contract is active.\n2. Combining multiple conditions in a single `and` expression.\n3. Leveraging short-circuiting to avoid unnecessary computations if the first condition fails.\n\n## Common Pitfalls\n\n1. Forgetting that `and` short-circuits, which might lead to unexpected behavior if side effects are intended in later conditions.\n2. Over-complicating logical expressions, making them hard to read and maintain.\n3. Not considering the order of conditions for optimal performance.\n\n## Related Functions\n\n- `or`: Used for logical OR operations.\n- `not`: Used to negate boolean values.\n- `asserts!`: Often used in combination with `and` for multiple condition checks.\n\n## Conclusion\n\nThe `and` function is a powerful tool for creating complex logical conditions in Clarity smart contracts. By understanding its short-circuiting behavior and using it effectively, you can create efficient and sophisticated contract logic, especially for scenarios requiring multiple conditions to be true simultaneously.\n"
  },
  {
    "title": "replace-at?",
    "description": "Replace an element at a specific index in a sequence in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/replace-at",
    "content": "\n## Function Signature\n\n```clarity\n(replace-at? sequence index new-element)\n```\n\n- Input: `sequence_A, uint, A`\n- Output: `(response sequence_A uint)`\n\n## Why it matters\n\nThe `replace-at?` function is crucial for:\n\n1. Modifying elements in a sequence at a specific index.\n2. Implementing logic that requires updating sequences.\n3. Ensuring data integrity by validating index and element replacement.\n4. Simplifying the process of handling sequence modifications in smart contracts.\n\n## When to use it\n\nUse `replace-at?` when you need to:\n\n- Modify an element in a sequence at a specific index.\n- Implement logic that requires updating sequences.\n- Validate the index and element replacement in your smart contract.\n- Handle sequence modification operations.\n\n## Best Practices\n\n- Ensure the `index` is within the bounds of the sequence.\n- Use meaningful variable names for better readability.\n- Combine with other sequence functions for comprehensive sequence management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Replacing an Element in a List\n\nLet's implement a function that replaces an element in a list at a specific index:\n\n```clarity\n(define-read-only (replace-element (items (list 5 int)) (index uint) (newElement int))\n  (replace-at? items index newElement)\n)\n\n;; Usage\n(replace-element (list 1 2 3 4 5) u2 10) ;; Returns (some (list (1 2 10 4 5)))\n(replace-element (list 1 2 3 4 5) u5 10) ;; Returns (none) because the index is out of bounds\n```\n\nThis example demonstrates:\n1. Using `replace-at?` to modify an element in a list at a specific index.\n2. Implementing a public function to handle the element replacement.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `replace-at?` with an index that is out of bounds, causing the operation to fail.\n2. Assuming the sequence will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete sequence management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `append`: Adds an element to the end of a list.\n- `index-of?`: Returns the first index at which an item can be found in a sequence.\n- `get`: Retrieves an element from a sequence at a specific index.\n\n## Conclusion\n\nThe `replace-at?` function is a fundamental tool for modifying elements in sequences in Clarity smart contracts. It allows you to update sequences, ensuring data integrity and simplifying sequence handling. When used effectively, `replace-at?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle sequence modification operations.\n"
  },
  {
    "title": "len",
    "description": "Get the length of a sequence in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/len",
    "content": "\n## Function Signature\n\n```clarity\n(len sequence)\n```\n\n- Input: `sequence_A`\n- Output: `uint`\n\n## Why it matters\n\nThe `len` function is crucial for:\n\n1. Determining the length of various sequence types.\n2. Implementing logic that depends on the size of sequences.\n3. Ensuring data integrity by validating sequence lengths.\n4. Simplifying length checks in smart contract code.\n\n## When to use it\n\nUse `len` when you need to:\n\n- Get the length of a list, buffer, or string.\n- Implement logic that depends on the size of sequences.\n- Validate the length of input data.\n- Handle cases where the size of a sequence is important.\n\n## Best Practices\n\n- Ensure the sequence type is compatible with the `len` function.\n- Use meaningful variable names for better readability.\n- Combine with other functions for comprehensive sequence handling.\n- Be aware of the maximum length of sequences in Clarity.\n\n## Practical Example: Validating a List Length\n\nLet's implement a function that validates the length of a list of integers:\n\n```clarity\n(define-read-only (validate-list-length (numbers (list 10 int)))\n  (let\n    (\n      (length (len numbers))\n    )\n    (if (<= length u10)\n      (ok length)\n      (err u1)\n    )\n  )\n)\n\n;; Usage\n(validate-list-length (list 1 2 3 4 5)) ;; Returns (ok u5)\n(validate-list-length (list 1 2 3 4 5 6 7 8 9 10 11)) ;; Returns (err u1)\n```\n\nThis example demonstrates:\n1. Using `len` to get the length of a list of integers.\n2. Implementing conditional logic based on the length of the list.\n3. Handling both the case where the list length is valid and where it is not.\n\n## Common Pitfalls\n\n1. Using `len` on incompatible types, causing type errors.\n2. Assuming the length will always be within a certain range, leading to unhandled cases.\n3. Not handling all possible conditions, resulting in incomplete length checks.\n4. Overlooking the need for comprehensive validation and error checking.\n\n## Related Functions\n\n- `as-max-len?`: Ensures a sequence does not exceed a maximum length.\n- `concat`: Concatenates multiple sequences.\n- `default-to`: Provides default values for optional types.\n\n## Conclusion\n\nThe `len` function is a fundamental tool for getting the length of sequences in Clarity smart contracts. It allows you to determine the size of lists, buffers, and strings, enabling robust and comprehensive sequence handling and validation logic. When used effectively, `len` enhances the reliability and maintainability of your smart contract code by ensuring that sequence lengths are detected and handled appropriately.\n"
  },
  {
    "title": "sha512/256",
    "description": "Compute the SHA-512/256 hash of a value in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/sha512-256",
    "content": "\n## Function Signature\n\n```clarity\n(sha512/256 value)\n```\n\n- Input: `buff | uint | int`\n- Output: `(buff 32)`\n\n## Why it matters\n\nThe `sha512/256` function is crucial for:\n\n1. Computing the SHA-512/256 hash of a given value.\n2. Implementing cryptographic operations in smart contracts.\n3. Ensuring data integrity by generating unique hashes.\n4. Simplifying the process of handling cryptographic hashing in smart contracts.\n\n## When to use it\n\nUse `sha512/256` when you need to:\n\n- Compute the SHA-512/256 hash of a given value.\n- Implement cryptographic operations in your smart contract.\n- Generate unique hashes to ensure data integrity.\n- Handle cryptographic hashing operations.\n\n## Best Practices\n\n- Ensure the input value is correctly formatted and valid.\n- Use meaningful variable names for better readability.\n- Combine with other cryptographic functions for comprehensive security management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Computing a SHA-512/256 Hash\n\nLet's implement a function that computes the SHA-512/256 hash of a given buffer:\n\n```clarity\n(define-read-only (compute-sha512-256 (input (buff 32)))\n  (sha512/256 input)\n)\n\n;; Usage\n(compute-sha512-256 0x68656c6c6f20776f726c64000000000000000000000000000000000000000000)\n;; Returns 0xcf0edb437886eae39b21ebad0caeea342d2bd61c98e9d09d0e89109a546d01fc\n```\n\nThis example demonstrates:\n1. Using `sha512/256` to compute the hash of a given buffer.\n2. Implementing a public function to handle the hash computation.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `sha512/256` with incorrectly formatted or invalid input values, causing the operation to fail.\n2. Assuming the hash will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete cryptographic hashing.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `sha256`: Computes the SHA-256 hash of the input.\n- `sha512`: Computes the SHA-512 hash of the input.\n- `keccak256`: Computes the KECCAK-256 hash of the input.\n\n## Conclusion\n\nThe `sha512/256` function is a fundamental tool for computing SHA-512/256 hashes in Clarity smart contracts. It allows you to implement cryptographic operations, ensuring data integrity and simplifying cryptographic hashing. When used effectively, `sha512/256` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle cryptographic hashing operations.\n"
  },
  {
    "title": "divide",
    "description": "Use the division function for arithmetic operations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/divide",
    "content": "\nThe division function (`/`) in Clarity performs integer division on a variable number of integer inputs. It's a fundamental arithmetic operation used in many smart contract calculations.\n\n## Function Signature\n\n```clarity\n(/ i1 i2...)\n```\n\n- Input: Two or more integers (int or uint)\n- Output: A single integer (int or uint)\n\n## Why it matters\n\nThe division function is crucial for:\n\n1. Performing basic arithmetic calculations within smart contracts.\n2. Calculating rates, percentages, or proportions.\n3. Distributing resources or tokens evenly.\n4. Implementing mathematical formulas that involve division.\n\n## When to use it\n\nUse the division function when you need to:\n\n- Perform basic division in your contract logic.\n- Calculate rates or percentages.\n- Distribute resources evenly among participants.\n- Implement mathematical formulas that involve division.\n\n## Best Practices\n\n- Always consider the possibility of division by zero, which throws a runtime error.\n- Be aware that Clarity uses integer division, so results are always rounded down.\n- Use appropriate types (int or uint) based on your needs and expected value ranges.\n- Consider using multiplication by fractions instead of division for more precise calculations.\n\n## Practical Example: Token Distribution Contract\n\nLet's implement a simple token distribution contract that uses division to allocate tokens evenly:\n\n```clarity\n;; Define constants\n(define-constant TOTAL_TOKENS u1000000)\n(define-constant DISTRIBUTION_ROUNDS u10)\n\n;; Define data variables\n(define-map ParticipantShares principal uint)\n(define-data-var currentRound uint u0)\n(define-data-var participantsCount uint u0)\n\n;; Function to register as a participant\n(define-public (register-participant)\n  (let\n    (\n      (currentParticipants (var-get participantsCount))\n    )\n    (asserts! (< currentParticipants DISTRIBUTION_ROUNDS) (err u1))\n    (map-set ParticipantShares tx-sender u0)\n    (var-set participantsCount (+ currentParticipants u1))\n    (ok true)\n  )\n)\n\n;; Function to distribute tokens\n(define-public (distribute-tokens)\n  (let\n    (\n      (currentParticipants (var-get participantsCount))\n      (tokensPerParticipant (/ TOTAL_TOKENS currentParticipants))\n    )\n    (asserts! (> currentParticipants u0) (err u2))\n    (asserts! (< (var-get currentRound) DISTRIBUTION_ROUNDS) (err u3))\n    (map-set ParticipantShares tx-sender tokensPerParticipant)\n    (var-set currentRound (+ (var-get currentRound) u1))\n    (ok tokensPerParticipant)\n  )\n)\n\n;; Function to check participant's share\n(define-read-only (get-participant-share (participant principal))\n  (default-to u0 (map-get? ParticipantShares participant))\n)\n```\n\nThis example demonstrates:\n1. Using division to calculate the number of tokens each participant should receive.\n2. Handling potential division by zero by checking the number of participants.\n3. Using integer division to evenly distribute tokens among participants.\n\n## Common Pitfalls\n\n1. Forgetting to handle division by zero, which causes a runtime error.\n2. Not accounting for integer division rounding down, which can lead to unexpected results.\n3. Dividing before multiplying in complex calculations, potentially losing precision.\n\n## Related Functions\n\n- `*`: Used for multiplication operations.\n- `+`: Used for addition operations.\n- `-`: Used for subtraction operations.\n\n## Conclusion\n\nThe division function is a fundamental tool for performing arithmetic operations in Clarity smart contracts. By understanding its behavior with integer division and potential edge cases, you can use it effectively to implement various mathematical operations in their contracts, from simple divisions to more complex token distribution algorithms.\n"
  },
  {
    "title": "bit-and",
    "description": "Use the bit-and function for bitwise operations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/bit-and",
    "content": "\nThe `bit-and` function in Clarity performs a bitwise AND operation on two or more integer inputs. It's a powerful tool for working with compact data representations and flag systems in smart contracts.\n\n## Function Signature\n\n```clarity\n(bit-and i1 i2...)\n```\n\n- Input: Two or more integers (int or uint)\n- Output: A single integer (int or uint)\n\n## Why it matters\n\nThe `bit-and` function is crucial for:\n\n1. Efficient data storage: Allows packing multiple boolean flags into a single integer.\n2. Permission systems: Enables checking for specific permissions in a compact format.\n3. Bitmasking: Useful for isolating specific bits in a larger integer.\n4. Low-level optimizations: Can be used for certain mathematical operations.\n\n## When to use it\n\nUse `bit-and` when you need to:\n\n- Check if specific bits are set in a bitfield\n- Implement compact permission or flag systems\n- Clear specific bits while leaving others unchanged\n- Perform certain low-level optimizations\n\n## Best Practices\n\n- Always use constants for bit flags to improve readability and maintainability.\n- Be cautious when using with signed integers, as the sign bit can affect results.\n- Combine with other bitwise operations like `bit-or` and `bit-not` for more complex manipulations.\n- Document your bit flag meanings clearly in your contract.\n\n## Practical Example: Role-Based Access Control\n\nLet's implement a simple role-based access control system using `bit-and`:\n\n```clarity\n;; Define role constants\n(define-constant ROLE_ADMIN u1)  ;; 0001\n(define-constant ROLE_MODERATOR u2)  ;; 0010\n(define-constant ROLE_USER u4)  ;; 0100\n\n;; Map to store user roles\n(define-map UserRoles principal uint)\n\n;; Function to check if a user has a specific role\n(define-read-only (has-role? (user principal) (role uint))\n  (let\n    ((userRole (default-to u0 (map-get? UserRoles user))))\n    (is-eq (bit-and userRole role) role)\n  )\n)\n\n;; Function to add a role to a user\n(define-public (add-role (user principal) (role uint))\n  (let\n    ((currentRole (default-to u0 (map-get? UserRoles user))))\n    (ok (map-set UserRoles user (bit-or currentRole role)))\n  )\n)\n\n;; Function to remove a role from a user\n(define-public (remove-role (user principal) (role uint))\n  (let\n    ((currentRole (default-to u0 (map-get? UserRoles user))))\n    (ok (map-set UserRoles user (bit-and currentRole (bit-not role))))\n  )\n)\n\n;; Example usage\n(add-role tx-sender (bit-or ROLE_MODERATOR ROLE_USER))\n(has-role? tx-sender ROLE_MODERATOR) ;; Returns true\n(has-role? tx-sender ROLE_ADMIN) ;; Returns false\n(remove-role tx-sender ROLE_USER)\n(has-role? tx-sender ROLE_USER) ;; Returns false\n```\n\nThis example demonstrates:\n1. Using `bit-and` to check for specific roles.\n2. Combining `bit-and` with `bit-or` and `bit-not` for role management.\n3. Efficient storage of multiple roles in a single integer.\n\n## Common Pitfalls\n\n1. Forgetting that `bit-and` with 0 always results in 0.\n2. Not accounting for the sign bit when using signed integers.\n3. Overcomplicating bit flag systems, making them hard to maintain.\n\n## Related Functions\n\n- `bit-or`: Used to set bits or combine flags.\n- `bit-not`: Used to invert bits, often in combination with `bit-and` for clearing specific bits.\n- `bit-xor`: Used for toggling specific bits.\n\n## Conclusion\n\nThe `bit-and` function is a powerful tool for working with compact data representations in Clarity. By mastering this function along with other bitwise operations, you can create efficient and sophisticated smart contracts that make optimal use of storage and perform complex flag-based logic.\n"
  },
  {
    "title": "less than",
    "description": "Use the less than function for comparisons in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/less-than",
    "content": "\nThe less than function (`<`) in Clarity compares two values and returns true if the first value is less than the second. It's a fundamental comparison operation used in many smart contract conditions and logic flows.\n\n## Function Signature\n\n```clarity\n(< v1 v2)\n```\n\n- Input: Two values of the same type (int, uint, string-ascii, string-utf8, or buff)\n- Output: A boolean (true or false)\n\n## Why it matters\n\nThe less than function is crucial for:\n\n1. Implementing conditional logic in smart contracts.\n2. Comparing numerical values for financial operations.\n3. Ordering and sorting data.\n4. Implementing maximum thresholds or limits in contract logic.\n\n## When to use it\n\nUse the less than function when you need to:\n\n- Compare two numerical values to determine if one is smaller.\n- Implement maximum thresholds for certain operations.\n- Create conditional logic based on numerical comparisons.\n- Sort or order data based on numerical or lexicographical order.\n\n## Best Practices\n\n- Ensure that both inputs are of the same type to avoid runtime errors.\n- Be aware of the differences in comparison between signed (int) and unsigned (uint) integers.\n- When comparing strings or buffers, understand that the comparison is lexicographical.\n- Consider edge cases, especially when dealing with the limits of integer ranges.\n\n## Practical Example: Auction Contract with Maximum Bid\n\nLet's implement a simple auction contract that uses the less than function to enforce a maximum bid amount:\n\n```clarity\n;; Define constants\n(define-constant MAX_BID u1000000000) ;; 1000 STX\n(define-constant AUCTION_END_HEIGHT u100)\n\n;; Define data variables\n(define-data-var currentHighestBid uint u0)\n(define-data-var highestBidder (optional principal) none)\n\n;; Function to place a bid\n(define-public (place-bid (bid uint))\n  (let\n    (\n      (current-block-height block-height)\n    )\n    ;; Check if the auction is still open\n    (asserts! (< current-block-height AUCTION_END_HEIGHT) (err u1))\n    ;; Check if the bid is less than the maximum allowed bid\n    (asserts! (< bid MAX_BID) (err u2))\n    ;; Check if the bid is higher than the current highest bid\n    (asserts! (> bid (var-get currentHighestBid)) (err u3))\n    ;; Place the bid\n    (try! (stx-transfer? bid tx-sender (as-contract tx-sender)))\n    (var-set currentHighestBid bid)\n    (var-set highestBidder (some tx-sender))\n    (ok bid)\n  )\n)\n\n;; Function to check current highest bid\n(define-read-only (get-highest-bid)\n  (ok (var-get currentHighestBid))\n)\n\n;; Function to check if auction has ended\n(define-read-only (auction-ended)\n  (>= block-height AUCTION_END_HEIGHT)\n)\n```\n\nThis example demonstrates:\n1. Using `<` to check if the current block height is less than the auction end height.\n2. Using `<` to ensure the bid is less than the maximum allowed bid.\n3. Combining the less than check with other contract logic for an auction system.\n\n## Common Pitfalls\n\n1. Comparing values of different types, which will result in a runtime error.\n2. Not considering the inclusive nature of `<=` vs the exclusive nature of `<` when setting thresholds.\n3. Overlooking potential integer underflow when working with very small numbers.\n\n## Related Functions\n\n- `>`: Used for greater than comparisons.\n- `<=`: Used for less than or equal to comparisons.\n- `>=`: Used for greater than or equal to comparisons.\n\n## Conclusion\n\nThe less than function is a fundamental tool for implementing comparison logic in Clarity smart contracts. By understanding its behavior with different types and potential edge cases, you can create robust conditional logic and enforce important thresholds in your contracts.\n"
  },
  {
    "title": "ft-burn?",
    "description": "Burn fungible tokens in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/ft-burn",
    "content": "\n## Function Signature\n\n```clarity\n(ft-burn? token-name amount sender)\n```\n\n- Input: \n  - `token-name`: The name of the fungible token\n  - `amount`: The amount of tokens to burn (uint)\n  - `sender`: The principal from whose balance the tokens will be burned\n- Output: `(response bool uint)`\n\n## Why it matters\n\nThe `ft-burn?` function is crucial for:\n\n1. Decreasing the total supply of a fungible token.\n2. Implementing token burning mechanisms in tokenomics models.\n3. Allowing users to destroy their own tokens.\n4. Managing token supply in deflationary token systems.\n\n## When to use it\n\nUse `ft-burn?` when you need to:\n\n- Implement a token burning feature in your contract.\n- Reduce the circulating supply of a token.\n- Allow users to voluntarily destroy their tokens.\n- Execute deflationary mechanisms in your token economy.\n\n## Best Practices\n\n- Ensure that the `sender` has sufficient balance before attempting to burn.\n- Use `ft-burn?` in conjunction with proper access controls.\n- Consider emitting events or logging burns for transparency.\n- Be cautious when burning tokens from a different principal than `tx-sender`.\n\n## Practical Example: Token Burning Mechanism\n\nLet's implement a simple token burning function:\n\n```clarity\n(define-fungible-token cBtc)\n\n(define-data-var tokenAdmin principal tx-sender)\n\n(define-public (burn-tokens (amount uint))\n  (ft-burn? cBtc amount tx-sender)\n)\n\n(define-public (burn-tokens-from (amount uint) (owner principal))\n  (begin\n    (asserts! (is-eq tx-sender (var-get tokenAdmin)) (err u3))\n    (ft-burn? cBtc amount owner)\n  )\n)\n```\n\nThis example demonstrates:\n1. Using `ft-burn?` to burn tokens from the transaction sender.\n2. Implementing an admin function to burn tokens from any account.\n3. Using assertions to ensure only the admin can burn tokens from other accounts.\n\n## Common Pitfalls\n\n1. Attempting to burn more tokens than the `sender` has in their balance.\n2. Not checking the return value of `ft-burn?` to handle potential errors.\n3. Allowing unauthorized burning of tokens from other accounts.\n4. Forgetting that burned tokens are permanently destroyed and cannot be recovered.\n\n## Related Functions\n\n- `ft-mint?`: Used to create new tokens, increasing the total supply.\n- `ft-transfer?`: Used to transfer tokens between principals.\n- `ft-get-balance`: Used to check the token balance of a principal.\n- `ft-get-supply`: Used to get the current total supply of tokens.\n\n## Conclusion\n\nThe `ft-burn?` function is a powerful tool for managing the supply of fungible tokens in Clarity smart contracts. It allows for the implementation of deflationary mechanisms and gives users the ability to destroy their own tokens. When used correctly, this function can be a key component in sophisticated tokenomics models. However, it should be used with caution and with proper checks to ensure the integrity of your token system.\n"
  },
  {
    "title": "get",
    "description": "Retrieve a value from a tuple in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/get",
    "content": "\n## Function Signature\n\n```clarity\n(get key-name tuple)\n```\n\n- Input: \n  - `key-name`: The name of the key in the tuple\n  - `tuple`: The tuple to retrieve the value from\n- Output: The value associated with the key in the tuple\n\n## Why it matters\n\nThe `get` function is crucial for:\n\n1. Accessing specific values within tuple data structures.\n2. Extracting information from complex data types in contracts.\n3. Enabling efficient data retrieval in contract logic.\n4. Working with structured data returned by other functions or stored in variables.\n\n## When to use it\n\nUse `get` when you need to:\n\n- Access a specific field in a tuple.\n- Extract values from structured data returned by other functions.\n- Work with complex data types in your contract logic.\n- Implement data processing that involves tuple manipulation.\n\n## Best Practices\n\n- Ensure the key exists in the tuple to avoid runtime errors.\n- Use meaningful key names for better code readability.\n- Consider using `get` in combination with `optional` for safer data access.\n- Be aware of the performance implications when working with large tuples.\n\n## Practical Example: User Profile Management\n\nLet's implement a simple user profile system using tuples and the `get` function:\n\n```clarity\n(define-map UserProfiles { userId: principal } { name: (string-ascii 50), age: uint })\n\n(define-public (set-profile (name (string-ascii 50)) (age uint))\n  (ok (map-set UserProfiles { userId: tx-sender } { name: name, age: age }))\n)\n\n(define-read-only (get-profile-name (user principal))\n  (match (map-get? UserProfiles { userId: user }) profile\n    (ok (get name profile))\n    (err u404)\n  )\n)\n\n(define-read-only (get-profile-age (user principal))\n  (match (map-get? UserProfiles { userId: user }) profile\n    (ok (get age profile))\n    (err u404)\n  )\n)\n\n;; Usage\n(set-profile \"Alice\" u30)\n(get-profile-name tx-sender) ;; Returns (ok \"Alice\")\n(get-profile-age tx-sender) ;; Returns (ok u30)\n```\n\nThis example demonstrates:\n1. Using `get` to retrieve specific fields from a tuple stored in a map.\n2. Implementing getter functions that use `get` to access tuple data.\n3. Handling cases where the profile might not exist.\n\n## Common Pitfalls\n\n1. Attempting to `get` a key that doesn't exist in the tuple, causing a runtime error.\n2. Forgetting that `get` is case-sensitive for key names.\n3. Not considering the performance impact of frequently accessing large tuples.\n\n## Related Functions\n\n- `merge`: Used to combine tuples, potentially creating new fields to `get`.\n- `tuple`: Used to create tuples that can be accessed with `get`.\n- `map-get?`: Often used in combination with `get` to retrieve data from maps.\n\n## Conclusion\n\nThe `get` function is a fundamental tool for working with tuples in Clarity smart contracts. It provides a straightforward way to access structured data, enabling developers to work with complex data types efficiently. When used effectively, `get` enhances the contract's ability to manage and process structured information, leading to more organized and maintainable smart contract code.\n"
  },
  {
    "title": "use-trait",
    "description": "Import and use traits from other contracts in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/use-trait",
    "content": "\n## Function Signature\n\n```clarity\n(use-trait trait-alias trait-identifier)\n```\n\n- Input: `VarName, TraitIdentifier`\n- Output: `Not Applicable`\n\n## Why it matters\n\nThe `use-trait` function is crucial for:\n\n1. Importing traits defined in other contracts.\n2. Implementing logic that requires conformance to specific interfaces.\n3. Ensuring code reusability and modularity by leveraging traits.\n4. Simplifying the process of using external traits in smart contracts.\n\n## When to use it\n\nUse `use-trait` when you need to:\n\n- Import traits defined in other contracts.\n- Implement logic that requires conformance to specific interfaces.\n- Ensure code reusability and modularity by leveraging traits.\n- Handle trait imports in your smart contract.\n\n## Best Practices\n\n- Use descriptive names for trait aliases for better readability.\n- Ensure the trait identifier is correctly formatted and valid.\n- Combine with other contract functions for comprehensive contract management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Importing and Using a Trait\n\nLet's implement a function that imports a trait and uses it in a contract:\n\n```clarity\n(use-trait token-trait 'SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR.token-trait)\n\n(define-public (forward-get-balance (user principal) (contract <token-trait>))\n  (ok (contract-of contract))\n)\n\n;; Usage\n(forward-get-balance tx-sender 'SP2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR.token-trait)\n;; Returns the principal of the contract implementing the token-trait\n```\n\nThis example demonstrates:\n1. Using `use-trait` to import a trait from another contract.\n2. Implementing a public function to use the imported trait.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `use-trait` with incorrectly formatted or invalid trait identifiers, causing runtime errors.\n2. Assuming the trait import will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete contract management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `contract-of`: Returns the principal of the contract implementing the trait.\n- `define-trait`: Defines a new trait in the current contract.\n- `impl-trait`: Implements a trait in the current contract.\n\n## Conclusion\n\nThe `use-trait` function is a fundamental tool for importing and using traits from other contracts in Clarity smart contracts. It allows you to implement logic that requires conformance to specific interfaces, ensuring code reusability and modularity. When used effectively, `use-trait` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle trait imports.\n"
  },
  {
    "title": "to-uint",
    "description": "Convert a signed integer to an unsigned integer in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/to-uint",
    "content": "\n## Function Signature\n\n```clarity\n(to-uint value)\n```\n\n- Input: `int`\n- Output: `uint`\n\n## Why it matters\n\nThe `to-uint` function is crucial for:\n\n1. Converting signed integers to unsigned integers.\n2. Implementing logic that requires unsigned integer operations.\n3. Ensuring data integrity by validating the conversion process.\n4. Simplifying the process of handling integer conversions in smart contracts.\n\n## When to use it\n\nUse `to-uint` when you need to:\n\n- Convert a signed integer to an unsigned integer.\n- Implement logic that requires unsigned integer operations.\n- Validate the conversion process to ensure data integrity.\n- Handle integer conversions in your smart contract.\n\n## Best Practices\n\n- Ensure the input value is non-negative to avoid runtime errors.\n- Use meaningful variable names for better readability.\n- Combine with other integer functions for comprehensive data management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Converting Signed Integer to Unsigned Integer\n\nLet's implement a function that converts a signed integer to an unsigned integer:\n\n```clarity\n(define-read-only (convert-to-uint (input int))\n  (to-uint input)\n)\n\n;; Usage\n(convert-to-uint 42) ;; Returns u42\n(convert-to-uint 0) ;; Returns u0\n(convert-to-uint -1) ;; Causes a runtime error\n```\n\nThis example demonstrates:\n1. Using `to-uint` to convert a signed integer to an unsigned integer.\n2. Implementing a public function to handle the conversion process.\n3. Handling both positive and zero input values.\n\n## Common Pitfalls\n\n1. Using `to-uint` with negative values, causing a runtime error.\n2. Assuming the conversion will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `to-int`: Converts an unsigned integer to a signed integer.\n- `int-to-ascii`: Converts an integer to a string-ascii representation.\n- `int-to-utf8`: Converts an integer to a string-utf8 representation.\n\n## Conclusion\n\nThe `to-uint` function is a fundamental tool for converting signed integers to unsigned integers in Clarity smart contracts. It allows you to implement logic that requires unsigned integer operations, ensuring data integrity and simplifying integer conversions. When used effectively, `to-uint` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle integer conversions.\n"
  },
  {
    "title": "define-trait",
    "description": "Define traits for interface-like behavior in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/define-trait",
    "content": "\n## Function Signature\n\n```clarity\n(define-trait trait-name ((func1-name (arg1-type arg2-type ...) (return-type)) ...))\n```\n\n- Input: \n  - `trait-name`: The name of the trait being defined\n  - `func1-name`: The name of a function in the trait\n  - `arg1-type, arg2-type, ...`: The types of the function's arguments\n  - `return-type`: The return type of the function\n- Output: Not applicable (definition statement)\n\n## Why it matters\n\nThe `define-trait` function is crucial for:\n\n1. Creating standardized interfaces for contracts to implement.\n2. Enabling polymorphic behavior in smart contract interactions.\n3. Facilitating contract composability and interoperability.\n4. Allowing for dynamic dispatch of contract calls based on traits.\n\n## When to use it\n\nUse `define-trait` when you need to:\n\n- Define a common interface that multiple contracts should adhere to.\n- Create a contract that can interact with any other contract implementing a specific trait.\n- Establish standards for token contracts or other common smart contract patterns.\n- Enable more flexible and modular smart contract architectures.\n\n## Best Practices\n\n- Use clear and descriptive names for traits and their functions.\n- Keep traits focused on a single responsibility or concept.\n- Consider creating traits for common patterns like token standards.\n- Use traits in combination with `use-trait` and `contract-call?` for dynamic contract interactions.\n\n## Practical Example: Token Trait\n\nLet's define a simple trait for a token contract:\n\n```clarity\n(define-trait token-trait\n  (\n    (transfer? (principal principal uint) (response bool uint))\n    (get-balance (principal) (response uint uint))\n    (get-token-uri () (response (optional (string-utf8 256)) uint))\n  )\n)\n```\n\nThis example demonstrates:\n1. Defining a trait with multiple functions.\n2. Specifying function signatures with argument types and return types.\n3. Using response types to handle success and failure cases.\n\n## Common Pitfalls\n\n1. Defining overly complex traits that are difficult for other contracts to implement.\n2. Forgetting that traits are not implementations, just interface definitions.\n3. Not considering backwards compatibility when updating traits in newer contract versions.\n\n## Related Functions\n\n- `use-trait`: Used to import trait definitions from other contracts.\n- `impl-trait`: Used to declare that a contract implements a specific trait.\n- `contract-call?`: Often used in combination with traits for dynamic contract calls.\n- `contract-of`: Used to get the principal of a contract implementing a trait.\n\n## Conclusion\n\nThe `define-trait` function is a powerful tool for creating standardized interfaces in Clarity smart contracts. By defining traits, you can create more modular, interoperable, and flexible smart contract ecosystems. Traits enable contracts to interact with each other in a predictable way, fostering the development of complex decentralized applications and standards within the Stacks ecosystem.\n"
  },
  {
    "title": "int-to-utf8",
    "description": "Convert integers to UTF-8 string representations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/int-to-utf8",
    "content": "\n## Function Signature\n\n```clarity\n(int-to-utf8 value)\n```\n\n\n\n\n- Input: `int | uint`\n- Output: `(string-utf8 40)`\n\n## Why it matters\n\nThe `int-to-utf8` function is crucial for:\n\n1. Converting integer values to their UTF-8 string representations.\n2. Facilitating the display and logging of numeric data in a more versatile encoding.\n3. Enabling the use of numeric values in contexts that require UTF-8 strings.\n4. Simplifying the process of creating human-readable outputs from numeric data.\n\n## When to use it\n\nUse `int-to-utf8` when you need to:\n\n- Convert an integer or unsigned integer to a UTF-8 string.\n- Display numeric values in a human-readable format.\n- Log or store numeric data as UTF-8 strings.\n- Prepare numeric data for concatenation with other UTF-8 strings.\n\n## Best Practices\n\n- Ensure the integer value is within the range that can be represented as a string.\n- Use meaningful variable names for better readability.\n- Combine with other string functions for more complex string manipulations.\n- Be aware of the maximum length of the resulting string (40 characters).\n\n## Practical Example: Logging a User's Balance\n\nLet's implement a function that logs a user's balance as a UTF-8 string:\n\n```clarity\n(define-map UserBalances { userId: principal } { balance: uint })\n\n(define-public (log-balance (user principal))\n  (let\n    (\n      (balance (default-to u0 (map-get? UserBalances { userId: user })))\n      (balanceStr (int-to-utf8 balance))\n    )\n    (print balanceStr)\n  )\n)\n\n;; Usage\n(map-set UserBalances { userId: tx-sender } { balance: u100 })\n(log-balance tx-sender) ;; Logs \"100\"\n```\n\n\n\n\nThis example demonstrates:\n1. Using `int-to-utf8` to convert a user's balance to a UTF-8 string.\n2. Logging the string representation of the balance using `print`.\n3. Handling the case where the user has no balance set.\n\n## Common Pitfalls\n\n1. Assuming the resulting string will always fit within 40 characters.\n2. Forgetting to handle cases where the integer value is not set or is zero.\n3. Using `int-to-utf8` in performance-critical sections without considering the overhead.\n4. Not combining with other string functions for more complex manipulations.\n\n## Related Functions\n\n- `print`: Used to log or display string values.\n- `concat`: Used to concatenate multiple strings.\n- `default-to`: Used to provide default values for optional types.\n\n## Conclusion\n\nThe `int-to-utf8` function is a powerful tool for converting integer values to their UTF-8 string representations in Clarity smart contracts. It enables you to create human-readable outputs from numeric data, facilitating logging, display, and storage of numeric values as strings. When used effectively, `int-to-utf8` enhances the readability and usability of numeric data within your smart contract code.\n"
  },
  {
    "title": "ok",
    "description": "Construct a successful response type in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/ok",
    "content": "\n## Function Signature\n\n```clarity\n(ok value)\n```\n\n- Input: `A`\n- Output: `(response A B)`\n\n## Why it matters\n\nThe `ok` function is crucial for:\n\n1. Constructing a successful response type.\n2. Indicating that a function executed successfully.\n3. Ensuring data integrity by clearly distinguishing between success and error states.\n4. Simplifying the process of handling function return values in smart contracts.\n\n## When to use it\n\nUse `ok` when you need to:\n\n- Construct a successful response type.\n- Indicate that a function executed successfully.\n- Clearly distinguish between success and error states.\n- Handle function return values in your smart contract.\n\n## Best Practices\n\n- Ensure the value passed to `ok` is the intended successful result.\n- Use meaningful variable names for better readability.\n- Combine with `err` for comprehensive response handling.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Returning a Successful Response\n\nLet's implement a function that returns a successful response with a value:\n\n```clarity\n(define-read-only (get-successful-response (value int))\n  (ok value)\n)\n\n;; Usage\n(get-successful-response 5) ;; Returns (ok 5)\n```\n\nThis example demonstrates:\n1. Using `ok` to construct a successful response type.\n2. Implementing a read-only function to return a successful response.\n3. Handling the successful response case.\n\n## Common Pitfalls\n\n1. Using `ok` with an incorrect or invalid value, causing unexpected behavior.\n2. Assuming the response will always be successful, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete response handling.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `err`: Constructs an error response type.\n- `match`: Handles different branches or cases for optional and response types.\n\n## Conclusion\n\nThe `ok` function is a fundamental tool for constructing successful response types in Clarity smart contracts. It allows you to indicate successful function execution, ensure data integrity, and simplify response handling. When used effectively, `ok` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle successful responses.\n"
  },
  {
    "title": "define-non-fungible-token",
    "description": "Define a new non-fungible token class in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/define-non-fungible-token",
    "content": "\n## Function Signature\n\n```clarity\n(define-non-fungible-token asset-name asset-identifier-type)\n```\n\n- Input: \n  - `asset-name`: The name of the non-fungible token class\n  - `asset-identifier-type`: The type of the unique identifier for each token\n- Output: Not applicable (definition statement)\n\n## Why it matters\n\nThe `define-non-fungible-token` function is crucial for:\n\n1. Creating new non-fungible token (NFT) classes within a smart contract.\n2. Establishing unique digital assets with individual identifiers.\n3. Implementing collectibles, digital art, or other unique token-based systems.\n4. Enabling NFT-related operations like minting, transferring, and ownership checks.\n\n## When to use it\n\nUse `define-non-fungible-token` when you need to:\n\n- Create a new NFT class for your smart contract or dApp.\n- Implement unique digital assets with distinct identifiers.\n- Establish a foundation for NFT-based features in your contract.\n- Create collectibles, digital art tokens, or other unique digital assets.\n\n## Best Practices\n\n- Place `define-non-fungible-token` at the top level of your contract, as it's a definition statement.\n- Choose an appropriate asset identifier type that ensures uniqueness for each token.\n- Use meaningful and descriptive names for your NFT classes.\n- Consider the scalability and gas costs associated with your chosen identifier type.\n\n## Practical Example: Simple Digital Art NFT\n\nLet's implement a basic digital art NFT system:\n\n```clarity\n(define-non-fungible-token SharkoBarko uint)\n\n(define-data-var index uint u0)\n\n(define-public (mint (who principal) (artwork-uri (string-utf8 256)))\n  (let\n    (\n      (tokenId (var-get index))\n    )\n    (try! (nft-mint? SharkoBarko tokenId who))\n    (var-set index (+ tokenId u1))\n    (ok tokenId)\n  )\n)\n\n(define-read-only (get-owner (tokenId uint))\n  (ok (nft-get-owner? SharkoBarko tokenId))\n)\n\n(define-public (transfer (tokenId uint) (sender principal) (recipient principal))\n  (begin\n    (asserts! (is-eq tx-sender sender) (err u403))\n    (nft-transfer? SharkoBarko tokenId sender recipient)\n  )\n)\n```\n\nThis example demonstrates:\n1. Using `define-non-fungible-token` to create a new NFT class for digital artwork.\n2. Implementing basic NFT operations like minting, checking ownership, and transferring.\n3. Using a simple incrementing integer as the token identifier.\n\n## Common Pitfalls\n\n1. Forgetting that each token in an NFT class must have a unique identifier.\n2. Not implementing proper access controls for minting and transferring operations.\n3. Choosing an identifier type that may lead to collisions or scalability issues.\n\n## Related Functions\n\n- `nft-mint?`: Used to create new tokens within the NFT class.\n- `nft-transfer?`: Used to transfer ownership of an NFT.\n- `nft-get-owner?`: Used to check the current owner of an NFT.\n- `nft-burn?`: Used to destroy an existing NFT.\n\n## Conclusion\n\nThe `define-non-fungible-token` function is a fundamental building block for creating NFT-based systems in Clarity smart contracts. It allows you to define custom non-fungible token classes with unique identifiers. When combined with other NFT-related functions, it enables the implementation of sophisticated systems for digital collectibles, art, and other unique digital assets on the Stacks blockchain.\n"
  },
  {
    "title": "ft-transfer?",
    "description": "Transfer fungible tokens between principals in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/ft-transfer",
    "content": "\n## Function Signature\n\n```clarity\n(ft-transfer? token-name amount sender recipient)\n```\n\n- Input: \n  - `token-name`: The name of the fungible token\n  - `amount`: The amount of tokens to transfer (uint)\n  - `sender`: The principal sending the tokens\n  - `recipient`: The principal receiving the tokens\n- Output: `(response bool uint)`\n\n## Why it matters\n\nThe `ft-transfer?` function is crucial for:\n\n1. Moving fungible tokens between different principals within a smart contract.\n2. Implementing token transfer functionality in decentralized applications.\n3. Enabling token-based transactions and interactions between users or contracts.\n4. Facilitating token economy mechanisms within smart contracts.\n\n## When to use it\n\nUse `ft-transfer?` when you need to:\n\n- Transfer tokens from one account to another.\n- Implement payment or reward systems using custom tokens.\n- Allow users to send tokens to each other within your dApp.\n- Move tokens as part of more complex contract operations.\n\n## Best Practices\n\n- Always check the return value to ensure the transfer was successful.\n- Implement proper access controls to prevent unauthorized transfers.\n- Consider using `asserts!` or `try!` to handle transfer failures gracefully.\n- Be aware that any principal can call this function, so add necessary guards.\n- Verify sender has sufficient balance before attempting a transfer.\n\n## Practical Example: Token Transfer Function\n\nLet's implement a public function for transferring tokens with some basic checks:\n\n```clarity\n(define-fungible-token cBtc)\n\n(define-public (transfer-tokens (amount uint) (recipient principal))\n  (let\n    (\n      (sender tx-sender)\n    )\n    (asserts! (not (is-eq sender recipient)) (err u2))\n    (asserts! (> amount u0) (err u3))\n    (match (ft-transfer? cBtc amount sender recipient)\n      success (ok success)\n      error (err error)\n    )\n  )\n)\n\n;; Usage\n(ft-mint? cBtc u100 tx-sender)\n(transfer-tokens u50 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (ok true)\n```\n\nThis example demonstrates:\n1. Using `ft-transfer?` within a public function to transfer tokens.\n2. Implementing basic checks for valid transfer conditions.\n3. Handling the response from `ft-transfer?` and propagating it to the caller.\n\n## Common Pitfalls\n\n1. Forgetting that `ft-transfer?` can be called by any principal, potentially leading to unauthorized transfers.\n2. Not handling all possible error cases returned by `ft-transfer?`.\n3. Attempting to transfer more tokens than the sender's balance.\n4. Using `ft-transfer?` with a token name that hasn't been defined in the contract.\n\n## Related Functions\n\n- `ft-mint?`: Used to create new tokens and assign them to a principal.\n- `ft-burn?`: Used to destroy tokens, reducing the balance of a principal.\n- `ft-get-balance`: Used to check the token balance of a principal.\n- `ft-get-supply`: Used to get the current total supply of tokens.\n\n## Conclusion\n\nThe `ft-transfer?` function is a fundamental component for implementing token transfers in Clarity smart contracts. It provides a straightforward way to move tokens between principals, enabling a wide range of token-based functionalities. When used with proper checks and balances, this function allows for the creation of secure and efficient token economies within decentralized applications on the Stacks blockchain.\n"
  },
  {
    "title": "is-err",
    "description": "Check if a response is an error in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/is-err",
    "content": "\n## Function Signature\n\n```clarity\n(is-err value)\n```\n\n- Input: `(response A B)`\n- Output: `bool`\n\n## Why it matters\n\nThe `is-err` function is crucial for:\n\n1. Determining if a response value represents an error.\n2. Implementing error handling and validation logic.\n3. Ensuring robust contract behavior by checking for errors.\n4. Simplifying conditional checks based on response types.\n\n## When to use it\n\nUse `is-err` when you need to:\n\n- Check if a response value is an error.\n- Implement conditional logic based on the success or failure of operations.\n- Validate the results of function calls that return response types.\n- Handle errors gracefully in your contract logic.\n\n## Best Practices\n\n- Use `is-err` in combination with `match` or `if` for comprehensive error handling.\n- Ensure that the response value being checked is of the correct type.\n- Use meaningful variable names for better readability.\n- Combine with other response handling functions like `is-ok` for complete validation.\n\n## Practical Example: Validating a Token Transfer\n\nLet's implement a function that validates a token transfer and checks for errors:\n\n```clarity\n(define-map UserBalances { userId: principal } { balance: uint })\n\n(define-public (transfer-tokens (amount uint) (recipient principal))\n  (let\n    (\n      (senderBalance (default-to u0 (map-get? UserBalances { userId: tx-sender })))\n      (recipientBalance (default-to u0 (map-get? UserBalances { userId: recipient })))\n      (transferResult (if (>= senderBalance amount)\n        (begin\n          (map-set UserBalances { userId: tx-sender } { balance: (- senderBalance amount) })\n          (map-set UserBalances { userId: recipient } { balance: (+ recipientBalance amount) })\n          (ok true)\n        )\n        (err u1)\n      ))\n    )\n    (if (is-err transferResult)\n      (err u2)\n      (ok true)\n    )\n  )\n)\n\n;; Usage\n(map-set UserBalances { userId: tx-sender } { balance: u100 })\n(transfer-tokens u50 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (ok true)\n(transfer-tokens u200 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (err u2)\n```\n\nThis example demonstrates:\n1. Using `is-err` to check if the token transfer operation resulted in an error.\n2. Implementing conditional logic based on the success or failure of the transfer.\n3. Handling both the success and error cases appropriately.\n\n## Common Pitfalls\n\n1. Assuming the response value is always of the correct type, leading to type errors.\n2. Not handling all possible error cases, resulting in incomplete error handling.\n3. Overlooking the need for comprehensive validation and error checking.\n4. Using `is-err` without meaningful error codes or messages, making debugging harder.\n\n## Related Functions\n\n- `is-ok`: Checks if a response value is `ok`.\n- `err`: Constructs an error response.\n- `ok`: Constructs a success response.\n\n## Conclusion\n\nThe `is-err` function is a fundamental tool for error handling in Clarity smart contracts. It allows you to check if a response value represents an error, enabling robust and comprehensive error handling and validation logic. When used effectively, `is-err` enhances the reliability and maintainability of your smart contract code by ensuring that errors are detected and handled appropriately.\n"
  },
  {
    "title": "ft-get-supply",
    "description": "Retrieve the total supply of a fungible token in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/ft-get-supply",
    "content": "\n## Function Signature\n\n```clarity\n(ft-get-supply token-name)\n```\n\n- Input: \n  - `token-name`: The name of the fungible token\n- Output: `uint`\n\n## Why it matters\n\nThe `ft-get-supply` function is crucial for:\n\n1. Querying the current total supply of a fungible token.\n2. Implementing supply-dependent logic in token contracts.\n3. Providing transparency about the token's circulating supply.\n4. Enabling other contracts or off-chain applications to verify token supply.\n\n## When to use it\n\nUse `ft-get-supply` when you need to:\n\n- Check the current total supply of a token.\n- Implement logic that depends on the token's supply (e.g., minting limits).\n- Provide supply information to users or other contracts.\n- Verify the integrity of token operations by checking supply changes.\n\n## Best Practices\n\n- Use `ft-get-supply` in combination with `ft-mint?` and `ft-burn?` to manage token supply.\n- Consider caching the supply result if queried frequently to optimize gas usage.\n- Be aware that the supply can change between checks due to minting or burning operations.\n- Use in conjunction with `ft-get-balance` for comprehensive token management.\n\n## Practical Example: Supply-Limited Minting\n\nLet's implement a function that mints tokens only if it doesn't exceed a certain supply cap:\n\n```clarity\n(define-fungible-token cBtc)\n(define-constant MAX_SUPPLY u1000000)\n\n(define-public (mint (amount uint) (recipient principal))\n  (let\n    (\n      (currentSupply (ft-get-supply cBtc))\n    )\n    (if (<= (+ currentSupply amount) MAX_SUPPLY)\n      (ft-mint? cBtc amount recipient)\n      (err u1)\n    )\n  )\n)\n\n;; Usage\n(mint u500000 tx-sender) ;; Returns (ok true)\n(ft-get-supply cBtc) ;; Returns u500000\n(mint u600000 tx-sender) ;; Returns (err u1)\n```\n\nThis example demonstrates:\n1. Using `ft-get-supply` to check the current token supply before minting.\n2. Implementing a supply cap check to limit token minting.\n3. Combining `ft-get-supply` with `ft-mint?` for supply management.\n\n## Common Pitfalls\n\n1. Assuming the supply remains constant between checks and operations.\n2. Not considering the potential for overflow when adding to the supply.\n3. Overusing `ft-get-supply` in loops, which can be inefficient for gas consumption.\n\n## Related Functions\n\n- `ft-mint?`: Used to create new tokens, increasing the total supply.\n- `ft-burn?`: Used to destroy tokens, decreasing the total supply.\n- `ft-get-balance`: Used to get the token balance of a specific principal.\n- `define-fungible-token`: Used to define the fungible token initially.\n\n## Conclusion\n\nThe `ft-get-supply` function is an essential tool for managing and querying the total supply of fungible tokens in Clarity smart contracts. It provides a straightforward way to access the current circulating supply, enabling you to implement supply-dependent logic and maintain transparency in token operations. When used effectively in combination with other token functions, this function ensures the integrity and accuracy of token supply management within your smart contracts.\n"
  },
  {
    "title": "as-max-len?",
    "description": "Use the as-max-len? function to check and limit sequence lengths in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/as-max-len",
    "content": "\n## Function Signature\n\n```clarity\n(as-max-len? sequence max_length)\n```\n\n- Input: \n  - `sequence`: A sequence of type A (list, buff, string-ascii, or string-utf8)\n  - `max_length`: A uint literal representing the maximum allowed length\n- Output: `(optional sequence_A)`\n\n## Why it matters\n\nThe `as-max-len?` function is crucial for:\n\n1. Enforcing length limits on sequences in smart contracts.\n2. Safely appending to lists or other sequences with maximum lengths.\n3. Validating input data before processing.\n4. Preventing potential overflow or excessive resource consumption.\n\n## When to use it\n\nUse the `as-max-len?` function when you need to:\n\n- Check if a sequence is within a specified maximum length.\n- Safely append to a list or other sequence with a known maximum length.\n- Validate user input or data from external sources.\n- Implement logic that depends on sequence length constraints.\n\n## Best Practices\n\n- Always use `as-max-len?` before appending to lists or other sequences with maximum lengths.\n- Combine with `unwrap!` or `unwrap-panic` when you're certain the length should be within limits.\n- Use meaningful error handling when the length check fails.\n- Consider the performance impact of frequent length checks in your contract logic.\n\n## Practical Example: Safe List Append\n\nLet's implement a function that safely appends to a list with a maximum length:\n\n```clarity\n(define-data-var myList (list 5 uint) (list))\n\n(define-public (safe-append (item uint))\n  (let\n    (\n      (newList (unwrap! (as-max-len? (append (var-get myList) item) u5) (err u1)))\n    )\n    (ok (var-set myList newList))\n  )\n)\n\n(define-read-only (get-list)\n  (var-get myList)\n)\n\n;; Usage\n(safe-append u1) ;; Returns (ok true)\n(safe-append u2) ;; Returns (ok true)\n(safe-append u3) ;; Returns (ok true)\n(safe-append u4) ;; Returns (ok true)\n(safe-append u5) ;; Returns (ok true)\n(safe-append u6) ;; Returns (err u1)\n\n(get-list) ;; Returns (list u1 u2 u3 u4 u5)\n```\n\nThis example demonstrates:\n1. Using `as-max-len?` to check if appending to the list would exceed the maximum length.\n2. Combining `as-max-len?` with `unwrap!` for concise error handling.\n3. Safely updating a list variable only if the length check passes.\n\n## Common Pitfalls\n\n1. Forgetting to use `as-max-len?` when appending to sequences with maximum lengths.\n2. Using a variable for the `max_length` parameter, which is not allowed (it must be a uint literal).\n3. Not handling the `none` case when `as-max-len?` returns an optional.\n\n## Related Functions\n\n- `append`: Used to add elements to lists.\n- `concat`: Used to join two sequences together.\n- `len`: Used to get the current length of a sequence.\n\n## Conclusion\n\nThe `as-max-len?` function is a critical tool for managing sequence lengths in Clarity smart contracts. By using it consistently, you can create more robust and secure contracts that properly handle length constraints, preventing potential vulnerabilities related to unbounded data growth or unexpected input sizes.\n"
  },
  {
    "title": "get-tenure-info?",
    "description": "Fetch information about Stacks tenures in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/get-tenure-info",
    "content": "\n## Function Signature\n\n\n```clarity\n(get-tenure-info? prop-name block-height)\n```\n\n- Input: \n  - `prop-name`: A TenureInfoPropertyName\n  - `block-height`: A uint representing the Stacks block height\n- Output: `(optional buff) | (optional uint) | (optional principal)` depending on the property\n\n## Why it matters\n\nThe `get-tenure-info?` function is essential for:\n\n1. Accessing historical tenure data within smart contracts\n2. Retrieving information about block miners and rewards\n3. Accessing VRF seeds for randomness-based applications\n4. Analyzing miner participation and spending patterns\n\n## When to use it\n\nUse `get-tenure-info?` when you need to:\n\n- Access tenure-specific data like VRF seeds or miner addresses\n- Verify tenure timestamps or burnchain information\n- Analyze block rewards and miner spending patterns\n- Implement logic that depends on historical tenure data\n\n## Best Practices\n\n- Always handle the `none` case, as it will be returned for non-existent or future blocks\n- Be aware that block rewards are only available after maturity (101 blocks on mainnet)\n- Consider the two-hour accuracy window when working with tenure timestamps\n- Cache frequently accessed tenure information to optimize execution costs\n\n## Practical Example: Checking Miner Spending\n\n```clarity\n(define-read-only (get-miner-spend-ratio (blockHeight uint)))\n(let\n  (\n    (winnerSpend (get-tenure-info? miner-spend-winner blockHeight))\n    (totalSpend (get-tenure-info? miner-spend-total blockHeight))\n  )\n  (match (tuple (winner winnerSpend) (total totalSpend))\n    success (some (/ (get success \"winner\") (get success \"total\")))\n    error none\n  )\n)\n```\n\n## Available Properties\n\n- `burnchain-header-hash`: Returns the burnchain block header hash (buff 32)\n- `miner-address`: Returns the tenure miner's principal\n- `time`: Returns the tenure time as Unix epoch timestamp (uint)\n- `vrf-seed`: Returns the VRF seed for the tenure (buff 32)\n- `block-reward`: Returns the total block reward (uint)\n- `miner-spend-total`: Returns total spent by all miners for this tenure (uint)\n- `miner-spend-winner`: Returns amount spent by winning miner (uint)\n\n## Common Pitfalls\n\n1. Not accounting for block reward maturity period (101 blocks)\n2. Relying on exact tenure times (accuracy window of two hours)\n3. Not handling the `none` case for invalid or future block heights\n\n## Related Functions\n\n- `get-block-info?`: Used to get information about Stacks blocks\n- `block-height`: Returns the current block height\n- `burn-block-height`: Returns the current burn chain block height\n\n## Conclusion\n\nThe `get-tenure-info?` function provides crucial access to historical tenure data in Clarity smart contracts. Introduced in Clarity 3, this function enables developers to access detailed information about past tenures, including miner participation, block rewards, and VRF seeds. When used properly, `get-tenure-info?` is a powerful tool for implementing sophisticated contract logic that depends on historical blockchain state.\n"
  },
  {
    "title": "bit-xor",
    "description": "Use the bit-xor function for bitwise exclusive OR operations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/bit-xor",
    "content": "\n## Function Signature\n\n```clarity\n(bit-xor i1 i2...)\n```\n\n- Input: Two or more integers (`int` or `uint`)\n- Output: An integer of the same type as the inputs (`int` or `uint`)\n\n## Why it matters\n\nThe `bit-xor` function is crucial for:\n\n1. Performing bitwise exclusive OR operations in smart contracts.\n2. Implementing certain cryptographic algorithms and hash functions.\n3. Creating toggle mechanisms for binary flags.\n4. Detecting changes between two bit patterns.\n\n## When to use it\n\nUse the `bit-xor` function when you need to:\n\n- Implement exclusive OR logic on binary data.\n- Toggle specific bits in a value without affecting others.\n- Compare two bit patterns to find differences.\n- Create simple encryption or hashing mechanisms.\n\n## Best Practices\n\n- Ensure all input values are of the same type (either all `int` or all `uint`).\n- Remember that `bit-xor` with 0 returns the original value, which can be useful for conditional operations.\n- Use `bit-xor` in combination with other bitwise operations for complex bit manipulations.\n- Consider the readability of your code when using bitwise operations extensively; add comments to explain the purpose.\n\n## Practical Example: Simple Toggle Mechanism\n\nLet's implement a simple toggle mechanism using `bit-xor`:\n\n```clarity\n(define-data-var flags uint u0)\n\n(define-read-only (get-flag (flagPosition uint))\n  (is-eq (bit-and (var-get flags) (bit-shift-left u1 flagPosition)) u0)\n)\n\n(define-public (toggle-flag (flagPosition uint))\n  (begin\n    (asserts! (< flagPosition u8) (err u1)) ;; Ensure flag position is valid\n    (ok (var-set flags (bit-xor (var-get flags) (bit-shift-left u1 flagPosition))))\n  )\n)\n\n;; Usage\n(toggle-flag u2) ;; Toggles the 3rd bit (position 2)\n(get-flag u2) ;; Returns false\n(toggle-flag u2) ;; Toggles the 3rd bit again (position 2)\n(get-flag u2) ;; Returns true\n```\n\nThis example demonstrates:\n1. Using `bit-xor` to toggle individual bits in a flags variable.\n2. Combining `bit-xor` with other bitwise operations like `bit-and` and `bit-shift-left`.\n3. Implementing a simple flag system using bitwise operations for efficient storage and manipulation.\n\n## Common Pitfalls\n\n1. Mixing signed (`int`) and unsigned (`uint`) integers in a single `bit-xor` operation.\n2. Forgetting that `bit-xor` of a value with itself always results in 0.\n3. Not considering the full range of bits when using `bit-xor` with smaller integer values.\n\n## Related Functions\n\n- `bit-and`: Used for bitwise AND operations.\n- `bit-or`: Used for bitwise OR operations.\n- `bit-not`: Used for bitwise NOT operations.\n- `bit-shift-left`: Often used in combination with `bit-xor` for flag operations.\n- `bit-shift-right`: Used for right-shifting bits.\n\n## Conclusion\n\nThe `bit-xor` function is a powerful tool for bitwise operations in Clarity smart contracts. When used in combination with other bitwise functions, it enables efficient implementation of toggles, flags, and other bit-level data manipulations. To avoid unexpected results, be mindful of the types of integers used and the effects of the operation on the full range of bits.\n"
  },
  {
    "title": "define-private",
    "description": "Define private functions in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/define-private",
    "content": "\n## Function Signature\n\n```clarity\n(define-private (function-name (arg-name-0 arg-type-0) ...) function-body)\n```\n\n- Input: \n  - `function-name`: The name of the private function\n  - `arg-name-N`: The name of each argument\n  - `arg-type-N`: The type of each argument\n  - `function-body`: The code to be executed when the function is called\n- Output: Not applicable (definition statement)\n\n## Why it matters\n\nThe `define-private` function is crucial for:\n\n1. Creating internal helper functions that are only accessible within the contract.\n2. Encapsulating logic that shouldn't be directly callable from outside the contract.\n3. Improving code organization and reusability within a contract.\n4. Implementing complex operations that are used by multiple public functions.\n\n## When to use it\n\nUse `define-private` when you need to:\n\n- Create utility functions that are used by multiple public functions.\n- Implement complex logic that needs to be hidden from external callers.\n- Break down large functions into smaller, more manageable pieces.\n- Improve the readability and maintainability of your contract.\n\n## Best Practices\n\n- Use descriptive names for private functions to clearly indicate their purpose.\n- Keep private functions focused on a single task or operation.\n- Use private functions to avoid code duplication within your contract.\n- Remember that private functions can return any type, not just response types.\n\n## Practical Example: Helper Function for Validation\n\nLet's implement a private function for input validation:\n\n```clarity\n(define-private (validate-amount (amount uint))\n  (and (> amount u0) (<= amount u1000000))\n)\n\n(define-public (transfer (recipient principal) (amount uint))\n  (if (validate-amount amount)\n    (begin\n      ;; Perform transfer logic here\n      (ok true)\n    )\n    (err u1)\n  )\n)\n```\n\nThis example demonstrates:\n1. Using `define-private` to create a helper function for input validation.\n2. Calling the private function from within a public function.\n3. Improving code readability by separating validation logic.\n\n## Common Pitfalls\n\n1. Attempting to call private functions from outside the contract, which is not allowed.\n2. Overusing private functions, leading to overly complex contract structure.\n3. Forgetting that private functions can modify contract state, which may lead to unexpected behavior if not carefully managed.\n\n## Related Functions\n\n- `define-public`: Used to define public functions that can be called from outside the contract.\n- `define-read-only`: Used to define public read-only functions that don't modify contract state.\n\n## Conclusion\n\nThe `define-private` function is a powerful tool for creating internal helper functions and encapsulating logic within Clarity smart contracts. By using private functions effectively, you can improve code organization, reduce duplication, and create more maintainable and secure smart contracts.\n"
  },
  {
    "title": "bit-or",
    "description": "Use the bit-or function for bitwise OR operations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/bit-or",
    "content": "\n## Function Signature\n\n```clarity\n(bit-or i1 i2...)\n```\n\n- Input: Two or more integers (`int` or `uint`)\n- Output: An integer of the same type as the inputs (`int` or `uint`)\n\n## Why it matters\n\nThe `bit-or` function is crucial for:\n\n1. Performing bitwise OR operations in smart contracts.\n2. Combining flags or bitmasks efficiently.\n3. Implementing certain logical operations and algorithms.\n4. Manipulating binary data at the bit level.\n\n## When to use it\n\nUse the `bit-or` function when you need to:\n\n- Combine multiple flags or bitmasks into a single value.\n- Set specific bits in an integer without affecting others.\n- Implement certain bitwise algorithms or data structures.\n- Perform low-level data manipulations involving binary operations.\n\n## Best Practices\n\n- Ensure all input values are of the same type (either all `int` or all `uint`).\n- Remember that `bit-or` with `0` has no effect, which can be useful for conditional operations.\n- Use `bit-or` in combination with other bitwise operations for complex bit manipulations.\n- Consider readability when using bitwise operations extensively; add comments to explain the purpose.\n\n## Practical Example: Permission System\n\nLet's implement a simple permission system using `bit-or` and other bitwise operations:\n\n```clarity\n(define-constant PERMISSION_READ u1)    ;; 0001\n(define-constant PERMISSION_WRITE u2)   ;; 0010\n(define-constant PERMISSION_EXECUTE u4) ;; 0100\n(define-constant PERMISSION_ADMIN u8)   ;; 1000\n\n(define-map UserPermissions principal uint)\n\n(define-public (grant-permission (user principal) (permission uint))\n  (let\n    (\n      (currentPermissions (default-to u0 (map-get? UserPermissions user)))\n    )\n    (ok (map-set UserPermissions user (bit-or currentPermissions permission)))\n  )\n)\n\n(define-public (revoke-permission (user principal) (permission uint))\n  (let\n    (\n      (currentPermissions (default-to u0 (map-get? UserPermissions user)))\n    )\n    (ok (map-set UserPermissions user (bit-and currentPermissions (bit-not permission))))\n  )\n)\n\n(define-read-only (has-permission (user principal) (permission uint))\n  (let\n    (\n      (userPermission (default-to u0 (map-get? UserPermissions user)))\n    )\n    (is-eq permission (bit-and userPermission permission))\n  )\n)\n\n;; Usage\n(grant-permission tx-sender (bit-or PERMISSION_READ PERMISSION_WRITE))\n(has-permission tx-sender PERMISSION_READ) ;; Returns true\n(has-permission tx-sender PERMISSION_EXECUTE) ;; Returns false\n```\n\n\n\nThis example demonstrates:\n1. Using `bit-or` to combine multiple permissions into a single value.\n2. Implementing a permission system using bitwise operations for efficient storage and checks.\n3. Combining `bit-or` with other bitwise operations like `bit-and` and `bit-not` for complex permission management.\n\n## Common Pitfalls\n\n1. Mixing signed (`int`) and unsigned (`uint`) integers in a single `bit-or` operation.\n2. Forgetting that `bit-or` with all bits set (`-1` for `int`, maximum value for `uint`) always results in all bits set.\n3. Not considering the full range of bits when using `bit-or` with smaller integer values.\n\n## Related Functions\n\n- `bit-and`: Used for bitwise AND operations.\n- `bit-xor`: Used for bitwise XOR operations.\n- `bit-not`: Used for bitwise NOT operations.\n- `bit-shift-left`: Used for left-shifting bits.\n- `bit-shift-right`: Used for right-shifting bits.\n\n## Conclusion\n\nThe `bit-or` function is a powerful tool for bitwise operations in Clarity smart contracts. When used in combination with other bitwise functions, this function enables efficient implementation of flags, permissions, and other bit-level data manipulations. However, be mindful of the types of integers used and the effects of the operation on the full range of bits to avoid unexpected results.\n"
  },
  {
    "title": "var-get",
    "description": "Retrieve the value of a data variable in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/var-get",
    "content": "\n## Function Signature\n\n```clarity\n(var-get var-name)\n```\n\n- Input: `VarName`\n- Output: `A`\n\n## Why it matters\n\nThe `var-get` function is crucial for:\n\n1. Retrieving the value of a data variable.\n2. Implementing logic that requires accessing stored data.\n3. Ensuring data integrity by validating the retrieval process.\n4. Simplifying the process of handling data variables in smart contracts.\n\n## When to use it\n\nUse `var-get` when you need to:\n\n- Retrieve the value of a data variable.\n- Implement logic that requires accessing stored data.\n- Validate the retrieval process to ensure data integrity.\n- Handle data variables in your smart contract.\n\n## Best Practices\n\n- Ensure the variable name is correctly formatted and valid.\n- Use meaningful variable names for better readability.\n- Combine with other data functions for comprehensive data management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Retrieving a Data Variable\n\n```clarity\n(define-data-var cursor int 6)\n\n(define-public (get-cursor)\n  (ok (var-get cursor))\n)\n\n;; Usage\n(get-cursor) ;; Returns (ok 6)\n```\n\nThis example demonstrates:\n1. Using `var-get` to retrieve the value of a data variable.\n2. Implementing a public function to handle the retrieval process.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `var-get` with incorrectly formatted or invalid variable names, causing runtime errors.\n2. Assuming the retrieval will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `var-set`: Sets the value of a data variable.\n- `map-get?`: Retrieves a value from a map.\n- `default-to`: Provides a default value if an optional is `none`.\n\n## Conclusion\n\nThe `var-get` function is a fundamental tool for retrieving the value of a data variable in Clarity smart contracts. It allows you to implement logic that requires accessing stored data, ensuring data integrity and simplifying the retrieval process. When used effectively, `var-get` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle data variables.\n"
  },
  {
    "title": "map-set",
    "description": "Set an entry in a map in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/map-set",
    "content": "\n## Function Signature\n\n```clarity\n(map-set map-name key-tuple value-tuple)\n```\n\n- Input: `MapName, tuple_A, tuple_B`\n- Output: `bool`\n\n## Why it matters\n\nThe `map-set` function is crucial for:\n\n1. Setting or updating entries in a map.\n2. Managing and updating the state of data stored in maps.\n3. Ensuring data integrity by allowing updates to existing entries.\n4. Simplifying the process of maintaining accurate data in smart contracts.\n\n## When to use it\n\nUse `map-set` when you need to:\n\n- Set or update an entry in a map.\n- Manage and update the state of data stored in maps.\n- Ensure data integrity by updating existing entries.\n- Maintain accurate data in your smart contract.\n\n## Best Practices\n\n- Ensure the key-tuple and value-tuple are correctly formatted.\n- Use meaningful variable names for better readability.\n- Combine with other map functions for comprehensive map management.\n- Be aware of the performance implications of frequent updates in large maps.\n\n## Practical Example: Setting User Data\n\nLet's implement a function that sets a user's data in a map:\n\n```clarity\n(define-map UserData { userId: principal } { data: (buff 32) })\n\n(define-public (set-user-data (user principal) (data (buff 32)))\n  (ok (map-set UserData { userId: user } { data: data }))\n)\n\n;; Usage\n(set-user-data tx-sender 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef) ;; Returns (ok true)\n(set-user-data tx-sender 0xabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdef) ;; Returns (ok true)\n```\n\nThis example demonstrates:\n1. Using `map-set` to set a user's data in the `UserData` map.\n2. Implementing a public function to set the data.\n3. Handling both the case where the entry is newly created and where it is updated.\n\n## Common Pitfalls\n\n1. Using `map-set` with incorrectly formatted tuples, causing the operation to fail.\n2. Assuming the entry will always be updated, leading to unhandled cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `map-insert`: Inserts a value into a map if the key does not already exist.\n- `map-delete`: Removes an entry from a map.\n- `map-get?`: Retrieves an entry from a map.\n\n## Conclusion\n\nThe `map-set` function is a fundamental tool for setting or updating entries in maps in Clarity smart contracts. It allows you to manage data, ensure data integrity, and maintain accurate data. When used effectively, `map-set` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage map entries.\n"
  },
  {
    "title": "buff-to-uint-be",
    "description": "Convert a byte buffer to an unsigned integer using big-endian encoding in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/buff-to-uint-be",
    "content": "\n## Function Signature\n\n```clarity\n(buff-to-uint-be (buff 16))\n```\n\n- Input: A byte buffer of up to 16 bytes\n- Output: An unsigned integer (`uint`)\n\n## Why it matters\n\nThe `buff-to-uint-be` function is crucial for:\n\n1. Converting byte data to unsigned integers using big-endian encoding.\n2. Handling data from external sources or other contracts that use big-endian encoding.\n3. Implementing protocols or algorithms that require big-endian integer representation.\n4. Interoperating with systems that use big-endian byte order.\n\n## When to use it\n\nUse the `buff-to-uint-be` function when you need to:\n\n- Convert a big-endian encoded byte buffer to an unsigned integer.\n- Process input data that represents unsigned integers in big-endian format.\n- Implement cryptographic or mathematical operations that expect big-endian integer inputs.\n- Ensure compatibility with external systems using big-endian encoding.\n\n## Best Practices\n\n- Ensure the input buffer is no larger than 16 bytes to avoid errors.\n- Be aware that smaller buffers are zero-padded on the left, affecting the resulting integer value.\n- Use `buff-to-int-be` if you need to handle signed integers instead.\n- Handle potential errors when the input buffer might be invalid or empty.\n\n## Practical Example: Decoding an Unsigned Integer from External Data\n\nLet's implement a function that processes external data containing a big-endian encoded unsigned integer:\n\n```clarity\n(define-read-only (process-external-data (data (buff 16)))\n  (let\n    (\n      (value (buff-to-uint-be data))\n    )\n    (if (> value u1000000)\n      (err \"Value too large\")\n      (ok value)\n    )\n  )\n)\n\n;; Usage\n(process-external-data 0x00000001) ;; Returns (ok u1)\n(process-external-data 0x000f4240) ;; Returns (ok u1000000)\n(process-external-data 0x00989680) ;; Returns (err \"Value too large\")\n```\n\nThis example demonstrates:\n1. Using `buff-to-uint-be` to convert external data to an unsigned integer.\n2. Implementing input validation based on the converted integer value.\n3. Handling different input sizes and values.\n\n## Common Pitfalls\n\n1. Forgetting that the function interprets the input as big-endian, which might lead to unexpected values if the data is actually little-endian.\n2. Not considering the full range of possible uint values when processing the result.\n3. Assuming a specific buffer length, which could lead to unexpected results with shorter inputs due to left-padding.\n\n## Related Functions\n\n- `buff-to-uint-le`: Converts a byte buffer to an unsigned integer using little-endian encoding.\n- `buff-to-int-be`: Converts a byte buffer to a signed integer using big-endian encoding.\n- `uint-to-buff`: Converts an unsigned integer to a byte buffer.\n\n## Conclusion\n\nThe `buff-to-uint-be` function is a powerful tool for working with big-endian encoded unsigned integers in Clarity smart contracts. By understanding its behavior with different input sizes and potential edge cases, you can effectively process and validate external data, implement complex algorithms, and ensure compatibility with big-endian systems in your smart contract applications.\n"
  },
  {
    "title": "define-read-only",
    "description": "Define public read-only functions in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/define-read-only",
    "content": "\n## Function Signature\n\n```clarity\n(define-read-only (function-name (arg-name-0 arg-type-0) ...) function-body)\n```\n\n- Input: \n  - `function-name`: The name of the read-only function\n  - `arg-name-N`: The name of each argument\n  - `arg-type-N`: The type of each argument\n  - `function-body`: The code to be executed when the function is called\n- Output: Not applicable (definition statement)\n\n## Why it matters\n\nThe `define-read-only` function is crucial for:\n\n1. Creating public functions that can query contract state without modifying it.\n2. Enabling efficient and gas-optimized read operations on the contract.\n3. Implementing view functions that other contracts or off-chain applications can call.\n4. Providing a safe way to expose contract data without risking state changes.\n\n## When to use it\n\nUse `define-read-only` when you need to:\n\n- Create functions that return contract state or computed values.\n- Implement getter functions for contract variables or complex data structures.\n- Provide public interfaces for querying contract data without modifying state.\n- Create helper functions that other contracts can call without incurring state change costs.\n\n## Best Practices\n\n- Use descriptive names for read-only functions to clearly indicate their purpose.\n- Ensure that read-only functions do not attempt to modify contract state.\n- Utilize read-only functions for complex calculations that don't require state changes.\n- Consider using read-only functions in combination with public functions to separate read and write operations.\n\n## Practical Example: Token Balance Checker\n\nLet's implement a read-only function for checking token balances:\n\n```clarity\n(define-map Balances principal uint)\n\n(define-read-only (get-balance (account principal))\n  (default-to u0 (map-get? Balances account))\n)\n```\n\nThis example demonstrates:\n1. Using `define-read-only` to create functions for querying token balances.\n2. Implementing a getter function for individual account balances.\n\n## Common Pitfalls\n\n1. Attempting to modify contract state within a read-only function, which will cause an error.\n2. Overusing read-only functions for complex calculations that might be better suited for off-chain computation.\n3. Forgetting that read-only functions can still consume gas when called, even though they don't modify state.\n\n## Related Functions\n\n- `define-public`: Used to define public functions that can modify contract state.\n- `define-private`: Used to define private functions that can only be called within the contract.\n- `map-get?`: Often used within read-only functions to retrieve data from maps.\n\n## Conclusion\n\nThe `define-read-only` function is an essential tool for creating efficient and safe query interfaces in Clarity smart contracts. By providing a way to expose contract data and perform calculations without modifying state, read-only functions enable you to create more transparent and gas-efficient contracts. When used effectively, this function can significantly enhance the usability and accessibility of smart contract data for both on-chain and off-chain applications.\n"
  },
  {
    "title": "nft-burn?",
    "description": "Burn a non-fungible token (NFT) in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/nft-burn",
    "content": "\n## Function Signature\n\n```clarity\n(nft-burn? asset-class asset-identifier sender)\n```\n\n- Input: `AssetName, A, principal`\n- Output: `(response bool uint)`\n\n## Why it matters\n\nThe `nft-burn?` function is crucial for:\n\n1. Reducing the circulating supply of a non-fungible token (NFT).\n2. Managing the lifecycle of NFTs by allowing their destruction.\n3. Ensuring data integrity by removing ownership records of burned NFTs.\n4. Simplifying the process of handling NFT burn operations in smart contracts.\n\n## When to use it\n\nUse `nft-burn?` when you need to:\n\n- Reduce the circulating supply of an NFT.\n- Manage the lifecycle of NFTs by allowing their destruction.\n- Remove ownership records of burned NFTs.\n- Handle NFT burn operations in your smart contract.\n\n## Best Practices\n\n- Ensure the `sender` principal owns the NFT before attempting to burn it.\n- Use meaningful variable names for better readability.\n- Combine with other NFT functions for comprehensive NFT management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Burning an NFT\n\nLet's implement a function that burns an NFT owned by the sender:\n\n```clarity\n(define-non-fungible-token Stackaroo (string-ascii 40))\n\n(define-public (burn-nft (id (string-ascii 40)))\n  (nft-burn? Stackaroo id tx-sender)\n)\n\n;; Usage\n(nft-mint? Stackaroo \"Roo\" tx-sender) ;; Returns (ok true)\n(burn-nft \"Roo\") ;; Returns (ok true)\n(nft-burn? Stackaroo \"Roo\" tx-sender) ;; Returns (err u3) because the asset no longer exists\n```\n\nThis example demonstrates:\n1. Using `nft-burn?` to burn an NFT owned by the sender.\n2. Implementing a public function to handle the burn operation.\n3. Handling both the successful burn and the case where the asset no longer exists.\n\n## Common Pitfalls\n\n1. Using `nft-burn?` without ensuring the `sender` owns the NFT, causing the operation to fail.\n2. Assuming the NFT will always exist, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete NFT management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `nft-mint?`: Mints a new non-fungible token.\n- `nft-transfer?`: Transfers ownership of a non-fungible token.\n- `nft-get-owner?`: Retrieves the owner of a non-fungible token.\n\n## Conclusion\n\nThe `nft-burn?` function is a fundamental tool for managing the lifecycle of non-fungible tokens in Clarity smart contracts. It allows you to reduce the circulating supply of NFTs, manage their destruction, and ensure data integrity. When used effectively, `nft-burn?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle NFT burn operations.\n"
  },
  {
    "title": "is-ok",
    "description": "Check if a response is ok in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/is-ok",
    "content": "\n## Function Signature\n\n```clarity\n(is-ok value)\n```\n\n- Input: `(response A B)`\n- Output: `bool`\n\n## Why it matters\n\nThe `is-ok` function is crucial for:\n\n1. Determining if a response value represents a successful operation.\n2. Implementing conditional logic based on the success or failure of operations.\n3. Ensuring robust contract behavior by checking for successful responses.\n4. Simplifying checks for response types in smart contract code.\n\n## When to use it\n\nUse `is-ok` when you need to:\n\n- Check if a response value is `ok`.\n- Implement logic that depends on the success of operations.\n- Validate the results of function calls that return response types.\n- Handle success cases gracefully in your contract logic.\n\n## Best Practices\n\n- Use `is-ok` in combination with `match` or `if` for comprehensive response handling.\n- Ensure that the response value being checked is of the correct type.\n- Use meaningful variable names for better readability.\n- Combine with other response handling functions like `is-err` for complete validation.\n\n## Practical Example: Validating a Token Transfer\n\nLet's implement a function that validates a token transfer and checks for success:\n\n```clarity\n(define-map UserBalances { userId: principal } { balance: uint })\n\n(define-public (transfer-tokens (amount uint) (recipient principal))\n  (let\n    (\n      (senderBalance (default-to u0 (map-get? UserBalances { userId: tx-sender })))\n      (recipientBalance (default-to u0 (map-get? UserBalances { userId: recipient })))\n      (transferResult (if (>= senderBalance amount)\n        (begin\n          (map-set UserBalances { userId: tx-sender } { balance: (- senderBalance amount) })\n          (map-set UserBalances { userId: recipient } { balance: (+ recipientBalance amount) })\n          (ok true)\n        )\n        (err u1)\n      ))\n    )\n    (if (is-ok transferResult)\n      (ok true)\n      (err u2)\n    )\n  )\n)\n\n;; Usage\n(map-set UserBalances { userId: tx-sender } { balance: u100 })\n(transfer-tokens u50 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (ok true)\n(transfer-tokens u200 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (err u2)\n```\n\nThis example demonstrates:\n1. Using `is-ok` to check if the token transfer operation was successful.\n2. Implementing conditional logic based on the success of the transfer.\n3. Handling both the success and error cases appropriately.\n\n## Common Pitfalls\n\n1. Assuming the response value is always of the correct type, leading to type errors.\n2. Not handling all possible success and error cases, resulting in incomplete response handling.\n3. Overlooking the need for comprehensive validation and error checking.\n4. Using `is-ok` without meaningful success codes or messages, making debugging harder.\n\n## Related Functions\n\n- `is-err`: Checks if a response value is `err`.\n- `err`: Constructs an error response.\n- `ok`: Constructs a success response.\n\n## Conclusion\n\nThe `is-ok` function is a fundamental tool for checking response values in Clarity smart contracts. It allows you to determine if a response value represents a successful operation, enabling robust and comprehensive response handling and validation logic. When used effectively, `is-ok` enhances the reliability and maintainability of your smart contract code by ensuring that successful operations are detected and handled appropriately.\n"
  },
  {
    "title": "add",
    "description": "Use the addition function for arithmetic operations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/add",
    "content": "\nThe addition function (`+`) in Clarity performs addition on a variable number of integer inputs. It's a fundamental arithmetic operation used in many smart contract calculations.\n\n## Function Signature\n\n```clarity\n(+ i1 i2...)\n```\n\n- Input: Two or more integers (int or uint)\n- Output: A single integer (int or uint)\n\n## Why it matters\n\nThe addition function is crucial for:\n\n1. Performing basic arithmetic calculations within smart contracts.\n2. Incrementing counters or values.\n3. Combining multiple quantities or balances.\n4. Implementing mathematical formulas that involve addition.\n\n## When to use it\n\nUse the addition function when you need to:\n\n- Perform basic addition in your contract logic.\n- Increment values or counters.\n- Sum up multiple values.\n- Implement mathematical formulas that involve addition.\n\n## Best Practices\n\n- Always consider the possibility of overflow when adding large numbers.\n- Use appropriate types (int or uint) based on your needs and expected value ranges.\n- Be aware that adding negative numbers to positive numbers can result in subtraction.\n- Consider using checked arithmetic functions if overflow detection is critical.\n\n## Practical Example: Simple Counter\n\nLet's implement a simple counter that uses the addition function to increment its value:\n\n```clarity\n(define-data-var counter int 0)\n\n(define-public (increment-counter (amount int))\n  (begin\n    (var-set counter (+ (var-get counter) amount))\n    (ok (var-get counter))\n  )\n)\n\n;; Usage\n(increment-counter 1) ;; Increments the counter by 1\n(increment-counter 5) ;; Increments the counter by 5\n```\n\nThis example demonstrates:\n1. Using addition to increment the value of a counter.\n2. Implementing a public function to handle the increment operation.\n3. Returning the updated counter value.\n\n## Common Pitfalls\n\n1. Overlooking potential overflow when adding large numbers.\n2. Not considering the effect of adding negative numbers (for int types).\n3. Forgetting to update related variables or state when incrementing values.\n\n## Related Functions\n\n- `-`: Used for subtraction operations.\n- `*`: Used for multiplication operations.\n- `/`: Used for division operations.\n\n## Conclusion\n\nThe addition function is a fundamental tool for performing arithmetic operations in Clarity smart contracts. By understanding its behavior with different types of inputs and potential edge cases, you can use it effectively to implement various mathematical operations in your contracts, from simple increments to more complex calculations.\n"
  },
  {
    "title": "string-to-int?",
    "description": "Convert a string to an optional integer in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/string-to-int",
    "content": "\n## Function Signature\n\n```clarity\n(string-to-int? string)\n```\n\n- Input: `(string-ascii 1048576) | (string-utf8 262144)`\n- Output: `(optional int)`\n\n## Why it matters\n\nThe `string-to-int?` function is crucial for:\n\n1. Converting string representations of numbers to integers.\n2. Implementing logic that requires numeric values from string inputs.\n3. Ensuring data integrity by validating string-to-integer conversions.\n4. Simplifying the process of handling numeric conversions in smart contracts.\n\n## When to use it\n\nUse `string-to-int?` when you need to:\n\n- Convert a string representation of a number to an integer.\n- Implement logic that requires numeric values from string inputs.\n- Validate string-to-integer conversions to ensure data integrity.\n- Handle numeric conversions in your smart contract.\n\n## Best Practices\n\n- Ensure the input string is correctly formatted and represents a valid integer.\n- Use meaningful variable names for better readability.\n- Combine with other string and numeric functions for comprehensive data management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Converting a String to an Integer\n\nLet's implement a function that converts a string to an optional integer:\n\n```clarity\n(define-read-only (convert-string-to-int (input (string-ascii 20)))\n  (string-to-int? input)\n)\n\n;; Usage\n(convert-string-to-int \"123\") ;; Returns (some 123)\n(convert-string-to-int \"-456\") ;; Returns (some -456)\n(convert-string-to-int \"abc\") ;; Returns none\n```\n\nThis example demonstrates:\n1. Using `string-to-int?` to convert a string to an optional integer.\n2. Implementing a public function to handle the string-to-integer conversion.\n3. Handling both valid and invalid string inputs.\n\n## Common Pitfalls\n\n1. Using `string-to-int?` with incorrectly formatted or invalid string inputs, causing the operation to return `none`.\n2. Assuming the conversion will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `string-to-uint?`: Converts a string to an optional unsigned integer.\n- `int-to-ascii`: Converts an integer to a string-ascii representation.\n- `int-to-utf8`: Converts an integer to a string-utf8 representation.\n\n## Conclusion\n\nThe `string-to-int?` function is a fundamental tool for converting string representations of numbers to integers in Clarity smart contracts. It allows you to implement logic that requires numeric values from string inputs, ensuring data integrity and simplifying numeric conversions. When used effectively, `string-to-int?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle string-to-integer conversions.\n"
  },
  {
    "title": "is-none",
    "description": "Check if an optional value is none in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/is-none",
    "content": "\n## Function Signature\n\n```clarity\n(is-none value)\n```\n\n- Input: `(optional A)`\n- Output: `bool`\n\n## Why it matters\n\nThe `is-none` function is crucial for:\n\n1. Determining if an optional value is `none`.\n2. Implementing conditional logic based on the presence or absence of values.\n3. Ensuring robust contract behavior by checking for missing values.\n4. Simplifying checks for optional values in smart contract code.\n\n## When to use it\n\nUse `is-none` when you need to:\n\n- Check if an optional value is `none`.\n- Implement logic that depends on whether a value is present or absent.\n- Validate the results of function calls that return optional types.\n- Handle cases where values might be missing or not set.\n\n## Best Practices\n\n- Use `is-none` in combination with `match` or `if` for comprehensive value handling.\n- Ensure that the value being checked is of the correct optional type.\n- Use meaningful variable names for better readability.\n- Combine with other optional handling functions like `is-some` for complete validation.\n\n## Practical Example: Checking for Missing User Data\n\nLet's implement a function that checks if a user's profile data is missing:\n\n```clarity\n(define-map UserProfiles { userId: principal } { name: (string-ascii 50), age: uint })\n\n(define-read-only (is-profile-missing (user principal))\n  (is-none (map-get? UserProfiles { userId: user }))\n)\n\n;; Usage\n(map-set UserProfiles { userId: tx-sender } { name: \"Alice\", age: u30 })\n(is-profile-missing tx-sender) ;; Returns false\n(is-profile-missing 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns true\n```\n\nThis example demonstrates:\n1. Using `is-none` to check if a user's profile data is missing.\n2. Implementing a read-only function to determine the presence of user data.\n3. Handling both the case where the profile data is present and where it is missing.\n\n## Common Pitfalls\n\n1. Assuming the value will always be `some`, leading to unhandled `none` cases.\n2. Using `is-none` on non-optional types, causing type errors.\n3. Not handling all possible conditions, resulting in incomplete value checks.\n4. Overlooking the need for comprehensive validation and error checking.\n\n## Related Functions\n\n- `is-some`: Checks if an optional value is `some`.\n- `match`: Used for pattern matching and handling multiple conditions.\n- `default-to`: Provides default values for optional types.\n\n## Conclusion\n\nThe `is-none` function is a fundamental tool for checking optional values in Clarity smart contracts. It allows you to determine if a value is `none`, enabling robust and comprehensive value handling and validation logic. When used effectively, `is-none` enhances the reliability and maintainability of your smart contract code by ensuring that missing values are detected and handled appropriately.\n"
  },
  {
    "title": "subtract",
    "description": "Use the subtraction function for arithmetic operations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/subtract",
    "content": "\nThe subtraction function (`-`) in Clarity performs subtraction on a variable number of integer inputs. It's a fundamental arithmetic operation used in many smart contract calculations.\n\n## Function Signature\n\n```clarity\n(- i1 i2...)\n```\n\n- Input: Two or more integers (int or uint)\n- Output: A single integer (int or uint)\n\n## Why it matters\n\nThe subtraction function is crucial for:\n\n1. Performing basic arithmetic calculations within smart contracts.\n2. Decreasing values or counters.\n3. Calculating differences between quantities.\n4. Implementing mathematical formulas that involve subtraction.\n\n## When to use it\n\nUse the subtraction function when you need to:\n\n- Perform basic subtraction in your contract logic.\n- Decrement values or counters.\n- Calculate the difference between two or more values.\n- Implement mathematical formulas that involve subtraction.\n\n## Best Practices\n\n- Always consider the possibility of underflow when subtracting from small numbers.\n- Use appropriate types (int or uint) based on your needs and expected value ranges.\n- Be aware that subtracting a negative number results in addition.\n- Consider using checked arithmetic functions if underflow detection is critical.\n\n## Practical Example: Simple Escrow Contract\n\nLet's implement a basic escrow contract that uses subtraction to manage balances:\n\n```clarity\n;; Define constants\n(define-constant ESCROW_FEE u100)  ;; 100 tokens as escrow fee\n\n;; Define data variables\n(define-map Balances principal uint)\n(define-data-var escrowBalance uint u0)\n\n;; Function to deposit funds\n(define-public (deposit (amount uint))\n  (let\n    (\n      (currentBalance (default-to u0 (map-get? Balances tx-sender)))\n    )\n    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))\n    (map-set Balances tx-sender (+ currentBalance amount))\n    (ok true)\n  )\n)\n\n;; Function to initiate escrow\n(define-public (start-escrow (recipient principal) (amount uint))\n  (let\n    (\n      (senderBalance (default-to u0 (map-get? Balances tx-sender)))\n    )\n    (asserts! (>= senderBalance (+ amount ESCROW_FEE)) (err u1))\n    (map-set Balances tx-sender (- senderBalance (+ amount ESCROW_FEE)))\n    (var-set escrowBalance (+ (var-get escrowBalance) amount))\n    (ok true)\n  )\n)\n\n;; Function to complete escrow and transfer funds\n(define-public (complete-escrow (recipient principal) (amount uint))\n  (let\n    (\n      (escrowAmount (var-get escrowBalance))\n    )\n    (asserts! (>= escrowAmount amount) (err u2))\n    (try! (as-contract (stx-transfer? amount tx-sender recipient)))\n    (var-set escrowBalance (- escrowAmount amount))\n    (ok true)\n  )\n)\n```\n\nThis example demonstrates:\n1. Using subtraction to update `Balances` when initiating an escrow.\n2. Using subtraction to update the escrow balance when completing a transfer.\n3. Combining subtraction with addition to handle fees and balance updates.\n\n## Common Pitfalls\n\n1. Overlooking potential underflow when subtracting from small numbers.\n2. Not considering the effect of subtracting negative numbers (for int types).\n3. Forgetting to update related variables or state when decrementing values.\n\n## Related Functions\n\n- `+`: Used for addition operations.\n- `*`: Used for multiplication operations.\n- `/`: Used for division operations.\n\n## Conclusion\n\nThe subtraction function is a fundamental tool for performing arithmetic operations in Clarity smart contracts. By understanding its behavior with different types of inputs and potential edge cases, you can use it effectively to implement various mathematical operations in your contracts, from simple decrements to more complex financial calculations.\n"
  },
  {
    "title": "principal-destruct?",
    "description": "Decompose a principal into its components in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/principal-destruct",
    "content": "\n## Function Signature\n\n```clarity\n(principal-destruct? principal-address)\n```\n\n- Input: `principal`\n- Output: `(response (tuple (hash-bytes (buff 20)) (name (optional (string-ascii 40))) (version (buff 1))) (tuple (hash-bytes (buff 20)) (name (optional (string-ascii 40))) (version (buff 1)))`\n\n## Why it matters\n\nThe `principal-destruct?` function is crucial for:\n\n1. Decomposing a principal into its component parts.\n2. Managing identities and permissions in smart contracts.\n3. Ensuring data integrity by validating principal components.\n4. Simplifying the process of handling principals in smart contracts.\n\n## When to use it\n\nUse `principal-destruct?` when you need to:\n\n- Decompose a principal into its component parts.\n- Manage identities and permissions in your smart contract.\n- Validate the components of a principal.\n- Handle principal decomposition operations.\n\n## Best Practices\n\n- Ensure the `principal` is correctly formatted.\n- Use meaningful variable names for better readability.\n- Combine with other principal functions for comprehensive identity management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Decomposing a Principal\n\nLet's implement a function that destructs a principal back into its components:\n\n```clarity\n(define-public (destruct-principal (principal principal))\n  (principal-destruct? principal)\n)\n\n;; Usage\n(destruct-principal 'ST3X6QWWETNBZWGBK6DRGTR1KX50S74D3425Q1TPK) \n;; Returns (ok (tuple (hash-bytes 0xfa6bf38ed557fe417333710d6033e9419391a320) (name none) (version 0x1a)))\n(destruct-principal 'ST3X6QWWETNBZWGBK6DRGTR1KX50S74D3425Q1TPK.foo) \n;; Returns (ok (tuple (hash-bytes 0xfa6bf38ed557fe417333710d6033e9419391a320) (name (some \"foo\")) (version 0x1a)))\n```\n\nThis example demonstrates:\n1. Using `principal-destruct?` to decompose a principal into its components.\n2. Implementing a public function to handle the principal decomposition.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `principal-destruct?` with incorrectly formatted principals, causing the operation to fail.\n2. Assuming the principal will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete principal management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `principal-construct?`: Constructs a principal from its components.\n- `principal-of?`: Returns the principal derived from a public key.\n- `contract-caller`: Returns the caller of the current contract context.\n\n## Conclusion\n\nThe `principal-destruct?` function is a fundamental tool for decomposing principals into their component parts in Clarity smart contracts. It allows you to manage identities and permissions, ensuring data integrity and simplifying principal handling. When used effectively, `principal-destruct?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle principal decomposition operations.\n"
  },
  {
    "title": "to-consensus-buff?",
    "description": "Serialize a Clarity value into a buffer for consensus in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/to-consensus-buff",
    "content": "\n## Function Signature\n\n```clarity\n(to-consensus-buff? value)\n```\n\n- Input: `any`\n- Output: `(optional (buff 32))`\n\n## Why it matters\n\nThe `to-consensus-buff?` function is crucial for:\n\n1. Serializing Clarity values into buffers for consensus.\n2. Implementing logic that requires converting Clarity values to a standardized buffer format.\n3. Ensuring data integrity by validating the serialization process.\n4. Simplifying the process of handling value serialization in smart contracts.\n\n## When to use it\n\nUse `to-consensus-buff?` when you need to:\n\n- Serialize Clarity values into buffers for consensus.\n- Implement logic that requires converting Clarity values to a standardized buffer format.\n- Validate the serialization process to ensure data integrity.\n- Handle value serialization in your smart contract.\n\n## Best Practices\n\n- Ensure the input value is correctly formatted and valid.\n- Use meaningful variable names for better readability.\n- Combine with other serialization functions for comprehensive data management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Serializing a Clarity Value\n\nLet's implement a function that serializes an integer value into a buffer:\n\n```clarity\n(define-read-only (serialize-int (input int))\n  (to-consensus-buff? input)\n)\n\n(define-read-only (serialize-tuple (input (tuple (name (string-ascii 50)) (age uint))))\n  (to-consensus-buff? input)\n)\n\n;; Usage\n(serialize-int 42) ;; Returns (some 0x000000000000000000000000000000000000000000000000000000000000002a)\n(serialize-int -1) ;; Returns none (since negative integers cannot be serialized)\n(serialize-tuple (tuple (name \"Harper Dog\") (age u5))) ;; Returns (some 0x0c00000002036167650100000000000000000000000000000005046e616d650d0000000a48617270657220446f67)\n```\n\nThis example demonstrates:\n1. Using `to-consensus-buff?` to serialize an integer value into a buffer.\n2. Implementing a public function to handle the serialization process.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `to-consensus-buff?` with incorrectly formatted or invalid input values, causing the operation to fail.\n2. Assuming the serialization will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `from-consensus-buff?`: Deserializes a buffer into a Clarity value.\n- `buff-to-int-be`: Converts a big-endian buffer to an integer.\n- `buff-to-uint-le`: Converts a little-endian buffer to an unsigned integer.\n\n## Conclusion\n\nThe `to-consensus-buff?` function is a fundamental tool for serializing Clarity values into buffers for consensus in Clarity smart contracts. It allows you to implement logic that requires converting Clarity values to a standardized buffer format, ensuring data integrity and simplifying value serialization. When used effectively, `to-consensus-buff?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle value serialization.\n"
  },
  {
    "title": "stx-burn?",
    "description": "Burn STX from a principal's account in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/stx-burn",
    "content": "\n## Function Signature\n\n```clarity\n(stx-burn? amount sender)\n```\n\n- Input: `uint, principal`\n- Output: `(response bool uint)`\n\n## Why it matters\n\nThe `stx-burn?` function is crucial for:\n\n1. Decreasing the STX holdings of a principal by burning the specified amount.\n2. Implementing logic that requires reducing the circulating supply of STX.\n3. Ensuring data integrity by validating the burn operation.\n4. Simplifying the process of handling STX burning in smart contracts.\n\n## When to use it\n\nUse `stx-burn?` when you need to:\n\n- Decrease the STX holdings of a principal by burning the specified amount.\n- Implement logic that requires reducing the circulating supply of STX.\n- Validate the burn operation to ensure data integrity.\n- Handle STX burning operations in your smart contract.\n\n## Best Practices\n\n- Ensure the `amount` is positive and the `sender` has sufficient balance.\n- Use meaningful variable names for better readability.\n- Combine with other STX functions for comprehensive account management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Burning STX from an Account\n\nLet's implement a function that burns a specified amount of STX from the `tx-sender`:\n\n```clarity\n(define-public (burn-stx (amount uint))\n  (stx-burn? amount tx-sender)\n)\n\n;; Usage\n(burn-stx u50) ;; Returns (ok true)\n```\n\nThis example demonstrates:\n1. Using `stx-burn?` to burn a specified amount of STX from the `tx-sender`.\n2. Implementing a public function to handle the STX burning operation.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `stx-burn?` with a non-positive amount, causing the operation to fail.\n2. Assuming the burn operation will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete account management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `stx-get-balance`: Queries the STX balance of a principal.\n- `stx-transfer?`: Transfers STX from one principal to another.\n- `stx-account`: Queries detailed STX account information.\n\n## Conclusion\n\nThe `stx-burn?` function is a fundamental tool for burning STX from a principal's account in Clarity smart contracts. It allows you to implement logic that requires reducing the circulating supply of STX, ensuring data integrity and simplifying STX burning operations. When used effectively, `stx-burn?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle STX burning operations.\n"
  },
  {
    "title": "from-consensus-buff?",
    "description": "Deserialize a buffer into a Clarity value in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/from-consensus-buff",
    "content": "\n## Function Signature\n\n```clarity\n(from-consensus-buff? type-signature buffer)\n```\n\n- Input: \n  - `type-signature`: The type to deserialize into\n  - `buffer`: A buffer containing the serialized data\n- Output: `(optional t)` where t is the type specified in the type signature\n\n## Why it matters\n\nThe `from-consensus-buff?` function is crucial for:\n\n1. Deserializing data that has been serialized using the SIP-005 standard.\n2. Enabling interoperability between different contracts or systems.\n3. Handling complex data structures that have been serialized for storage or transmission.\n4. Safely converting buffers back into Clarity values with type checking.\n\n## When to use it\n\nUse `from-consensus-buff?` when you need to:\n\n- Convert serialized data back into Clarity values.\n- Interact with data that has been serialized by other contracts or off-chain systems.\n- Implement cross-contract communication protocols involving serialized data.\n- Deserialize stored data that was previously serialized for efficiency.\n\n## Best Practices\n\n- Always specify the correct type signature to ensure proper deserialization.\n- Handle the `none` case when the deserialization fails.\n- Use in conjunction with `to-consensus-buff?` for serialization-deserialization workflows.\n- Be aware of the gas costs associated with deserializing large or complex data structures.\n\n## Practical Example: Deserializing a Tuple\n\nLet's implement a function that deserializes a buffer into a tuple:\n\n```clarity\n(define-read-only (deserialize-user-data (serializedData (buff 128)))\n  (match (from-consensus-buff? { name: (string-ascii 50), age: uint } serializedData)\n    success success\n    (err u1)\n  )\n)\n\n;; Usage\n(deserialize-user-data 0x0c00000002036167650100000000000000000000000000000005046e616d650d0000000a48617270657220446f67)\n;; Returns (ok (tuple (name \"Harper Dog\") (age u5)))\n```\n\nThis example demonstrates:\n1. Using `from-consensus-buff?` to deserialize a buffer into a tuple.\n2. Specifying the expected type structure for the deserialization.\n3. Handling both successful and failed deserialization attempts.\n\n## Common Pitfalls\n\n1. Specifying an incorrect type signature, leading to deserialization failures.\n2. Not handling the `none` case when deserialization fails.\n3. Attempting to deserialize data that wasn't properly serialized using the SIP-005 standard.\n4. Overlooking potential out-of-memory errors when deserializing very large structures.\n\n## Related Functions\n\n- `to-consensus-buff?`: Used to serialize Clarity values into buffers.\n- `unwrap-panic`: Often used to forcibly unwrap the optional result (use with caution).\n- `match`: Commonly used to handle both success and failure cases of deserialization.\n\n## Conclusion\n\nThe `from-consensus-buff?` function is a powerful tool for working with serialized data in Clarity smart contracts. It enables contracts to safely deserialize complex data structures, facilitating interoperability and efficient data handling. When used correctly, this function provides a robust way to convert buffers back into typed Clarity values, enhancing the contract's ability to process and validate external data.\n"
  },
  {
    "title": "bit-shift-right",
    "description": "Use the bit-shift-right function for bitwise right shift operations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/bit-shift-right",
    "content": "\n## Function Signature\n\n```clarity\n(bit-shift-right i1 shamt)\n```\n\n- Input: \n  - `i1`: An integer (`int` or `uint`)\n  - `shamt`: A `uint` representing the number of places to shift\n- Output: An integer of the same type as `i1` (`int` or `uint`)\n\n## Why it matters\n\nThe `bit-shift-right` function is crucial for:\n\n1. Performing efficient division by powers of 2.\n2. Implementing certain bitwise algorithms and data structures.\n3. Manipulating binary data at the bit level.\n4. Extracting specific bit patterns from integers.\n\n## When to use it\n\nUse the `bit-shift-right` function when you need to:\n\n- Divide a number by a power of 2 efficiently.\n- Implement certain cryptographic or hashing algorithms.\n- Perform low-level data manipulations involving binary operations.\n- Extract specific bits or bit patterns from integers.\n\n## Best Practices\n\n- Be aware that shifting right by `n` bits is equivalent to integer division by 2^n.\n- Remember that for signed integers (`int`), the sign bit is preserved during right shifts.\n- Use `uint` for `shamt` to avoid potential issues with negative shift amounts.\n- Consider the differences in behavior between signed and unsigned integers when right-shifting.\n\n## Practical Example: Efficient Power of 2 Division\n\nLet's implement a function that efficiently divides by powers of 2 using `bit-shift-right`:\n\n```clarity\n(define-read-only (divide-by-power-of-2 (value int) (power uint))\n  (bit-shift-right value power)\n)\n\n(define-read-only (extract-lowest-bits (value uint) (numBits uint))\n  (bit-and value (- (bit-shift-left u1 numBits) u1))\n)\n\n;; Usage\n(divide-by-power-of-2 128 u3) ;; Returns 16 (128 / 2^3)\n(divide-by-power-of-2 -128 u3) ;; Returns -16 (-128 / 2^3)\n(extract-lowest-bits u171 u4) ;; Returns u11 (binary: 1011)\n```\n\nThis example demonstrates:\n1. Using `bit-shift-right` for efficient division by powers of 2.\n2. Handling both positive and negative numbers in division.\n3. Combining `bit-shift-right` with other bitwise operations to extract specific bit patterns.\n\n## Common Pitfalls\n\n1. Forgetting that right-shifting signed integers preserves the sign bit.\n2. Not considering the modulo behavior when shifting by amounts greater than or equal to 128.\n3. Using a negative or non-uint value for the shift amount, which is not allowed.\n\n## Related Functions\n\n- `bit-shift-left`: Used for left-shifting bits.\n- `bit-and`: Often used in combination with `bit-shift-right` for masking operations.\n- `/`: Used for general division, but less efficient for powers of 2 compared to bit shifting.\n\n## Conclusion\n\nThe `bit-shift-right` function is a powerful tool for bitwise operations in Clarity smart contracts. This function enables efficient division by powers of 2 and is essential for extracting specific bit patterns and implementing various bitwise algorithms. However, be mindful of the differences between signed and unsigned integers when using this function, as well as its behavior with large shift amounts.\n"
  },
  {
    "title": "is-some",
    "description": "Check if an optional value is some in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/is-some",
    "content": "\n## Function Signature\n\n```clarity\n(is-some value)\n```\n\n- Input: `(optional A)`\n- Output: `bool`\n\n## Why it matters\n\nThe `is-some` function is crucial for:\n\n1. Determining if an optional value is `some`.\n2. Implementing conditional logic based on the presence of values.\n3. Ensuring robust contract behavior by checking for existing values.\n4. Simplifying checks for optional values in smart contract code.\n\n## When to use it\n\nUse `is-some` when you need to:\n\n- Check if an optional value is `some`.\n- Implement logic that depends on whether a value is present.\n- Validate the results of function calls that return optional types.\n- Handle cases where values might be present or absent.\n\n## Best Practices\n\n- Use `is-some` in combination with `match` or `if` for comprehensive value handling.\n- Ensure that the value being checked is of the correct optional type.\n- Use meaningful variable names for better readability.\n- Combine with other optional handling functions like `is-none` for complete validation.\n\n## Practical Example: Checking for Existing User Data\n\nLet's implement a function that checks if a user's profile data exists:\n\n```clarity\n(define-map UserProfiles { userId: principal } { name: (string-ascii 50), age: uint })\n\n(define-read-only (is-profile-existing (user principal))\n  (is-some (map-get? UserProfiles { userId: user }))\n)\n\n;; Usage\n(map-set UserProfiles { userId: tx-sender } { name: \"Alice\", age: u30 })\n(is-profile-existing tx-sender) ;; Returns true\n(is-profile-existing 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns false\n```\n\nThis example demonstrates:\n1. Using `is-some` to check if a user's profile data exists.\n2. Implementing a read-only function to determine the presence of user data.\n3. Handling both the case where the profile data is present and where it is absent.\n\n## Common Pitfalls\n\n1. Assuming the value will always be `some`, leading to unhandled `none` cases.\n2. Using `is-some` on non-optional types, causing type errors.\n3. Not handling all possible conditions, resulting in incomplete value checks.\n4. Overlooking the need for comprehensive validation and error checking.\n\n## Related Functions\n\n- `is-none`: Checks if an optional value is `none`.\n- `match`: Used for pattern matching and handling multiple conditions.\n- `default-to`: Provides default values for optional types.\n\n## Conclusion\n\nThe `is-some` function is a fundamental tool for checking optional values in Clarity smart contracts. It allows you to determine if a value is `some`, enabling robust and comprehensive value handling and validation logic. When used effectively, `is-some` enhances the reliability and maintainability of your smart contract code by ensuring that existing values are detected and handled appropriately.\n"
  },
  {
    "title": "is-standard",
    "description": "Check if a value is a standard principal in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/is-standard",
    "content": "\n## Function Signature\n\n```clarity\n(is-standard value)\n```\n\n- Input: `principal`\n- Output: `bool`\n\n## Why it matters\n\nThe `is-standard` function is crucial for:\n\n1. Determining if a principal is a standard principal (i.e., a user address).\n2. Implementing conditional logic based on the type of principal.\n3. Ensuring that certain operations are only performed by standard principals.\n4. Simplifying checks for principal types in smart contract code.\n\n## When to use it\n\nUse `is-standard` when you need to:\n\n- Check if a principal is a standard user address.\n- Implement logic that depends on the type of principal.\n- Validate the type of principal before performing certain operations.\n- Handle cases where only standard principals are allowed.\n\n## Best Practices\n\n- Use `is-standard` in combination with `if` or `match` for comprehensive principal type handling.\n- Ensure that the value being checked is of the correct principal type.\n- Use meaningful variable names for better readability.\n- Note that you can pass in a valid contract principal as well, not just a standard principal (e.g., `'SP12` or `'SP12.contract`).\n\n## Practical Example: Restricting Access to Standard Principals\n\nLet's implement a function that restricts access to standard principals:\n\n```clarity\n(define-map UserBalances { userId: principal } { balance: uint })\n\n(define-public (transfer-tokens (amount uint) (recipient principal))\n  (if (is-standard tx-sender)\n    (let\n      (\n        (senderBalance (default-to u0 (map-get? UserBalances { userId: tx-sender })))\n        (recipientBalance (default-to u0 (map-get? UserBalances { userId: recipient })))\n      )\n      (if (>= senderBalance amount)\n        (begin\n          (map-set UserBalances { userId: tx-sender } { balance: (- senderBalance amount) })\n          (map-set UserBalances { userId: recipient } { balance: (+ recipientBalance amount) })\n          (ok true)\n        )\n        (err u1)\n      )\n    )\n    (err u2)\n  )\n)\n\n;; Usage\n(map-set UserBalances { userId: tx-sender } { balance: u100 })\n(transfer-tokens u50 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (ok true) if tx-sender is a standard principal\n```\n\nThis example demonstrates:\n1. Using `is-standard` to check if the transaction sender is a standard principal.\n2. Implementing conditional logic based on the type of principal.\n3. Handling both the case where the principal is standard and where it is not.\n\n## Common Pitfalls\n\n1. Assuming the principal will always be standard, leading to unhandled cases.\n2. Using `is-standard` on non-principal types, causing type errors.\n3. Not handling all possible conditions, resulting in incomplete principal type checks.\n4. Overlooking the need for comprehensive validation and error checking.\n\n## Related Functions\n\n- `tx-sender`: Returns the principal that initiated the transaction.\n- `contract-caller`: Returns the caller of the current contract context.\n\n## Conclusion\n\nThe `is-standard` function is a fundamental tool for checking principal types in Clarity smart contracts. It allows you to determine if a principal is a standard user address, enabling robust and comprehensive principal type handling and validation logic. When used effectively, `is-standard` enhances the reliability and maintainability of your smart contract code by ensuring that operations are performed by the correct type of principal.\n"
  },
  {
    "title": "unwrap-err-panic",
    "description": "Unpack error responses and throwing runtime errors in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/unwrap-err-panic",
    "content": "\n## Function Signature\n\n```clarity\n(unwrap-err-panic response-input)\n```\n\n- Input: `(response A B)`\n- Output: `B`\n\n## Why it matters\n\nThe `unwrap-err-panic` function is crucial for:\n\n1. Unpacking error responses to access their inner values.\n2. Implementing logic that requires handling error responses.\n3. Ensuring data integrity by validating the error unpacking process.\n4. Simplifying the process of handling error responses in smart contracts by throwing runtime errors when necessary.\n\n## When to use it\n\nUse `unwrap-err-panic` when you need to:\n\n- Unpack error responses to access their inner values.\n- Implement logic that requires handling error responses.\n- Validate the error unpacking process to ensure data integrity.\n- Handle error responses in your smart contract and throw runtime errors when necessary.\n\n## Best Practices\n\n- Ensure the input value is a response type.\n- Use meaningful variable names for better readability.\n- Combine with other error handling functions for comprehensive error management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Unpacking an Error Response and Throwing a Runtime Error\n\nLet's implement a function that processes an error response using `unwrap-err-panic`:\n\n```clarity\n(define-public (process-error-response (input (response int int)))\n  (let\n    (\n      (errorValue (unwrap-err-panic input))\n    )\n    (ok errorValue)\n  )\n)\n\n;; Usage\n(process-error-response (err 42)) ;; Returns (ok 42)\n(process-error-response (ok 1)) ;; Throws a runtime exception\n```\n\nThis example demonstrates:\n1. Using `unwrap-err-panic` to unpack an error response.\n2. Implementing a public function to handle the error unpacking process.\n3. Handling both successful and error cases, with runtime errors thrown for `ok` values.\n\n## Common Pitfalls\n\n1. Using `unwrap-err-panic` with values that are not response types, causing runtime errors.\n2. Assuming the error unpacking will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete error management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `unwrap!`: Unpacks optional and response types, returning a thrown value if unpacking fails.\n- `unwrap-err!`: Unpacks error responses, returning a thrown value if the response is `ok`.\n- `try!`: Unpacks optional and response types, returning `none` or the `err` value if unpacking fails.\n\n## Conclusion\n\nThe `unwrap-err-panic` function is a fundamental tool for unpacking error responses and throwing runtime errors in Clarity smart contracts. It allows you to implement logic that requires handling error responses, ensuring data integrity and simplifying the error unpacking process. When used effectively, `unwrap-err-panic` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle error responses and throw runtime errors when necessary.\n"
  },
  {
    "title": "append",
    "description": "Use the append function to add elements to lists in Clarity smart contracts, with considerations for maximum list length.",
    "slug": "/stacks/clarity/functions/append",
    "content": "\n## Function Signature\n\n```clarity\n(append (list A) A)\n```\n\n- Input: A list of type A, and a single element of type A\n- Output: A new list of type A with the element appended\n\n## Why it matters\n\nThe `append` function is crucial for:\n\n1. Dynamically growing lists within smart contracts.\n2. Adding new elements to existing data structures.\n3. Implementing queue-like behaviors in contract logic.\n4. Constructing lists incrementally during contract execution.\n\n## When to use it\n\nUse the `append` function when you need to:\n\n- Add a new element to the end of an existing list.\n- Construct a list by adding elements one at a time.\n- Implement data structures that require adding elements in order.\n- Combine existing lists with single elements.\n\n## Best Practices\n\n- Always use `as-max-len?` before appending to ensure the list doesn't exceed its maximum length.\n- Be mindful of the maximum list length specified when defining the list.\n- Consider using `concat` for joining two lists instead of repeatedly using `append`.\n- Remember that `append` creates a new list; it doesn't modify the original list in-place.\n- Use type-appropriate elements that match the list's declared type.\n\n## Practical Example: Event Log with Max Length Check\n\nLet's implement a simple event log system using `append` with a maximum length check:\n\n```clarity\n(define-data-var eventLog (list 50 (string-ascii 50)) (list))\n\n(define-public (log-event (event (string-ascii 50)))\n  (let\n    (\n      (current-log (var-get eventLog))\n    )\n    (match (as-max-len? (append current-log event) u2) success\n      (ok (var-set eventLog success))\n      (err u1)\n    )\n  )\n)\n\n(define-read-only (get-eventLog)\n  (ok (var-get eventLog))\n)\n\n;; Usage\n(log-event \"Contract initialized\")\n(log-event \"User registered\")\n(get-eventLog) ;; Returns (ok (\"Contract initialized\" \"User registered\"))\n```\n\nThis example demonstrates:\n1. Using `append` to add new events to an existing log.\n2. Using `as-max-len?` to check if appending would exceed the maximum list length.\n3. Handling the case where the list would exceed its maximum length.\n4. Combining `append` with other Clarity functions like `var-set` and `var-get`.\n\n## Common Pitfalls\n\n1. Forgetting to use `as-max-len?` when appending to a list with a maximum length.\n2. Attempting to append an element of the wrong type to a typed list.\n3. Assuming `append` will always succeed without checking the list's current length.\n4. Inefficiently using `append` in a loop when `concat` might be more appropriate.\n\n## Related Functions\n\n- `as-max-len?`: Used to check if a sequence exceeds a maximum length.\n- `concat`: Used for joining two lists together.\n- `list`: Used for creating new lists.\n- `len`: Used for getting the current length of a list.\n\n## Conclusion\n\nThe `append` function is a powerful tool for manipulating lists in Clarity smart contracts. By understanding its behavior, limitations, and the necessity of using `as-max-len?` with lists that have a maximum length, you can effectively manage dynamic data structures within your contracts. This enables more flexible and responsive smart contract designs while maintaining safeguards against exceeding predefined list size limits.\n"
  },
  {
    "title": "stx-transfer?",
    "description": "Transfer STX between principals in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/stx-transfer",
    "content": "\n## Function Signature\n\n```clarity\n(stx-transfer? amount sender recipient)\n```\n\n- Input: `uint, principal, principal`\n- Output: `(response bool uint)`\n\n## Why it matters\n\nThe `stx-transfer?` function is crucial for:\n\n1. Transferring STX between principals.\n2. Implementing logic that requires moving STX from one account to another.\n3. Ensuring data integrity by validating the transfer operation.\n4. Simplifying the process of handling STX transfers in smart contracts.\n\n## When to use it\n\nUse `stx-transfer?` when you need to:\n\n- Transfer STX between principals.\n- Implement logic that requires moving STX from one account to another.\n- Validate the transfer operation to ensure data integrity.\n- Handle STX transfers in your smart contract.\n\n## Best Practices\n\n- Ensure the `amount` is positive and the `sender` has sufficient balance.\n- Use meaningful variable names for better readability.\n- Combine with other STX functions for comprehensive account management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Transferring STX\n\nLet's implement a function that transfers STX from the `tx-sender` to a recipient:\n\n```clarity\n(define-public (transfer-stx (amount uint) (recipient principal))\n  (stx-transfer? amount tx-sender recipient)\n)\n\n;; Usage\n(transfer-stx u60 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR) \n;; Returns (ok true) if successful\n(transfer-stx u50 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR) \n;; Returns (err u1) if the sender does not have enough balance\n```\n\nThis example demonstrates:\n1. Using `stx-transfer?` to transfer STX from the `tx-sender` to a recipient.\n2. Implementing a public function to handle the STX transfer.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `stx-transfer?` with a non-positive amount, causing the operation to fail.\n2. Assuming the transfer operation will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete account management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `stx-get-balance`: Queries the STX balance of a principal.\n- `stx-transfer-memo?`: Transfers STX from one principal to another with a memo.\n- `stx-burn?`: Burns STX from a principal's account.\n\n## Conclusion\n\nThe `stx-transfer?` function is a fundamental tool for transferring STX between principals in Clarity smart contracts. It allows you to implement logic that requires moving STX from one account to another, ensuring data integrity and simplifying STX transfer operations. When used effectively, `stx-transfer?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle STX transfers.\n"
  },
  {
    "title": "unwrap-panic",
    "description": "Unpack optional and response types and throwing runtime errors in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/unwrap-panic",
    "content": "\n## Function Signature\n\n```clarity\n(unwrap-panic option-input)\n```\n\n- Input: `(optional A) | (response A B)`\n- Output: `A`\n\n## Why it matters\n\nThe `unwrap-panic` function is crucial for:\n\n1. Unpacking optional and response types to access their inner values.\n2. Implementing logic that requires handling optional and response types.\n3. Ensuring data integrity by validating the unpacking process.\n4. Simplifying the process of handling optional and response types in smart contracts by throwing runtime errors when necessary.\n\n## When to use it\n\nUse `unwrap-panic` when you need to:\n\n- Unpack optional and response types to access their inner values.\n- Implement logic that requires handling optional and response types.\n- Validate the unpacking process to ensure data integrity.\n- Handle optional and response types in your smart contract and throw runtime errors when necessary.\n\n## Best Practices\n\n- Ensure the input value is an optional or response type.\n- Use meaningful variable names for better readability.\n- Combine with other error handling functions for comprehensive error management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Unpacking an Optional Value and Throwing a Runtime Error\n\nLet's implement a function that retrieves a value from a map and unpacks it using `unwrap-panic`:\n\n```clarity\n(define-map UserInfo { userId: principal } { name: (string-ascii 20), age: uint })\n\n(define-public (get-user-age (user principal))\n  (let\n    (\n      (userData (unwrap-panic (map-get? UserInfo { userId: user })))\n    )\n    (ok (get age userData))\n  )\n)\n\n;; Usage\n(map-set UserInfo { userId: tx-sender } { name: \"Alice\", age: u30 })\n(get-user-age tx-sender) ;; Returns (ok u30)\n(get-user-age 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR) ;; Throws a runtime exception\n```\n\n## Common Pitfalls\n\n1. Using `unwrap-panic` with values that are not optional or response types, causing runtime errors.\n2. Assuming the unpacking will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete error management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `unwrap!`: Unpacks optional and response types, returning a thrown value if unpacking fails.\n- `unwrap-err!`: Unpacks error responses, returning a thrown value if the response is `ok`.\n- `try!`: Unpacks optional and response types, returning `none` or the `err` value if unpacking fails.\n\n## Conclusion\n\nThe `unwrap-panic` function is a fundamental tool for unpacking optional and response types and throwing runtime errors in Clarity smart contracts. It allows you to implement logic that requires handling optional and response types, ensuring data integrity and simplifying the unpacking process. When used effectively, `unwrap-panic` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle optional and response types and throw runtime errors when necessary.\n"
  },
  {
    "title": "impl-trait",
    "description": "Implement traits in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/impl-trait",
    "content": "\n## Function Signature\n\n```clarity\n(impl-trait trait-name)\n```\n\n- Input: \n  - `trait-name`: The name of the trait to implement\n- Output: Not applicable\n\n## Why it matters\n\nThe `impl-trait` function is crucial for:\n\n1. Enabling contracts to conform to specific interfaces.\n2. Allowing dynamic function calls between contracts.\n3. Promoting code reuse and modularity in smart contract development.\n4. Ensuring contracts adhere to predefined behaviors and standards.\n\n## When to use it\n\nUse `impl-trait` when you need to:\n\n- Implement a predefined interface in your contract.\n- Allow other contracts to interact with your contract through a common interface.\n- Ensure your contract adheres to specific standards or behaviors.\n- Enable dynamic function calls using `contract-call?`.\n\n## Best Practices\n\n- Define traits at the top level of your contract for clarity and organization.\n- Ensure all required functions in the trait are implemented in your contract.\n- Use meaningful and descriptive names for traits and their functions.\n- Document the purpose and usage of each trait in your contract.\n\n## Practical Example: Implementing a Token Trait\n\nLet's define a simple token trait and implement it in a contract:\n\n```clarity\n(define-trait token-trait\n  (\n    (transfer (principal principal uint) (response bool uint))\n    (get-balance (principal) (response uint uint))\n  )\n)\n\n(impl-trait token-trait)\n\n(define-map Balances { user: principal } { balance: uint })\n\n(define-public (transfer (sender principal) (recipient principal) (amount uint))\n  (let\n    (\n      (senderBalance (default-to u0 (map-get? Balances { user: sender })))\n      (recipientBalance (default-to u0 (map-get? Balances { user: recipient })))\n    )\n    (if (>= senderBalance amount)\n      (begin\n        (map-set Balances { user: sender } { balance: (- senderBalance amount) })\n        (map-set Balances { user: recipient } { balance: (+ recipientBalance amount) })\n        (ok true)\n      )\n      (err u1)\n    )\n  )\n)\n\n(define-read-only (get-balance (user principal))\n  (ok (default-to u0 (map-get? Balances { user: user })))\n)\n```\n\nThis example demonstrates:\n1. Defining a `token-trait` with `transfer` and `get-balance` functions.\n2. Implementing the `token-trait` in a contract using `impl-trait`.\n3. Providing implementations for the `transfer` and `get-balance` functions.\n\n## Common Pitfalls\n\n1. Forgetting to implement all required functions in the trait, leading to deployment errors.\n2. Using inconsistent function signatures between the trait and the implementation.\n3. Not documenting the purpose and usage of traits, making the contract harder to understand.\n4. Overlooking the need for proper error handling in trait functions.\n\n## Related Functions\n\n- `define-trait`: Used to define a new trait.\n- `contract-call?`: Used to call functions dynamically on contracts that implement a trait.\n- `define-public`: Used to define public functions that can be called from outside the contract.\n\n## Conclusion\n\nThe `impl-trait` function is a powerful tool for promoting modularity and code reuse in Clarity smart contracts. By implementing predefined interfaces, contracts can interact dynamically and adhere to specific standards and behaviors. When used effectively, `impl-trait` enhances the flexibility and maintainability of your smart contract code, enabling more robust and interoperable decentralized applications.\n"
  },
  {
    "title": "to-int",
    "description": "Convert an unsigned integer to a signed integer in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/to-int",
    "content": "\n## Function Signature\n\n```clarity\n(to-int value)\n```\n\n- Input: `uint`\n- Output: `int`\n\n## Why it matters\n\nThe `to-int` function is crucial for:\n\n1. Converting unsigned integers to signed integers.\n2. Implementing logic that requires signed integer operations.\n3. Ensuring data integrity by validating the conversion process.\n4. Simplifying the process of handling integer conversions in smart contracts.\n\n## When to use it\n\nUse `to-int` when you need to:\n\n- Convert an unsigned integer to a signed integer.\n- Implement logic that requires signed integer operations.\n- Validate the conversion process to ensure data integrity.\n- Handle integer conversions in your smart contract.\n\n## Best Practices\n\n- Ensure the input value is within the range that can be represented as a signed integer.\n- Use meaningful variable names for better readability.\n- Combine with other integer functions for comprehensive data management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Converting Unsigned Integer to Signed Integer\n\nLet's implement a function that converts an unsigned integer to a signed integer:\n\n```clarity\n(define-read-only (convert-to-int (input uint))\n  (to-int input)\n)\n\n;; Usage\n(convert-to-int u42) ;; Returns 42\n(convert-to-int u0) ;; Returns 0\n(convert-to-int u1000000) ;; Returns 1000000\n```\n\nThis example demonstrates:\n1. Using `to-int` to convert an unsigned integer to a signed integer.\n2. Implementing a public function to handle the conversion process.\n3. Handling both small and large input values.\n\n## Common Pitfalls\n\n1. Using `to-int` with values that exceed the range of signed integers, causing unexpected behavior.\n2. Assuming the conversion will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `to-uint`: Converts a signed integer to an unsigned integer.\n- `int-to-ascii`: Converts an integer to a string-ascii representation.\n- `int-to-utf8`: Converts an integer to a string-utf8 representation.\n\n## Conclusion\n\nThe `to-int` function is a fundamental tool for converting unsigned integers to signed integers in Clarity smart contracts. It allows you to implement logic that requires signed integer operations, ensuring data integrity and simplifying integer conversions. When used effectively, `to-int` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle integer conversions.\n"
  },
  {
    "title": "greater than",
    "description": "Use the greater than function for comparisons in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/greater-than",
    "content": "\nThe greater than function (`>`) in Clarity compares two values and returns true if the first value is greater than the second. It's a fundamental comparison operation used in many smart contract conditions and logic flows.\n\n## Function Signature\n\n```clarity\n(> v1 v2)\n```\n\n- Input: Two values of the same type (int, uint, string-ascii, string-utf8, or buff)\n- Output: A boolean (true or false)\n\n## Why it matters\n\nThe greater than function is crucial for:\n\n1. Implementing conditional logic in smart contracts.\n2. Comparing numerical values for financial operations.\n3. Ordering and sorting data.\n4. Implementing thresholds or limits in contract logic.\n\n## When to use it\n\nUse the greater than function when you need to:\n\n- Compare two numerical values to determine if one is larger.\n- Implement minimum thresholds for certain operations.\n- Create conditional logic based on numerical comparisons.\n- Sort or order data based on numerical or lexicographical order.\n\n## Best Practices\n\n- Ensure that both inputs are of the same type to avoid runtime errors.\n- Be aware of the differences in comparison between signed (int) and unsigned (uint) integers.\n- When comparing strings or buffers, understand that the comparison is lexicographical.\n- Consider edge cases, especially when dealing with the limits of integer ranges.\n\n## Practical Example: Token Sale with Minimum Purchase\n\nLet's implement a simple token sale contract that uses the greater than function to enforce a minimum purchase amount:\n\n```clarity\n;; Define constants\n(define-constant MIN_PURCHASE u100000000) ;; 1 STX\n(define-constant TOKEN_PRICE u50000) ;; 0.0005 STX per token\n\n;; Define data variables\n(define-data-var tokensSold uint u0)\n\n;; Function to purchase tokens\n(define-public (purchase-tokens (amount uint))\n  (let\n    (\n      (tokensToMint (/ amount TOKEN_PRICE))\n      (payment amount)\n    )\n    ;; Check if the purchase amount is greater than the minimum\n    (asserts! (> payment MIN_PURCHASE) (err u1))\n    ;; Perform the token purchase\n    (try! (stx-transfer? payment tx-sender (as-contract tx-sender)))\n    (var-set tokensSold (+ (var-get tokensSold) tokensToMint))\n    ;; Here you would typically mint or transfer tokens to the buyer\n    (ok tokensToMint)\n  )\n)\n\n;; Function to check total tokens sold\n(define-read-only (get-tokensSold)\n  (ok (var-get tokensSold))\n)\n```\n\nThis example demonstrates:\n1. Using `>` to check if the payment amount exceeds the minimum purchase threshold.\n2. Combining the greater than check with other contract logic for a token sale.\n3. Implementing a minimum purchase amount to prevent small, potentially spam transactions.\n\n## Common Pitfalls\n\n1. Comparing values of different types, which will result in a runtime error.\n2. Not considering the inclusive nature of `>=` vs the exclusive nature of `>` when setting thresholds.\n3. Overlooking potential integer overflow when working with very large numbers.\n\n## Related Functions\n\n- `<`: Used for less than comparisons.\n- `>=`: Used for greater than or equal to comparisons.\n- `<=`: Used for less than or equal to comparisons.\n\n## Conclusion\n\nThe greater than function is a fundamental tool for implementing comparison logic in Clarity smart contracts. By understanding its behavior with different types and potential edge cases, you can create robust conditional logic and enforce important thresholds in your contracts.\n"
  },
  {
    "title": "not",
    "description": "Logical negation in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/not",
    "content": "\n## Function Signature\n\n```clarity\n(not boolean-expression)\n```\n\n- Input: `bool`\n- Output: `bool`\n\n## Why it matters\n\nThe `not` function is crucial for:\n\n1. Implementing logical negation in conditional statements.\n2. Simplifying the process of inverting boolean expressions.\n3. Enhancing code readability and maintainability by abstracting logical negation.\n\n## When to use it\n\nUse `not` when you need to:\n\n- Invert a boolean expression.\n- Implement logical negation in conditional statements.\n- Simplify and abstract the process of inverting boolean values.\n\n## Best Practices\n\n- Ensure the input is a boolean expression.\n- Use meaningful variable names for better readability.\n- Combine with other logical functions for comprehensive boolean logic.\n- Be aware of the performance implications of complex logical operations.\n\n## Practical Example: Inverting a Boolean Expression\n\nLet's implement a function that checks if a number is not zero:\n\n```clarity\n(define-read-only (is-not-zero (n int))\n  (not (is-eq n 0))\n)\n\n;; Usage\n(is-not-zero 5) ;; Returns true\n(is-not-zero 0) ;; Returns false\n```\n\nThis example demonstrates:\n1. Using `not` to invert the result of a boolean expression.\n2. Implementing a read-only function to check if a number is not zero.\n3. Handling both true and false cases.\n\n## Common Pitfalls\n\n1. Using `not` with non-boolean expressions, causing type errors.\n2. Assuming the result will always be true or false, leading to incorrect logic.\n3. Not handling all possible conditions, resulting in incomplete boolean logic.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `and`: Logical conjunction of multiple boolean expressions.\n- `or`: Logical disjunction of multiple boolean expressions.\n- `is-eq`: Checks if two values are equal.\n\n## Conclusion\n\nThe `not` function is a fundamental tool for implementing logical negation in Clarity smart contracts. It allows you to invert boolean expressions, enabling robust and comprehensive boolean logic. When used effectively, `not` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage logical negation.\n"
  },
  {
    "title": "get-block-info?",
    "description": "Fetch information about Stacks blocks in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/get-block-info",
    "content": "\n<Callout>\nIn Clarity 3, this function is being deprecated for [`get-stacks-block-info?`](/stacks/clarity/functions/get-stacks-block-info).\n</Callout>\n\n## Function Signature\n\n```clarity\n(get-block-info? prop-name block-height)\n```\n\n- Input: \n  - `prop-name`: A BlockInfoPropertyName\n  - `block-height`: A uint representing the Stacks block height\n- Output: `(optional buff) | (optional uint) | (optional principal)` depending on the property\n\n## Why it matters\n\nThe `get-block-info?` function is crucial for:\n\n1. Accessing historical block data within smart contracts.\n2. Implementing time-based logic using block information.\n3. Verifying block-related properties for security or validation purposes.\n4. Building applications that need to reference specific blockchain states.\n\n## When to use it\n\nUse `get-block-info?` when you need to:\n\n- Retrieve information about past Stacks blocks.\n- Implement logic that depends on block times or miner information.\n- Verify block hashes or other block-specific data.\n- Access block rewards or miner spending data (in Stacks 2.1+).\n\n## Best Practices\n\n- Always check if the returned value is `none`, as it will be for non-existent or future blocks.\n- Be aware of the potential for chain reorganizations when using recent block data.\n- Use the appropriate property name for the data you need to retrieve.\n- Consider caching results for frequently accessed block information to save on execution costs.\n\n## Practical Example: Block Time Verification\n\nLet's implement a function that checks if a given block was mined after a certain time:\n\n```clarity\n(define-read-only (block-after-time? (blockHeight uint) (targetTime uint))\n  (match (get-block-info? time blockHeight) time\n    (> time targetTime)\n    false\n  )\n)\n\n;; Usage\n(block-after-time? u100 u1600000000) ;; Returns true if block 100 was mined after Unix timestamp 1600000000\n```\n\nThis example demonstrates:\n1. Using `get-block-info?` to retrieve the `time` property of a block.\n2. Handling the optional return value with `match`.\n3. Comparing the block time to a target time.\n\n## Available Properties\n\n- `burnchain-header-hash`: Returns the burnchain block header hash (buff 32).\n- `id-header-hash`: Returns the Stacks block's index block hash (buff 32).\n- `header-hash`: Returns the Stacks block's header hash (buff 32).\n- `miner-address`: Returns the block miner's principal.\n- `time`: Returns the block time as a Unix epoch timestamp (uint).\n\nNew in Stacks 2.1:\n- `block-reward`: Returns the total block reward (uint).\n- `miner-spend-total`: Returns the total spent by miners for this block (uint).\n\n## Common Pitfalls\n\n1. Assuming all properties are available for all blocks (e.g., `block-reward` is only available for mature blocks).\n2. Not handling the `none` case when the block height is invalid or in the future.\n3. Relying on exact block times, which can be inaccurate up to two hours.\n4. Using `header-hash` when global uniqueness is required (use `id-header-hash` instead).\n\n## Related Functions\n\n- `get-burn-block-info?`: Used to get information about the underlying burn chain blocks.\n- `block-height`: Keyword that returns the current block height.\n- `burn-block-height`: Keyword that returns the current burn chain block height.\n\n## Conclusion\n\nThe `get-block-info?` function is a powerful tool for accessing historical block data in Clarity smart contracts. It allows you to incorporate block-specific information into your contract logic, enabling a wide range of applications that can reference and utilize blockchain state. When used correctly, it provides valuable insights into the Stacks blockchain's history and can be used to implement sophisticated, time-aware contract behaviors.\n"
  },
  {
    "title": "string-to-uint?",
    "description": "Convert a string to an optional unsigned integer in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/string-to-uint",
    "content": "\n## Function Signature\n\n```clarity\n(string-to-uint? string)\n```\n\n- Input: `(string-ascii 1048576) | (string-utf8 262144)`\n- Output: `(optional uint)`\n\n## Why it matters\n\nThe `string-to-uint?` function is crucial for:\n\n1. Converting string representations of numbers to unsigned integers.\n2. Implementing logic that requires numeric values from string inputs.\n3. Ensuring data integrity by validating string-to-unsigned-integer conversions.\n4. Simplifying the process of handling numeric conversions in smart contracts.\n\n## When to use it\n\nUse `string-to-uint?` when you need to:\n\n- Convert a string representation of a number to an unsigned integer.\n- Implement logic that requires numeric values from string inputs.\n- Validate string-to-unsigned-integer conversions to ensure data integrity.\n- Handle numeric conversions in your smart contract.\n\n## Best Practices\n\n- Ensure the input string is correctly formatted and represents a valid unsigned integer.\n- Use meaningful variable names for better readability.\n- Combine with other string and numeric functions for comprehensive data management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Converting a String to an Unsigned Integer\n\nLet's implement a function that converts a string to an optional unsigned integer:\n\n```clarity\n(define-read-only (convert-string-to-uint (input (string-ascii 20)))\n  (string-to-uint? input)\n)\n\n;; Usage\n(convert-string-to-uint \"123\") ;; Returns (some u123)\n(convert-string-to-uint \"456\") ;; Returns (some u456)\n(convert-string-to-uint \"abc\") ;; Returns none\n```\n\nThis example demonstrates:\n1. Using `string-to-uint?` to convert a string to an optional unsigned integer.\n2. Implementing a public function to handle the string-to-unsigned-integer conversion.\n3. Handling both valid and invalid string inputs.\n\n## Common Pitfalls\n\n1. Using `string-to-uint?` with incorrectly formatted or invalid string inputs, causing the operation to return `none`.\n2. Assuming the conversion will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `string-to-int?`: Converts a string to an optional signed integer.\n- `int-to-ascii`: Converts an integer to a string-ascii representation.\n- `int-to-utf8`: Converts an integer to a string-utf8 representation.\n\n## Conclusion\n\nThe `string-to-uint?` function is a fundamental tool for converting string representations of numbers to unsigned integers in Clarity smart contracts. It allows you to implement logic that requires numeric values from string inputs, ensuring data integrity and simplifying numeric conversions. When used effectively, `string-to-uint?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle string-to-unsigned-integer conversions.\n"
  },
  {
    "title": "buff-to-uint-le",
    "description": "Convert a byte buffer to an unsigned integer using little-endian encoding in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/buff-to-uint-le",
    "content": "\n## Function Signature\n\n```clarity\n(buff-to-uint-le (buff 16))\n```\n\n- Input: A byte buffer of up to 16 bytes\n- Output: An unsigned integer (`uint`)\n\n## Why it matters\n\nThe `buff-to-uint-le` function is crucial for:\n\n1. Converting byte data to unsigned integers using little-endian encoding.\n2. Handling data from external sources or other contracts that use little-endian encoding.\n3. Implementing protocols or algorithms that require little-endian integer representation.\n4. Interoperating with systems that use little-endian byte order.\n\n## When to use it\n\nUse the `buff-to-uint-le` function when you need to:\n\n- Convert a little-endian encoded byte buffer to an unsigned integer.\n- Process input data that represents unsigned integers in little-endian format.\n- Implement cryptographic or mathematical operations that expect little-endian integer inputs.\n- Ensure compatibility with external systems using little-endian encoding.\n\n## Best Practices\n\n- Ensure the input buffer is no larger than 16 bytes to avoid errors.\n- Be aware that smaller buffers are zero-padded on the right, affecting the resulting integer value.\n- Use `buff-to-int-le` if you need to handle signed integers instead.\n- Handle potential errors when the input buffer might be invalid or empty.\n\n## Practical Example: Decoding an Unsigned Integer from External Data\n\nLet's implement a function that processes external data containing a little-endian encoded unsigned integer:\n\n```clarity\n(define-read-only (process-external-data-le (data (buff 16)))\n  (let\n    (\n      (value (buff-to-uint-le data))\n    )\n    (if (> value u1000000)\n      (err \"Value too large\")\n      (ok value)\n    )\n  )\n)\n\n;; Usage\n(process-external-data-le 0x01000000) ;; Returns (ok u1)\n(process-external-data-le 0x40420f00) ;; Returns (ok u1000000)\n(process-external-data-le 0x80969800) ;; Returns (err \"Value too large\")\n```\n\nThis example demonstrates:\n1. Using `buff-to-uint-le` to convert external data to an unsigned integer.\n2. Implementing input validation based on the converted integer value.\n3. Handling different input sizes and values.\n\n## Common Pitfalls\n\n1. Confusing little-endian with big-endian encoding, leading to incorrect integer values.\n2. Not considering the full range of possible uint values when processing the result.\n3. Assuming a specific buffer length, which could lead to unexpected results with shorter inputs due to right-padding.\n\n## Related Functions\n\n- `buff-to-uint-be`: Converts a byte buffer to an unsigned integer using big-endian encoding.\n- `buff-to-int-le`: Converts a byte buffer to a signed integer using little-endian encoding.\n- `uint-to-buff`: Converts an unsigned integer to a byte buffer.\n\n## Conclusion\n\nThe `buff-to-uint-le` function is a powerful tool for working with little-endian encoded unsigned integers in Clarity smart contracts. By understanding its behavior with different input sizes and potential edge cases, you can effectively process and validate external data, implement complex algorithms, and ensure compatibility with little-endian systems in your smart contract applications.\n"
  },
  {
    "title": "unwrap-err!",
    "description": "Unpack error responses in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/unwrap-err",
    "content": "\n## Function Signature\n\n```clarity\n(unwrap-err! response-input thrown-value)\n```\n\n- Input: `(response A B), C`\n- Output: `B`\n\n## Why it matters\n\nThe `unwrap-err!` function is crucial for:\n\n1. Unpacking error responses to access their inner values.\n2. Implementing logic that requires handling error responses.\n3. Ensuring data integrity by validating the error unpacking process.\n4. Simplifying the process of handling error responses in smart contracts.\n\n## When to use it\n\nUse `unwrap-err!` when you need to:\n\n- Unpack error responses to access their inner values.\n- Implement logic that requires handling error responses.\n- Validate the error unpacking process to ensure data integrity.\n- Handle error responses in your smart contract.\n\n## Best Practices\n\n- Ensure the input value is a response type.\n- Use meaningful variable names for better readability.\n- Combine with other error handling functions for comprehensive error management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Unpacking an Error Response\n\nLet's implement a function that processes an error response using `unwrap-err!`:\n\n```clarity\n(define-public (process-error-response (input (response int int)))\n  (let\n    (\n      (errorValue (unwrap-err! input (err \"No error found\")))\n    )\n    (ok errorValue)\n  )\n)\n\n;; Usage\n(process-error-response (err 42)) ;; Returns (ok 42)\n(process-error-response (ok 1)) ;; Returns (err \"No error found\")\n```\n\nThis example demonstrates:\n1. Using `unwrap-err!` to unpack an error response.\n2. Implementing a public function to handle the error unpacking process.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `unwrap-err!` with values that are not response types, causing runtime errors.\n2. Assuming the error unpacking will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete error management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `unwrap!`: Unpacks optional and response types, returning a thrown value if unpacking fails.\n- `unwrap-panic`: Unpacks optional and response types, throwing a runtime error if unpacking fails.\n- `try!`: Unpacks optional and response types, returning `none` or the `err` value if unpacking fails.\n\n## Conclusion\n\nThe `unwrap-err!` function is a fundamental tool for unpacking error responses in Clarity smart contracts. It allows you to implement logic that requires handling error responses, ensuring data integrity and simplifying the error unpacking process. When used effectively, `unwrap-err!` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle error responses.\n"
  },
  {
    "title": "define-fungible-token",
    "description": "Define a new fungible token in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/define-fungible-token",
    "content": "\n## Function Signature\n\n```clarity\n(define-fungible-token token-name <total-supply>)\n```\n\n- Input: \n  - `token-name`: The name of the fungible token\n  - `<total-supply>`: (Optional) An unsigned integer representing the total supply of tokens\n- Output: Not applicable (definition statement)\n\n## Why it matters\n\nThe `define-fungible-token` function is crucial for:\n\n1. Creating new fungible tokens within a smart contract.\n2. Establishing a token economy or system within your dApp.\n3. Implementing custom tokens with specific supply constraints.\n4. Enabling token-related operations like minting, transferring, and burning.\n\n## When to use it\n\nUse `define-fungible-token` when you need to:\n\n- Create a new fungible token for your smart contract or dApp.\n- Implement a token with a fixed total supply.\n- Establish a foundation for token-based features in your contract.\n- Create utility tokens, governance tokens, or other custom fungible assets.\n\n## Best Practices\n\n- Place `define-fungible-token` at the top level of your contract, as it's a definition statement.\n- Consider carefully whether to specify a total supply or leave it unlimited.\n- Use meaningful and descriptive names for your tokens.\n- Implement proper access controls for minting and burning operations if required.\n\n## Practical Example: Simple Token Creation\n\nLet's implement a basic fungible token with a fixed supply:\n\n```clarity\n(define-fungible-token DOG-GO-TO-THE-MOON u1000000)\n\n(define-data-var tokenAdmin principal tx-sender)\n\n(define-public (transfer (amount uint) (sender principal) (recipient principal))\n  (begin\n    (asserts! (is-eq tx-sender sender) (err u1))\n    (ft-transfer? DOG-GO-TO-THE-MOON amount sender recipient)\n  )\n)\n\n(define-read-only (get-balance (account principal))\n  (ok (ft-get-balance DOG-GO-TO-THE-MOON account))\n)\n\n(define-public (mint (amount uint) (recipient principal))\n  (begin\n    (asserts! (is-eq tx-sender (var-get tokenAdmin)) (err u3))\n    (ft-mint? DOG-GO-TO-THE-MOON amount recipient)\n  )\n)\n```\n\nThis example demonstrates:\n1. Using `define-fungible-token` to create a new token with a fixed supply of 1,000,000.\n2. Implementing basic token operations like transfer and balance checking.\n3. Adding a mint function with admin-only access control.\n\n## Common Pitfalls\n\n1. Forgetting that omitting the total supply parameter allows unlimited minting, if not handled manually.\n2. Not implementing proper access controls for sensitive operations like minting.\n3. Overlooking the need for additional functionality like burning or pausing.\n\n## Related Functions\n\n- `ft-transfer?`: Used to transfer tokens between principals.\n- `ft-mint?`: Used to create new tokens (if allowed by the token definition).\n- `ft-burn?`: Used to destroy tokens, reducing the circulating supply.\n- `ft-get-balance`: Used to check the token balance of a principal.\n- `ft-get-supply`: Used to get the current total supply of tokens.\n\n## Conclusion\n\nThe `define-fungible-token` function is a fundamental building block for creating token-based systems in Clarity smart contracts. It allows you to define custom fungible tokens with or without supply constraints. When combined with other token-related functions, it enables the implementation of sophisticated token economies and financial instruments on the Stacks blockchain.\n"
  },
  {
    "title": "at-block",
    "description": "Use the at-block function to evaluate expressions at a specific block in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/at-block",
    "content": "\n## Function Signature\n\n```clarity\n(at-block id-block-hash expr)\n```\n\n\n- Input: \n  - `id-block-hash`: A 32-byte buffer representing a block hash\n  - `expr`: An expression to be evaluated\n- Output: The result of evaluating `expr`\n\n## Why it matters\n\nThe `at-block` function is crucial for:\n\n1. Accessing historical contract state at a specific block.\n2. Implementing time-dependent logic based on blockchain state.\n3. Verifying past conditions or values in the contract.\n4. Creating mechanisms that depend on specific blockchain checkpoints.\n\n## When to use it\n\nUse the `at-block` function when you need to:\n\n- Evaluate contract state or expressions as they were at a specific past block.\n- Implement logic that depends on historical blockchain data.\n- Verify past conditions without relying on stored state.\n- Create time-locked or checkpoint-based features in your contract.\n\n## Best Practices\n\n- Only use `at-block` when historical data is necessary, as it can be computationally expensive.\n- Ensure the block hash used is from the `id-header-hash` property, not `header-hash`.\n- Use read-only expressions within `at-block` to maintain determinism.\n- Be aware of the potential for chain reorganizations when using recent block hashes.\n\n## Practical Example: Historical Price Check\n\nLet's implement a simple function that checks if a price was above a certain threshold at a specific block:\n\n```clarity\n(define-map AssetPrices uint uint)\n\n(define-public (set-price (price uint))\n  (ok (map-set AssetPrices block-height price))\n)\n\n(define-read-only (was-price-above-at-block (threshold uint) (blockHash (buff 32)))\n  (at-block blockHash\n    (let\n      (\n        (pastPrice (default-to u0 (map-get? AssetPrices block-height)))\n      )\n      (> pastPrice threshold)\n    )\n  )\n)\n\n;; Usage\n(set-price u100)\n;; ... several blocks later\n(was-price-above-at-block u50 0x123456...) ;; Returns true if the price was above 50 at the specified block\n```\n\n\nThis example demonstrates:\n1. Using `at-block` to evaluate a condition based on historical data.\n2. Combining `at-block` with map lookups to access past state.\n3. Implementing a read-only function that depends on blockchain history.\n\n## Common Pitfalls\n\n1. Using `header-hash` instead of `id-header-hash`, which can lead to inconsistencies across forks.\n2. Attempting to modify state within an `at-block` expression, which is not allowed.\n3. Overusing `at-block`, which can lead to performance issues due to the cost of historical lookups.\n\n## Related Functions\n\n- `get-block-info?`: Used to retrieve information about specific blocks.\n- `block-height`: Often used in conjunction with `at-block` for time-based logic.\n- `id-header-hash`: Provides the correct hash to use with `at-block`.\n\n## Conclusion\n\nThe `at-block` function is a powerful tool for implementing history-dependent logic in Clarity smart contracts. By allowing contracts to evaluate expressions as they would have at a specific past block, it enables sophisticated time-based mechanisms and historical verifications. However, this function should be used judiciously due to its potential performance impact and the complexities of working with blockchain history.\n"
  },
  {
    "title": "secp256k1-recover?",
    "description": "Recover the public key from a message hash and signature in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/secp256k1-recover",
    "content": "\n## Function Signature\n\n```clarity\n(secp256k1-recover? message-hash signature)\n```\n\n- Input: `(buff 32), (buff 65)`\n- Output: `(response (buff 33) uint)`\n\n## Why it matters\n\nThe `secp256k1-recover?` function is crucial for:\n\n1. Verifying the authenticity of a message by recovering the public key from a signature.\n2. Implementing cryptographic verification in smart contracts.\n3. Ensuring data integrity by validating signatures.\n4. Simplifying the process of handling cryptographic operations in smart contracts.\n\n## When to use it\n\nUse `secp256k1-recover?` when you need to:\n\n- Verify the authenticity of a message by recovering the public key from a signature.\n- Implement cryptographic verification in your smart contract.\n- Validate signatures to ensure data integrity.\n- Handle cryptographic operations.\n\n## Best Practices\n\n- Ensure the `message-hash` and `signature` are correctly formatted and valid.\n- Use meaningful variable names for better readability.\n- Combine with other cryptographic functions for comprehensive security management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Recovering a Public Key\n\nLet's implement a function that recovers the public key from a message hash and signature:\n\n```clarity\n(define-read-only (recover-public-key (messageHash (buff 32)) (signature (buff 65)))\n  (secp256k1-recover? messageHash signature)\n)\n\n;; Usage\n(recover-public-key 0xde5b9eb9e7c5592930eb2e30a01369c36586d872082ed8181ee83d2a0ec20f04 0x8738487ebe69b93d8e51583be8eee50bb4213fc49c767d329632730cc193b873554428fc936ca3569afc15f1c9365f6591d6251a89fee9c9ac661116824d3a1301) \n;; Returns (ok 0x03adb8de4bfb65db2cfd6120d55c6526ae9c52e675db7e47308636534ba7786110)\n```\n\nThis example demonstrates:\n1. Using `secp256k1-recover?` to recover a public key from a message hash and signature.\n2. Implementing a public function to handle the public key recovery.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `secp256k1-recover?` with incorrectly formatted or invalid `message-hash` or `signature`, causing the operation to fail.\n2. Assuming the public key will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete cryptographic verification.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `principal-of?`: Returns the principal derived from a public key.\n- `hash160`: Computes the RIPEMD-160 hash of the SHA-256 hash of the input.\n- `sha256`: Computes the SHA-256 hash of the input.\n\n## Conclusion\n\nThe `secp256k1-recover?` function is a fundamental tool for recovering public keys from message hashes and signatures in Clarity smart contracts. It allows you to verify the authenticity of messages, ensuring data integrity and simplifying cryptographic operations. When used effectively, `secp256k1-recover?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle cryptographic verification.\n"
  },
  {
    "title": "begin",
    "description": "Use the begin function to evaluate multiple expressions in sequence in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/begin",
    "content": "\n## Function Signature\n\n```clarity\n(begin expr1 expr2 expr3 ... expr-last)\n```\n\n\n- Input: Two or more expressions of any type\n- Output: The value of the last expression\n\n## Why it matters\n\nThe `begin` function is crucial for:\n\n1. Grouping multiple expressions into a single expression.\n2. Executing a series of operations in a specific order.\n3. Creating complex logic flows within functions or conditions.\n4. Allowing side effects while returning a specific value.\n\n## When to use it\n\nUse the `begin` function when you need to:\n\n- Perform multiple operations in sequence within a single expression.\n- Execute side effects before returning a final value.\n- Group multiple expressions where only one is allowed (e.g., in function bodies or condition branches).\n- Create more complex, multi-step logic within your smart contract functions.\n\n## Best Practices\n\n- Use `begin` to keep related operations together for better readability.\n- Ensure that any expressions that return a response type (ok or err) are properly checked.\n- Be mindful of the order of expressions, as they are evaluated sequentially.\n- Use `begin` to make your code more expressive and easier to understand.\n\n## Practical Example: User Registration with Logging\n\nLet's implement a simple user registration function that performs multiple actions:\n\n```clarity\n(define-map Users principal bool)\n(define-data-var userCount uint u0)\n\n(define-public (register-user)\n  (begin\n    (asserts! (is-none (map-get? Users tx-sender)) (err u1))\n    (map-set Users tx-sender true)\n    (var-set userCount (+ (var-get userCount) u1))\n    (print { registered: true, user: tx-sender })\n    (ok true)\n  )\n)\n\n;; Usage\n(register-user) ;; Returns (ok true) and logs the new user\n```\n\n\nThis example demonstrates:\n1. Using `begin` to group multiple operations in a single function.\n2. Performing checks, updates, and logging in a specific order.\n3. Executing side effects (printing) before returning the final value.\n\n## Common Pitfalls\n\n1. Forgetting to return a value in the last expression of a `begin` block.\n2. Not properly handling responses from functions that return (ok) or (err) within the `begin` block.\n3. Relying on side effects of earlier expressions without considering their order of execution.\n\n## Related Functions\n\n- `let`: Used for creating local bindings within a limited scope.\n- `asserts!`: Often used within `begin` blocks for condition checking.\n- `print`: Useful for logging within `begin` blocks during development.\n\n## Conclusion\n\nThe `begin` function is a fundamental tool in Clarity for grouping multiple expressions and creating more complex logic flows. By allowing you to execute a series of operations in a specific order while returning a single value, `begin` enhances the expressiveness and capability of Clarity smart contracts. When used judiciously, this function can significantly improve code readability and organization.\n"
  },
  {
    "title": "err",
    "description": "Construct error responses in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/err",
    "content": "\n## Function Signature\n\n```clarity\n(err value)\n```\n\n- Input: `value` - Any type A\n- Output: `(response A B)` where A is the type of the input value\n\n## Why it matters\n\nThe `err` function is crucial for:\n\n1. Creating standardized error responses in public functions.\n2. Indicating that a function execution has failed.\n3. Providing meaningful error information to callers.\n4. Triggering automatic rollback of any database changes during function execution.\n\n## When to use it\n\nUse `err` when you need to:\n\n- Return an error state from a public function.\n- Indicate that a condition or operation has failed.\n- Provide specific error information or codes to the caller.\n- Ensure that any state changes are reverted due to a failure condition.\n\n## Best Practices\n\n- Use descriptive error values that help diagnose the issue.\n- Consider using standardized error codes across your contract.\n- Pair `err` with `ok` to create comprehensive response handling.\n- Remember that returning an `err` will cause all state changes in the current function to be rolled back.\n\n## Practical Example: Token Transfer with Error Handling\n\nLet's implement a simple token transfer function with error handling:\n\n```clarity\n(define-map Balances principal uint)\n\n(define-public (transfer (amount uint) (recipient principal))\n  (let\n    (\n      (senderBalance (default-to u0 (map-get? Balances tx-sender)))\n    )\n    (if (>= senderBalance amount)\n      (begin\n        (map-set Balances tx-sender (- senderBalance amount))\n        (map-set Balances recipient (+ (default-to u0 (map-get? Balances recipient)) amount))\n        (ok true)\n      )\n      (err u1)\n    )\n  )\n)\n\n;; Usage\n(transfer u100 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM) ;; Returns (err u1) if balance is insufficient\n```\n\nThis example demonstrates:\n1. Using `err` to return an error when the sender has insufficient balance.\n2. Pairing `err` with `ok` to handle both success and failure cases.\n3. Using a simple error code (u1) to indicate the type of error.\n\n## Common Pitfalls\n\n1. Forgetting that returning an `err` will revert all state changes in the current function.\n2. Using non-descriptive error values that make debugging difficult.\n3. Inconsistent error handling across different functions in the contract.\n\n## Related Functions\n\n- `ok`: Used to construct successful responses in public functions.\n- `asserts!`: Often used with `err` for condition checking and error reporting.\n- `try!`: Used to propagate errors up the call stack.\n\n## Conclusion\n\nThe `err` function is a fundamental tool for error handling and response construction in Clarity smart contracts. By providing a standardized way to indicate and communicate errors, this function enables robust and predictable contract behavior. When used effectively in combination with `ok` and other error-handling mechanisms, `err` contributes to creating more reliable and maintainable smart contracts.\n"
  },
  {
    "title": "or",
    "description": "Logical disjunction in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/or",
    "content": "\n## Function Signature\n\n```clarity\n(or b1 b2 ...)\n```\n\n- Input: `bool, ...`\n- Output: `bool`\n\n## Why it matters\n\nThe `or` function is crucial for:\n\n1. Implementing logical disjunction in conditional statements.\n2. Simplifying the process of evaluating multiple boolean expressions.\n3. Enhancing code readability and maintainability by abstracting logical disjunction.\n\n## When to use it\n\nUse `or` when you need to:\n\n- Evaluate multiple boolean expressions and return `true` if any are `true`.\n- Implement logical disjunction in conditional statements.\n- Simplify and abstract the process of evaluating multiple boolean values.\n\n## Best Practices\n\n- Ensure all inputs are boolean expressions.\n- Use meaningful variable names for better readability.\n- Combine with other logical functions for comprehensive boolean logic.\n- Be aware of the performance implications of complex logical operations.\n\n## Practical Example: Evaluating Multiple Conditions\n\nLet's implement a function that checks if a number is either zero or negative:\n\n```clarity\n(define-read-only (is-zero-or-negative (n int))\n  (or (is-eq n 0) (< n 0))\n)\n\n;; Usage\n(is-zero-or-negative 5) ;; Returns false\n(is-zero-or-negative 0) ;; Returns true\n(is-zero-or-negative -3) ;; Returns true\n```\n\nThis example demonstrates:\n1. Using `or` to evaluate multiple boolean expressions.\n2. Implementing a read-only function to check if a number is either zero or negative.\n3. Handling both true and false cases.\n\n## Common Pitfalls\n\n1. Using `or` with non-boolean expressions, causing type errors.\n2. Assuming the result will always be true or false, leading to incorrect logic.\n3. Not handling all possible conditions, resulting in incomplete boolean logic.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `and`: Logical conjunction of multiple boolean expressions.\n- `not`: Logical negation of a boolean expression.\n- `is-eq`: Checks if two values are equal.\n\n## Conclusion\n\nThe `or` function is a fundamental tool for implementing logical disjunction in Clarity smart contracts. It allows you to evaluate multiple boolean expressions, enabling robust and comprehensive boolean logic. When used effectively, `or` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage logical disjunction.\n"
  },
  {
    "title": "try!",
    "description": "Handle errors in Clarity smart contracts using the `try!` function.",
    "slug": "/stacks/clarity/functions/try",
    "content": "\n## Function Signature\n\n```clarity\n(try! expression)\n```\n\n- Input: `expression` (of type `(response T E)`)\n- Output: `T` (if the response is `ok`) or causes a runtime error (if the response is `err`)\n\n## Why it matters\n\nThe `try!` function is crucial for:\n\n1. Simplifying error handling in Clarity smart contracts.\n2. Implementing logic that requires automatic error propagation.\n3. Ensuring data integrity by validating operations and handling errors gracefully.\n4. Simplifying the process of handling responses in smart contracts.\n\n## When to use it\n\nUse `try!` when you need to:\n\n- Simplify error handling in your smart contract.\n- Implement logic that requires automatic error propagation.\n- Validate operations and handle errors gracefully.\n- Handle responses in your smart contract.\n\n## Best Practices\n\n- Ensure the expression returns a response type `(response T E)`.\n- Use meaningful variable names for better readability.\n- Combine with other error handling functions for comprehensive error management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Handling Errors in a Transfer Function\n\nLet's implement a function that transfers STX and handles errors using `try!`:\n\n```clarity\n(define-public (transfer-stx (amount uint) (recipient principal))\n  (begin\n    (try! (stx-transfer? amount tx-sender recipient))\n    (ok true)\n  )\n)\n\n;; Usage\n(transfer-stx u60 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR) \n;; Returns (ok true) if successful\n(transfer-stx u50 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR) \n;; Returns (err u1) if the sender does not have enough balance\n```\n\nThis example demonstrates:\n1. Using `try!` to handle errors in a STX transfer operation.\n2. Implementing a public function to handle the transfer and error propagation.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `try!` with expressions that do not return a response type, causing runtime errors.\n2. Assuming the operation will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete error management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `unwrap!`: Unwraps an optional value, causing a runtime error if the value is `none`.\n- `asserts!`: Asserts a condition, causing a runtime error if the condition is false.\n- `is-err`: Checks if a response is an error.\n\n## Conclusion\n\nThe `try!` function is a fundamental tool for handling errors in Clarity smart contracts. It allows you to simplify error handling, ensuring data integrity and automatic error propagation. When used effectively, `try!` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle responses and errors.\n"
  },
  {
    "title": "map-insert",
    "description": "Insert an entry into a map in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/map-insert",
    "content": "\n## Function Signature\n\n```clarity\n(map-insert map-name key-tuple value-tuple)\n```\n\n- Input: `MapName, tuple_A, tuple_B`\n- Output: `bool`\n\n## Why it matters\n\nThe `map-insert` function is crucial for:\n\n1. Adding new entries to a map.\n2. Ensuring data integrity by preventing overwrites of existing entries.\n3. Simplifying the process of managing data in smart contracts.\n4. Enabling the creation of unique key-value pairs in maps.\n\n## When to use it\n\nUse `map-insert` when you need to:\n\n- Add a new entry to a map.\n- Ensure that existing entries are not overwritten.\n- Manage data in your smart contract.\n- Create unique key-value pairs in maps.\n\n## Best Practices\n\n- Ensure the key-tuple and value-tuple are correctly formatted.\n- Use meaningful variable names for better readability.\n- Combine with other map functions for comprehensive map management.\n- Handle the case where the key already exists to avoid unexpected behavior.\n\n## Practical Example: Inserting User Data\n\nLet's implement a function that inserts a user's data into a map:\n\n```clarity\n(define-map UserData { userId: principal } { data: (buff 32) })\n\n(define-public (insert-user-data (user principal) (data (buff 32)))\n  (ok (map-insert UserData { userId: user } { data: data }))\n)\n\n;; Usage\n(insert-user-data tx-sender 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef) ;; Returns (ok true) if the entry is inserted\n(insert-user-data tx-sender 0xabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdef) ;; Returns (ok false) if the entry already exists\n```\n\nThis example demonstrates:\n1. Using `map-insert` to add a user's data to the `UserData` map.\n2. Implementing a public function to insert the data.\n3. Handling both the case where the entry is successfully inserted and where it already exists.\n\n## Common Pitfalls\n\n1. Using `map-insert` with incorrectly formatted tuples, causing the insertion to fail.\n2. Assuming the entry will always be inserted, leading to unhandled cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `map-set`: Sets the value associated with a key in a map, overwriting any existing value.\n- `map-delete`: Removes an entry from a map.\n- `map-get?`: Retrieves an entry from a map.\n\n## Conclusion\n\nThe `map-insert` function is a fundamental tool for adding entries to maps in Clarity smart contracts. It allows you to manage data, ensure data integrity, and create unique key-value pairs. When used effectively, `map-insert` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage data insertion.\n"
  },
  {
    "title": "some",
    "description": "Construct an optional type from a value in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/some",
    "content": "\n## Function Signature\n\n```clarity\n(some value)\n```\n\n- Input: `A`\n- Output: `(optional A)`\n\n## Why it matters\n\nThe `some` function is crucial for:\n\n1. Constructing an optional type from a given value.\n2. Implementing logic that requires optional types.\n3. Ensuring data integrity by explicitly handling optional values.\n4. Simplifying the process of working with optional types in smart contracts.\n\n## When to use it\n\nUse `some` when you need to:\n\n- Construct an optional type from a given value.\n- Implement logic that requires optional types.\n- Explicitly handle optional values to ensure data integrity.\n- Work with optional types in your smart contract.\n\n## Best Practices\n\n- Ensure the value passed to `some` is the intended value to be wrapped in an optional type.\n- Use meaningful variable names for better readability.\n- Combine with other optional functions for comprehensive optional type management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Constructing an Optional Type\n\nLet's implement a function that constructs an optional type from a given integer:\n\n```clarity\n(define-read-only (wrap-in-optional (input int))\n  (some input)\n)\n\n;; Usage\n(wrap-in-optional 42) ;; Returns (some 42)\n(wrap-in-optional -1) ;; Returns (some -1)\n```\n\nThis example demonstrates:\n1. Using `some` to construct an optional type from a given integer.\n2. Implementing a public function to handle the optional type construction.\n3. Handling both positive and negative input values.\n\n## Common Pitfalls\n\n1. Using `some` without ensuring the value is the intended value to be wrapped, causing unexpected behavior.\n2. Assuming the optional type will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete optional type management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `is-some`: Checks if an optional type contains a value.\n- `is-none`: Checks if an optional type is empty.\n- `unwrap!`: Unwraps an optional type, returning the contained value or throwing an error if empty.\n\n## Conclusion\n\nThe `some` function is a fundamental tool for constructing optional types in Clarity smart contracts. It allows you to implement logic that requires optional types, ensuring data integrity and simplifying optional type handling. When used effectively, `some` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle optional type construction.\n"
  },
  {
    "title": "secp256k1-verify",
    "description": "Verify a signature against a message hash and public key in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/secp256k1-verify",
    "content": "\n## Function Signature\n\n```clarity\n(secp256k1-verify message-hash signature public-key)\n```\n\n- Input: `(buff 32), (buff 64) | (buff 65), (buff 33)`\n- Output: `bool`\n\n## Why it matters\n\nThe `secp256k1-verify` function is crucial for:\n\n1. Verifying the authenticity of a message by checking the signature against the public key.\n2. Implementing cryptographic verification in smart contracts.\n3. Ensuring data integrity by validating signatures.\n4. Simplifying the process of handling cryptographic operations in smart contracts.\n\n## When to use it\n\nUse `secp256k1-verify` when you need to:\n\n- Verify the authenticity of a message by checking the signature against the public key.\n- Implement cryptographic verification in your smart contract.\n- Validate signatures to ensure data integrity.\n- Handle cryptographic operations.\n\n## Best Practices\n\n- Ensure the `message-hash`, `signature`, and `public-key` are correctly formatted and valid.\n- Use meaningful variable names for better readability.\n- Combine with other cryptographic functions for comprehensive security management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Verifying a Signature\n\nLet's implement a function that verifies a signature against a message hash and public key:\n\n```clarity\n(define-read-only (verify-signature (messageHash (buff 32)) (signature (buff 65)) (publicKey (buff 33)))\n  (secp256k1-verify messageHash signature publicKey)\n)\n\n;; Usage\n(verify-signature 0xde5b9eb9e7c5592930eb2e30a01369c36586d872082ed8181ee83d2a0ec20f04 0x8738487ebe69b93d8e51583be8eee50bb4213fc49c767d329632730cc193b873554428fc936ca3569afc15f1c9365f6591d6251a89fee9c9ac661116824d3a1301 0x03adb8de4bfb65db2cfd6120d55c6526ae9c52e675db7e47308636534ba7786110) \n;; Returns true\n```\n\nThis example demonstrates:\n1. Using `secp256k1-verify` to verify a signature against a message hash and public key.\n2. Implementing a public function to handle the signature verification.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `secp256k1-verify` with incorrectly formatted or invalid `message-hash`, `signature`, or `public-key`, causing the operation to fail.\n2. Assuming the verification will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete cryptographic verification.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `secp256k1-recover?`: Recovers the public key from a message hash and signature.\n- `sha256`: Computes the SHA-256 hash of the input.\n- `hash160`: Computes the RIPEMD-160 hash of the SHA-256 hash of the input.\n\n## Conclusion\n\nThe `secp256k1-verify` function is a fundamental tool for verifying signatures against message hashes and public keys in Clarity smart contracts. It allows you to ensure data integrity and simplify cryptographic operations. When used effectively, `secp256k1-verify` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle cryptographic verification.\n"
  },
  {
    "title": "match",
    "description": "Handle different branches or cases in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/match",
    "content": "\n## Function Signature\n\n```clarity\n(match opt-input some-binding-name some-branch none-branch)\n(match-resp input ok-binding-name ok-branch err-binding-name err-branch)\n```\n\n- Input: `(optional A) name expression expression | (response A B) name expression name expression`\n- Output: `C`\n\n## Why it matters\n\nThe `match` function is crucial for:\n\n1. Handling different branches or cases for optional and response types.\n2. Simplifying complex conditional logic.\n3. Enhancing code readability and maintainability.\n4. Ensuring comprehensive handling of all possible cases.\n\n## When to use it\n\nUse `match` when you need to:\n\n- Handle different branches or cases for optional and response types.\n- Simplify complex conditional logic.\n- Enhance the readability and maintainability of your code.\n- Ensure comprehensive handling of all possible cases.\n\n## Best Practices\n\n- Ensure all possible branches are covered to avoid unhandled cases.\n- Use meaningful variable names for better readability.\n- Combine with other control flow functions for more complex logic.\n- Be aware of the performance implications of extensive branching.\n\n## Practical Example: Handling Optional and Response Values\n\nLet's implement functions that handle optional and response values using `match`:\n\n```clarity\n(define-private (add-10 (x (optional int)))  \n  (match x \n    value (+ 10 value)\n    10\n  )\n)\n(add-10 (some 5)) ;; Returns 15\n(add-10 none) ;; Returns 10\n\n(define-private (add-or-pass-err (x (response int (string-ascii 10))) (to-add int))  \n  (match x\n    value (ok (+ to-add value))\n    err-value (err err-value)\n  )\n)\n(add-or-pass-err (ok 5) 20) ;; Returns (ok 25)\n(add-or-pass-err (err \"ERROR\") 20) ;; Returns (err \"ERROR\")\n```\n\nThis example demonstrates:\n1. Using `match` to handle the result of an optional value.\n2. Using `match` to handle the result of a response value.\n3. Implementing functions to return the appropriate result based on the input type.\n\n## Common Pitfalls\n\n1. Using `match` without covering all possible branches, leading to unhandled cases.\n2. Assuming the value will always match a certain branch, causing runtime errors.\n3. Not handling all possible conditions, resulting in incomplete logic.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `if`: Implements conditional logic based on boolean expressions.\n- `let`: Binds variables to expressions within a local scope.\n- `default-to`: Provides default values for optional types.\n\n## Conclusion\n\nThe `match` function is a fundamental tool for handling different branches or cases in Clarity smart contracts. It allows you to manage optional and response types, simplify complex conditional logic, and ensure comprehensive handling of all possible cases. When used effectively, `match` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage branching logic.\n"
  },
  {
    "title": "let",
    "description": "Bind variables to expressions in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/let",
    "content": "\n## Function Signature\n\n```clarity\n(let ((name1 expr1) (name2 expr2) ...) expr-body1 expr-body2 ... expr-body-last)\n```\n\n- Input: `((name1 AnyType) (name2 AnyType) ...), AnyType, ... A`\n- Output: `A`\n\n## Why it matters\n\nThe `let` function is crucial for:\n\n1. Binding variables to expressions within a local scope.\n2. Simplifying complex expressions by breaking them into smaller parts.\n3. Improving code readability and maintainability.\n4. Enabling sequential evaluation of expressions.\n\n## When to use it\n\nUse `let` when you need to:\n\n- Bind variables to expressions within a local scope.\n- Simplify complex expressions by breaking them into smaller parts.\n- Improve the readability and maintainability of your code.\n- Ensure sequential evaluation of expressions.\n\n## Best Practices\n\n- Use meaningful variable names for better readability.\n- Ensure that the expressions are evaluated in the correct order.\n- Combine with other control flow functions for more complex logic.\n- Be aware that `let` bindings are sequential and can refer to prior bindings.\n\n## Practical Example: Calculating a Sum\n\nLet's implement a function that calculates the sum of two numbers using `let`:\n\n```clarity\n(define-public (calculate-sum (a int) (b int))\n  (let\n    (\n      (sum (+ a b))\n    )\n    (ok sum)\n  )\n)\n\n;; Usage\n(calculate-sum 3 5) ;; Returns (ok 8)\n```\n\nThis example demonstrates:\n1. Using `let` to bind the variable `sum` to the result of adding `a` and `b`.\n2. Returning the sum as the result of the function.\n3. Simplifying the function body by breaking it into smaller parts.\n\n## Common Pitfalls\n\n1. Using `let` bindings out of order, leading to incorrect evaluations.\n2. Not handling all possible conditions, resulting in incomplete logic.\n3. Overlooking the need for proper error handling and validation.\n4. Using `let` for simple expressions where it is not necessary.\n\n## Related Functions\n\n- `begin`: Evaluates multiple expressions sequentially, returning the last expression's value.\n- `if`: Implements conditional logic based on boolean expressions.\n- `match`: Used for pattern matching and handling multiple conditions.\n\n## Conclusion\n\nThe `let` function is a fundamental tool for binding variables to expressions in Clarity smart contracts. It allows you to simplify complex expressions, improve code readability, and ensure sequential evaluation of expressions. When used effectively, `let` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage local variables and expressions.\n"
  },
  {
    "title": "map-get?",
    "description": "Retrieve an entry from a map in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/map-get",
    "content": "\n## Function Signature\n\n```clarity\n(map-get? map-name key-tuple)\n```\n\n- Input: `MapName, tuple`\n- Output: `(optional (tuple))`\n\n## Why it matters\n\nThe `map-get?` function is crucial for:\n\n1. Retrieving entries from a map.\n2. Implementing logic that depends on the presence of map entries.\n3. Ensuring data integrity by checking for the existence of values.\n4. Simplifying the process of accessing stored data in smart contracts.\n\n## When to use it\n\nUse `map-get?` when you need to:\n\n- Retrieve an entry from a map.\n- Implement logic that depends on the presence of map entries.\n- Check for the existence of values in a map.\n- Access stored data in your smart contract.\n\n## Best Practices\n\n- Ensure the key-tuple accurately identifies the entry to be retrieved.\n- Use meaningful variable names for better readability.\n- Combine with other map functions for comprehensive map management.\n- Handle the `none` case to avoid runtime errors.\n\n## Practical Example: Retrieving User Data\n\nLet's implement a function that retrieves a user's data from a map:\n\n```clarity\n(define-map UserData { userId: principal } { data: (buff 32) })\n\n(define-read-only (get-user-data (user principal))\n  (map-get? UserData { userId: user })\n)\n\n;; Usage\n(map-set UserData { userId: tx-sender } { data: 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef })\n(get-user-data tx-sender) ;; Returns (some (tuple (data 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef)))\n(get-user-data 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns none\n```\n\nThis example demonstrates:\n1. Using `map-get?` to retrieve a user's data from the `UserData` map.\n2. Implementing a read-only function to return the retrieved data.\n3. Handling both the case where the user's data is present and where it is not.\n\n## Common Pitfalls\n\n1. Using `map-get?` with an incorrect key-tuple, causing the retrieval to fail.\n2. Assuming the entry will always exist, leading to unhandled `none` cases.\n3. Not handling all possible conditions, resulting in incomplete data retrieval.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `map-set`: Sets the value associated with a key in a map.\n- `map-delete`: Removes an entry from a map.\n- `map-insert`: Inserts a value into a map if the key does not already exist.\n\n## Conclusion\n\nThe `map-get?` function is a fundamental tool for retrieving entries from maps in Clarity smart contracts. It allows you to access stored data, implement logic based on map entries, and ensure data integrity. When used effectively, `map-get?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to retrieve map entries.\n"
  },
  {
    "title": "is-eq",
    "description": "Compare values for equality in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/is-eq",
    "content": "\n## Function Signature\n\n```clarity\n(is-eq v1 v2 ...)\n```\n\n\n\n\n- Input: `A, A, ...`\n- Output: `bool`\n\n## Why it matters\n\nThe `is-eq` function is crucial for:\n\n1. Comparing values to check for equality.\n2. Implementing conditional logic based on value comparisons.\n3. Ensuring data integrity by verifying that values match expected results.\n4. Simplifying equality checks in smart contract code.\n\n## When to use it\n\nUse `is-eq` when you need to:\n\n- Compare multiple values for equality.\n- Implement logic that depends on whether values are equal.\n- Verify that input values match expected constants or variables.\n- Simplify equality checks in your contract.\n\n## Best Practices\n\n- Ensure all values being compared are of the same type to avoid type errors.\n- Use `is-eq` for simple equality checks and combine with other logical functions for complex conditions.\n- Be aware that `is-eq` does not short-circuit; all values are evaluated.\n- Use meaningful variable names for better readability.\n\n## Practical Example: Checking User Role\n\nLet's implement a function that checks if a user has a specific role:\n\n```clarity\n(define-constant ADMIN_ROLE \"admin\")\n(define-map UserRoles { userId: principal } { role: (string-ascii 10) })\n\n(define-read-only (is-admin (user principal))\n  (let\n    (\n      (userRole (default-to \"none\" (map-get? UserRoles { userId: user })))\n    )\n    (is-eq userRole ADMIN_ROLE)\n  )\n)\n\n;; Usage\n(map-set UserRoles { userId: tx-sender } { role: \"admin\" })\n(is-admin tx-sender) ;; Returns true\n```\n\n\n\n\nThis example demonstrates:\n1. Using `is-eq` to compare a user's role with the constant `ADMIN_ROLE`.\n2. Handling the case where the user role is not set by providing a default value.\n3. Implementing a read-only function to check if a user is an admin.\n\n## Common Pitfalls\n\n1. Comparing values of different types, leading to type errors.\n2. Assuming `is-eq` short-circuits like `and` or `or` (it does not).\n3. Using `is-eq` for complex conditions where other logical functions might be more appropriate.\n4. Not handling cases where values might be `none` or unset.\n\n## Related Functions\n\n- `is-some`: Checks if an optional value is `some`.\n- `is-none`: Checks if an optional value is `none`.\n- `asserts!`: Asserts a condition and throws an error if it is false.\n\n## Conclusion\n\nThe `is-eq` function is a fundamental tool for comparing values in Clarity smart contracts. It provides a straightforward way to check for equality, enabling you to implement conditional logic and verify data integrity. When used effectively, `is-eq` simplifies equality checks and enhances the readability and maintainability of your smart contract code.\n"
  },
  {
    "title": "bit-shift-left",
    "description": "Use the bit-shift-left function for bitwise left shift operations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/bit-shift-left",
    "content": "\n## Function Signature\n\n```clarity\n(bit-shift-left i1 shamt)\n```\n\n- Input: \n  - `i1`: An integer (`int` or `uint`)\n  - `shamt`: A `uint` representing the number of places to shift\n- Output: An integer of the same type as `i1` (`int` or `uint`)\n\n## Why it matters\n\nThe `bit-shift-left` function is crucial for:\n\n1. Implementing certain bitwise algorithms and data structures.\n2. Manipulating binary data at the bit level.\n3. Creating bitmasks for various purposes.\n4. Low-level optimizations in specific scenarios.\n\n## When to use it\n\nUse the `bit-shift-left` function when you need to:\n\n- Implement certain cryptographic or hashing algorithms.\n- Perform low-level data manipulations involving binary operations.\n- Create specific bit patterns or masks.\n- Optimize certain bitwise operations.\n\n## Best Practices\n\n- Remember that shifting beyond the bit width of the integer (128 bits in Clarity) will result in zero.\n- Use `uint` for `shamt` to avoid potential issues with negative shift amounts.\n- Be aware of the potential for overflow when shifting left, especially with large numbers or shift amounts.\n- For multiplication by powers of 2, use the `pow` function instead, as it provides built-in overflow protection.\n\n## Practical Example: Flag Management\n\nLet's implement a simple flag management system using `bit-shift-left`:\n\n```clarity\n(define-constant FLAG_READ u1)\n(define-constant FLAG_WRITE u2)\n(define-constant FLAG_EXECUTE u4)\n\n(define-read-only (create-flag (flagPosition uint))\n  (bit-shift-left u1 flagPosition)\n)\n\n(define-read-only (set-flag (currentFlags uint) (flag uint))\n  (bit-or currentFlags flag)\n)\n\n(define-read-only (check-flag (flags uint) (flag uint))\n  (is-eq (bit-and flags flag) flag)\n)\n\n;; Usage\n(set-flag (bit-or FLAG_READ FLAG_WRITE) FLAG_EXECUTE) ;; Returns u7 (READ | WRITE | EXECUTE)\n(check-flag u7 FLAG_WRITE) ;; Returns true\n(check-flag u7 (create-flag u3)) ;; Returns false\n```\n\nThis example demonstrates:\n1. Using `bit-shift-left` to create individual flags.\n2. Combining `bit-shift-left` with `bit-or` to set flags.\n3. Using `bit-and` to check if a specific flag is set.\n\n## Common Pitfalls\n\n1. Using `bit-shift-left` for multiplication without considering overflow risks.\n2. Not considering the modulo behavior when shifting by amounts greater than or equal to 128.\n3. Using a negative or non-uint value for the shift amount, which is not allowed.\n\n## Related Functions\n\n- `bit-shift-right`: Used for right-shifting bits.\n- `bit-and`: Often used in combination with `bit-shift-left` for masking operations.\n- `bit-or`: Used for combining flags or masks created with `bit-shift-left`.\n- `pow`: Preferred for safe multiplication by powers of 2.\n\n## Conclusion\n\nThe `bit-shift-left` function is a powerful tool for bitwise operations in Clarity smart contracts. This function is essential for creating bitmasks, implementing various bitwise algorithms, and performing low-level optimizations. However, you should be cautious about potential overflows and avoid using it for general multiplication tasks, where the `pow` function is more appropriate due to its built-in overflow protection.\n"
  },
  {
    "title": "var-set",
    "description": "Set the value of a data variable in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/var-set",
    "content": "\n## Function Signature\n\n```clarity\n(var-set var-name expr1)\n```\n\n- Input: `VarName, AnyType`\n- Output: `bool`\n\n## Why it matters\n\nThe `var-set` function is crucial for:\n\n1. Setting the value of a data variable.\n2. Implementing logic that requires updating stored data.\n3. Ensuring data integrity by validating the update process.\n4. Simplifying the process of handling data variables in smart contracts.\n\n## When to use it\n\nUse `var-set` when you need to:\n\n- Set the value of a data variable.\n- Implement logic that requires updating stored data.\n- Validate the update process to ensure data integrity.\n- Handle data variables in your smart contract.\n\n## Best Practices\n\n- Ensure the variable name is correctly formatted and valid.\n- Use meaningful variable names for better readability.\n- Combine with other data functions for comprehensive data management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Setting a Data Variable\n\nLet's implement a function that sets the value of a data variable:\n\n```clarity\n(define-data-var cursor int 6)\n\n(define-public (increment-cursor)\n  (ok (var-set cursor (+ (var-get cursor) 1)))\n)\n\n;; Usage\n(increment-cursor) ;; Sets cursor to 7\n(var-get cursor) ;; Returns 7\n```\n\nThis example demonstrates:\n1. Using `var-set` to set the value of a data variable.\n2. Implementing a public function to handle the update process.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `var-set` with incorrectly formatted or invalid variable names, causing runtime errors.\n2. Assuming the update will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `var-get`: Retrieves the value of a data variable.\n- `map-set`: Sets a value in a map.\n- `default-to`: Provides a default value if an optional is `none`.\n\n## Conclusion\n\nThe `var-set` function is a fundamental tool for setting the value of a data variable in Clarity smart contracts. It allows you to implement logic that requires updating stored data, ensuring data integrity and simplifying the update process. When used effectively, `var-set` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle data variables.\n"
  },
  {
    "title": "less than or equal",
    "description": "Use the less than or equal function for comparisons in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/less-than-or-equal",
    "content": "\nThe less than or equal function (`<=`) in Clarity compares two values and returns true if the first value is less than or equal to the second. It's a fundamental comparison operation used in many smart contract conditions and logic flows.\n\n## Function Signature\n\n```clarity\n(<= v1 v2)\n```\n\n- Input: Two values of the same type (int, uint, string-ascii, string-utf8, or buff)\n- Output: A boolean (true or false)\n\n## Why it matters\n\nThe less than or equal function is crucial for:\n\n1. Implementing conditional logic in smart contracts.\n2. Comparing numerical values for financial operations.\n3. Ordering and sorting data.\n4. Implementing maximum thresholds or limits in contract logic.\n5. Checking for equality alongside less than comparisons.\n\n## When to use it\n\nUse the less than or equal function when you need to:\n\n- Compare two numerical values to determine if one is smaller or equal.\n- Implement maximum thresholds for certain operations, including the threshold value itself.\n- Create conditional logic based on numerical comparisons, including equality.\n- Sort or order data based on numerical or lexicographical order, including equal values.\n\n## Best Practices\n\n- Ensure that both inputs are of the same type to avoid runtime errors.\n- Be aware of the differences in comparison between signed (int) and unsigned (uint) integers.\n- When comparing strings or buffers, understand that the comparison is lexicographical.\n- Consider edge cases, especially when dealing with the limits of integer ranges.\n- Use `<=` instead of `<` when you want to include equality in your comparison.\n\n## Practical Example: Token Vesting Contract\n\nLet's implement a simple token vesting contract that uses the less than or equal function to manage vesting periods:\n\n```clarity\n;; Define constants\n(define-constant VESTING_PERIOD u31536000) ;; 1 year in seconds\n(define-constant TOTAL_ALLOCATION u1000000) ;; 1 million tokens\n\n;; Define data variables\n(define-data-var vestingStartTime uint u0)\n(define-data-var tokensClaimed uint u0)\n\n;; Function to start vesting\n(define-public (start-vesting)\n  (begin\n    (asserts! (is-eq (var-get vestingStartTime) u0) (err u1))\n    (var-set vestingStartTime block-height)\n    (ok true)\n  )\n)\n\n;; Function to calculate vested amount\n(define-read-only (get-vested-amount)\n  (let\n    (\n      (elapsed-time (- block-height (var-get vestingStartTime)))\n      (vesting-ratio (/ elapsed-time VESTING_PERIOD))\n    )\n    (if (<= elapsed-time VESTING_PERIOD)\n      (* TOTAL_ALLOCATION vesting-ratio)\n      TOTAL_ALLOCATION\n    )\n  )\n)\n\n;; Function to claim vested tokens\n(define-public (claim-tokens)\n  (let\n    (\n      (vested-amount (get-vested-amount))\n      (claimable-amount (- vested-amount (var-get tokensClaimed)))\n    )\n    (asserts! (> claimable-amount u0) (err u2))\n    (var-set tokensClaimed vested-amount)\n    ;; Here you would typically transfer tokens\n    ;; For simplicity, we're just returning the claimed amount\n    (ok claimable-amount)\n  )\n)\n```\n\nThis example demonstrates:\n1. Using `<=` to check if the elapsed time is within or equal to the vesting period.\n2. Combining the less than or equal check with other contract logic for a vesting system.\n3. Implementing a maximum threshold (the vesting period) that includes the exact end time.\n\n## Common Pitfalls\n\n1. Comparing values of different types, which will result in a runtime error.\n2. Confusing `<=` with `<` when setting thresholds, potentially excluding valid values.\n3. Overlooking the inclusive nature of `<=` in boundary conditions.\n\n## Related Functions\n\n- `<`: Used for strict less than comparisons.\n- `>`: Used for greater than comparisons.\n- `>=`: Used for greater than or equal to comparisons.\n\n## Conclusion\n\nThe less than or equal function is a fundamental tool for implementing comparison logic in Clarity smart contracts. By understanding its behavior with different types and potential edge cases, you can create robust conditional logic and enforce important thresholds in your contracts, including scenarios where equality is a valid condition.\n"
  },
  {
    "title": "filter",
    "description": "Filter elements from a list based on a predicate function in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/filter",
    "content": "\n## Function Signature\n\n```clarity\n(filter <function> <sequence>)\n```\n\n- Input: \n  - `<function>`: A function that takes one argument and returns a boolean\n  - `<sequence>`: A list, buffer, or string to iterate over\n- Output: A new list containing only the elements for which the function returned true\n\n## Why it matters\n\nThe `filter` function is crucial for:\n\n1. Selectively processing elements from a list based on specific criteria.\n2. Removing unwanted elements from a list without modifying the original.\n3. Implementing complex data filtering logic within smart contracts.\n4. Enhancing data manipulation capabilities in list processing.\n\n## When to use it\n\nUse `filter` when you need to:\n\n- Create a subset of a list based on certain conditions.\n- Remove elements from a list that don't meet specific criteria.\n- Implement data validation or selection logic on lists.\n- Prepare data for further processing by removing irrelevant elements.\n\n## Best Practices\n\n- Ensure the predicate function is efficient, especially for large lists.\n- Use `filter` in combination with other list functions like `map` or `fold` for complex list operations.\n- Be mindful of gas costs when filtering large lists.\n- Consider using `filter` with `define-private` functions for reusable filtering logic.\n\n## Practical Example: Filtering Even Numbers\n\nLet's implement a function that filters even numbers from a list:\n\n```clarity\n(define-private (is-even (num int))\n  (is-eq (mod num 2) 0)\n)\n\n(define-read-only (get-even-numbers (numbers (list 10 int)))\n  (filter is-even numbers)\n)\n\n;; Usage\n(get-even-numbers (list 1 2 3 4 5 6 7 8 9 10)) ;; Returns (2 4 6 8 10)\n```\n\nThis example demonstrates:\n1. Defining a private helper function `is-even` to check if a number is even.\n2. Using `filter` with the `is-even` function to create a new list of even numbers.\n3. Applying the filter operation to a list of integers.\n\n## Common Pitfalls\n\n1. Forgetting that `filter` creates a new list and does not modify the original.\n2. Using a computationally expensive predicate function, which could lead to high gas costs.\n3. Not considering the potential for an empty result list if no elements match the predicate.\n\n## Related Functions\n\n- `map`: Applies a function to each element in a list, transforming the elements.\n- `fold`: Reduces a list to a single value by applying a function to each element.\n- `len`: Can be used to check the length of the resulting filtered list.\n\n## Conclusion\n\nThe `filter` function is a powerful tool for list manipulation in Clarity smart contracts. It allows you to create refined subsets of data based on specific criteria, enhancing the contract's ability to process and analyze list-based information. When used effectively, `filter` can significantly improve the efficiency and clarity of list operations in smart contracts.\n"
  },
  {
    "title": "ft-mint?",
    "description": "Mint new fungible tokens in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/ft-mint",
    "content": "\n## Function Signature\n\n```clarity\n(ft-mint? token-name amount recipient)\n```\n\n- Input: \n  - `token-name`: The name of the fungible token\n  - `amount`: The amount of tokens to mint (uint)\n  - `recipient`: The principal to receive the newly minted tokens\n- Output: `(response bool uint)`\n\n## Why it matters\n\nThe `ft-mint?` function is crucial for:\n\n1. Creating new tokens and increasing the total supply of a fungible token.\n2. Implementing token issuance mechanisms in smart contracts.\n3. Rewarding users or other contracts with newly created tokens.\n4. Managing the token economy within a decentralized application.\n\n## When to use it\n\nUse `ft-mint?` when you need to:\n\n- Create new tokens as part of your contract's logic.\n- Implement token distribution mechanisms (e.g., airdrops, rewards).\n- Increase the balance of a specific principal with new tokens.\n- Execute token minting operations based on certain conditions or events.\n\n## Best Practices\n\n- Implement proper access controls to restrict who can mint new tokens.\n- Consider using a maximum supply cap to prevent unlimited minting.\n- Emit events or use a logging mechanism to track minting operations for transparency.\n- Be cautious of potential overflow when minting large amounts of tokens.\n\n## Practical Example: Reward Minting\n\nLet's implement a simple reward system that mints tokens:\n\n```clarity\n(define-fungible-token RewardToken)\n\n(define-constant CONTRACT_OWNER tx-sender)\n\n(define-public (mint-reward (amount uint) (recipient principal))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT_OWNER) (err u403))\n    (ft-mint? RewardToken amount recipient)\n  )\n)\n\n;; Usage\n(mint-reward u100 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (ok true) if called by CONTRACT_OWNER\n```\n\nThis example demonstrates:\n1. Using `ft-mint?` to create new tokens and assign them to a recipient.\n2. Implementing a basic access control check before minting.\n3. Returning the result of the minting operation.\n\n## Common Pitfalls\n\n1. Minting tokens without proper access controls, allowing unauthorized token creation.\n2. Not considering the total supply limit, potentially leading to economic imbalances.\n3. Forgetting to handle the error case when minting fails (e.g., due to supply cap).\n4. Overlooking the gas costs associated with minting, especially for large amounts.\n\n## Related Functions\n\n- `ft-burn?`: Used to destroy tokens, decreasing the total supply.\n- `ft-transfer?`: Used to transfer tokens between principals.\n- `ft-get-balance`: Used to check the token balance of a principal.\n- `ft-get-supply`: Used to get the current total supply of tokens.\n\n## Conclusion\n\nThe `ft-mint?` function is a fundamental tool for managing fungible token creation in Clarity smart contracts. It allows for controlled increase of token supply and distribution to specified recipients. When used responsibly with proper access controls and supply management, this function enables the implementation of sophisticated token economies within decentralized applications on the Stacks blockchain.\n"
  },
  {
    "title": "buff-to-int-le",
    "description": "Convert a byte buffer to a signed integer using little-endian encoding in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/buff-to-int-le",
    "content": "\n## Function Signature\n\n```clarity\n(buff-to-int-le (buff 16))\n```\n\n- Input: A byte buffer of up to 16 bytes\n- Output: A signed integer (`int`)\n\n## Why it matters\n\nThe `buff-to-int-le` function is crucial for:\n\n1. Converting byte data to signed integers using little-endian encoding.\n2. Handling data from external sources or other contracts that use little-endian encoding.\n3. Implementing protocols or algorithms that require little-endian integer representation.\n4. Interoperating with systems that use little-endian byte order.\n\n## When to use it\n\nUse the `buff-to-int-le` function when you need to:\n\n- Convert a little-endian encoded byte buffer to a signed integer.\n- Process input data that represents signed integers in little-endian format.\n- Implement cryptographic or mathematical operations that expect little-endian integer inputs.\n- Ensure compatibility with external systems using little-endian encoding.\n\n## Best Practices\n\n- Ensure the input buffer is no larger than 16 bytes to avoid errors.\n- Be aware that smaller buffers are zero-padded on the right, affecting the resulting integer value.\n- Consider using `buff-to-uint-le` for unsigned integers if the sign is not needed.\n- Handle potential errors when the input buffer might be invalid or empty.\n\n## Practical Example: Decoding a Signed Integer from External Data\n\nLet's implement a function that processes external data containing a little-endian encoded signed integer:\n\n```clarity\n(define-read-only (process-external-data-le (data (buff 16)))\n  (let\n    (\n      (value (buff-to-int-le data))\n    )\n    (if (< value 0)\n      (err \"Negative value not allowed\")\n      (ok value)\n    )\n  )\n)\n\n;; Usage\n(process-external-data-le 0x01000000000000000000000000000000) ;; Returns (ok 1)\n(process-external-data-le 0xffffffffffffffffffffffffffffffff) ;; Returns (err \"Negative value not allowed\")\n(process-external-data-le 0xffffffffffffffffffffffffffffff7f) ;; Returns (ok 9223372036854775807)\n```\n\nThis example demonstrates:\n1. Using `buff-to-int-le` to convert external data to a signed integer.\n2. Handling both positive and negative values resulting from the conversion.\n3. Implementing input validation based on the converted integer value.\n\n## Common Pitfalls\n\n1. Confusing little-endian with big-endian encoding, leading to incorrect integer values.\n2. Not handling potential negative values when working with signed integers.\n3. Assuming a specific buffer length, which could lead to unexpected results with shorter inputs due to right-padding.\n\n## Related Functions\n\n- `buff-to-int-be`: Converts a byte buffer to a signed integer using big-endian encoding.\n- `buff-to-uint-le`: Converts a byte buffer to an unsigned integer using little-endian encoding.\n- `int-to-ascii`: Converts an integer to its ASCII string representation.\n\n## Conclusion\n\nThe `buff-to-int-le` function is a powerful tool for working with little-endian encoded signed integers in Clarity smart contracts. By understanding its behavior with different input sizes and potential sign issues, you can effectively process and validate external data, implement complex algorithms, and ensure compatibility with little-endian systems in your smart contract applications.\n"
  },
  {
    "title": "element-at?",
    "description": "Retrieve an element from a list at a specific index in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/element-at",
    "content": "\n## Function Signature\n\n```clarity\n(element-at? list-expr uint)\n```\n\n- Input: \n  - `list-expr`: A list expression\n  - `uint`: An unsigned integer representing the index\n- Output: `(optional A)` where A is the type of elements in the list\n\n## Why it matters\n\nThe `element-at?` function is crucial for:\n\n1. Safely accessing elements in a list at a specific index.\n2. Handling potential out-of-bounds access without causing errors.\n3. Implementing logic that depends on retrieving specific elements from lists.\n4. Providing a way to work with lists in a more flexible manner.\n\n## When to use it\n\nUse `element-at?` when you need to:\n\n- Retrieve a specific element from a list by its position.\n- Implement algorithms that require access to list elements by index.\n- Safely handle potential out-of-bounds access in list operations.\n- Work with lists in a way that may involve accessing elements at varying positions.\n\n## Best Practices\n\n- Always check the returned optional value to handle cases where the index is out of bounds.\n- Use in combination with `len` to ensure you're not attempting to access beyond the list's length.\n- Consider using `map` or `fold` for operations that need to process all elements instead of accessing by index.\n- Be mindful of the zero-based indexing when using `element-at?`.\n\n## Practical Example: Retrieving a Specific Item\n\nLet's implement a function that retrieves an item from a todo list:\n\n```clarity\n(define-data-var todoList (list 10 (string-ascii 50)) (list))\n\n(define-public (add-todo (item (string-ascii 50)))\n  (let\n    (\n      (currentList (var-get todoList))\n      (newList (as-max-len? (append currentList item) u10))\n    )\n    (match newList\n      newListValue (ok (var-set todoList newListValue))\n      (err u1)\n    )\n  )\n)\n\n(define-read-only (get-todo (index uint))\n  (match (element-at? (var-get todoList) index) item\n    (ok item)\n    (err u404)\n  )\n)\n\n;; Usage\n(add-todo \"Buy milk\")\n(add-todo \"Walk the dog\")\n(get-todo u1) ;; Returns (ok \"Walk the dog\")\n(get-todo u5) ;; Returns (err u404)\n```\n\nThis example demonstrates:\n1. Using `element-at?` to retrieve an item from a list stored in a data variable.\n2. Handling the optional return value with `match` to provide meaningful responses.\n3. Safely accessing list elements without risking out-of-bounds errors.\n\n## Common Pitfalls\n\n1. Forgetting that list indices are zero-based in Clarity.\n2. Not handling the case where `element-at?` returns `none` for out-of-bounds access.\n3. Using `element-at?` in a loop to process all elements, which is less efficient than using `map` or `fold`.\n\n## Related Functions\n\n- `list`: Used to create lists that can be accessed with `element-at?`.\n- `len`: Often used in conjunction with `element-at?` to check list bounds.\n- `map`: An alternative for processing all elements in a list.\n- `fold`: Another alternative for reducing a list to a single value.\n\n## Clarity 1 Version: element-at\n\nIn Clarity 1, this function was named `element-at` (without the question mark) and had a slightly different behavior:\n\n```clarity\n(element-at list-expr uint)\n```\n\nThe key differences are:\n1. It returns the element directly, not wrapped in an optional.\n2. It throws a runtime error if the index is out of bounds.\n\nWhen migrating from Clarity 1 to newer versions, replace `element-at` with `element-at?` and add appropriate error handling for out-of-bounds cases.\n\n## Conclusion\n\nThe `element-at?` function is a safer and more flexible way to access list elements in Clarity smart contracts compared to its predecessor. By returning an optional value, this function allows you to handle out-of-bounds access gracefully, leading to more robust and error-resistant code. When working with lists in Clarity, `element-at?` is an essential tool for accessing specific elements while maintaining the integrity and safety of your contract operations.\n"
  },
  {
    "title": "sha512",
    "description": "Compute the SHA-512 hash of a value in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/sha512",
    "content": "\n## Function Signature\n\n```clarity\n(sha512 value)\n```\n\n- Input: `buff | uint | int`\n- Output: `(buff 64)`\n\n## Why it matters\n\nThe `sha512` function is crucial for:\n\n1. Computing the SHA-512 hash of a given value.\n2. Implementing cryptographic operations in smart contracts.\n3. Ensuring data integrity by generating unique hashes.\n4. Simplifying the process of handling cryptographic hashing in smart contracts.\n\n## When to use it\n\nUse `sha512` when you need to:\n\n- Compute the SHA-512 hash of a given value.\n- Implement cryptographic operations in your smart contract.\n- Generate unique hashes to ensure data integrity.\n- Handle cryptographic hashing operations.\n\n## Best Practices\n\n- Ensure the input value is correctly formatted and valid.\n- Use meaningful variable names for better readability.\n- Combine with other cryptographic functions for comprehensive security management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Computing a SHA-512 Hash\n\nLet's implement a function that computes the SHA-512 hash of a given buffer:\n\n```clarity\n(define-read-only (compute-sha512 (input (buff 32)))\n  (sha512 input)\n)\n\n;; Usage\n(compute-sha512 0x68656c6c6f20776f726c64000000000000000000000000000000000000000000)\n;; Returns 0x638f0da7489fae1f981a47199a2854d0fa117cea82bd86049930aa86e565c6cdccd52fc0e6bba5a135961ed5b7360d5e2b0ff65889acbac01361f5e291a6da45\n```\n\nThis example demonstrates:\n1. Using `sha512` to compute the hash of a given buffer.\n2. Implementing a public function to handle the hash computation.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `sha512` with incorrectly formatted or invalid input values, causing the operation to fail.\n2. Assuming the hash will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete cryptographic hashing.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `sha256`: Computes the SHA-256 hash of the input.\n- `sha512/256`: Computes the SHA-512/256 hash of the input.\n- `keccak256`: Computes the KECCAK-256 hash of the input.\n\n## Conclusion\n\nThe `sha512` function is a fundamental tool for computing SHA-512 hashes in Clarity smart contracts. It allows you to implement cryptographic operations, ensuring data integrity and simplifying cryptographic hashing. When used effectively, `sha512` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle cryptographic hashing operations.\n"
  },
  {
    "title": "concat",
    "description": "Concatenate sequences in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/concat",
    "content": "\n## Function Signature\n\n```clarity\n(concat sequence1 sequence2)\n```\n\n- Input: Two sequences of the same type (`sequence_A`, `sequence_A`)\n- Output: A concatenated sequence of the same type (`sequence_A`)\n\n## Why it matters\n\nThe `concat` function is crucial for:\n\n1. Combining two sequences of the same type into a single sequence.\n2. Building longer strings, buffers, or lists from smaller components.\n3. Dynamically constructing data structures in smart contracts.\n4. Implementing string or data manipulation operations.\n\n## When to use it\n\nUse the `concat` function when you need to:\n\n- Join two strings together.\n- Combine two byte buffers into a single buffer.\n- Merge two lists into a single list.\n- Build complex data structures from simpler components.\n\n## Best Practices\n\n- Ensure that both input sequences are of the same type (e.g., both strings, both buffers, or both lists).\n- Be aware of the maximum length limitations for the resulting sequence type.\n- Consider using `concat` in combination with other sequence manipulation functions for more complex operations.\n- When working with strings, remember that Clarity distinguishes between ASCII and UTF-8 strings.\n\n## Practical Example: Dynamic Message Construction\n\nLet's implement a function that constructs a personalized message:\n\n```clarity\n(define-public (create-greeting (name (string-ascii 20)))\n  (ok (concat (concat \"Hello, \" name) \"! Welcome to our dApp.\"))\n)\n\n;; Usage\n(create-greeting \"Alice\") ;; Returns (ok \"Hello, Alice! Welcome to our dApp.\")\n```\n\nThis example demonstrates:\n1. Using `concat` to join multiple string components.\n2. Nesting `concat` calls to build a more complex string.\n3. Combining static and dynamic parts of a message.\n\n## Common Pitfalls\n\n1. Attempting to concatenate sequences of different types, which will result in an error.\n2. Not considering the maximum length of the resulting sequence, potentially leading to truncation.\n3. Forgetting that `concat` only works with two sequences at a time, requiring nested calls for multiple concatenations.\n\n## Related Functions\n\n- `len`: Used to get the length of a sequence.\n- `slice?`: Can be used to extract parts of a sequence before concatenation.\n- `append`: Used to add elements to the end of a list (similar to `concat` for lists).\n\n## Conclusion\n\nThe `concat` function is a versatile tool for combining sequences in Clarity smart contracts. Whether you're working with strings, byte buffers, or lists, `concat` provides a straightforward way to join sequences together. By understanding its behavior and limitations, you can effectively use `concat` to build dynamic data structures and implement various string and data manipulation operations in your smart contracts.\n"
  },
  {
    "title": "index-of",
    "description": "Find the index of an element in a list in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/index-of",
    "content": "\n## Function Signature\n\n```clarity\n(index-of list element)\n```\n\n- Input: \n  - `list`: A list of elements\n  - `element`: The element to find in the list\n- Output: `(optional uint)`\n\n## Why it matters\n\nThe `index-of` function is crucial for:\n\n1. Locating the position of an element within a list.\n2. Implementing search functionality in smart contracts.\n3. Enabling conditional logic based on the presence and position of elements.\n4. Simplifying list operations by providing a built-in search mechanism.\n\n## When to use it\n\nUse `index-of` when you need to:\n\n- Determine the position of an element in a list.\n- Check if an element exists in a list and retrieve its index.\n- Implement logic that depends on the order or position of elements.\n- Simplify list search operations without writing custom loops.\n\n## Best Practices\n\n- Ensure the list and element types are compatible.\n- Handle the `none` case when the element is not found in the list.\n- Use meaningful variable names for better readability.\n- Consider the performance implications when searching large lists.\n\n## Practical Example: Finding an Element in a List\n\nLet's implement a function that finds the index of a given element in a list of integers:\n\n```clarity\n(define-read-only (find-index (element int) (numbers (list 10 int)))\n  (index-of numbers element)\n)\n\n;; Usage\n(find-index 3 (list 1 2 3 4 5)) ;; Returns (some u2)\n(find-index 6 (list 1 2 3 4 5)) ;; Returns none\n```\n\nThis example demonstrates:\n1. Using `index-of` to find the position of an element in a list.\n2. Handling both the case where the element is found and where it is not found.\n\n## Common Pitfalls\n\n1. Assuming the element will always be found, leading to unhandled `none` cases.\n2. Using `index-of` on lists with incompatible element types.\n3. Overlooking the performance impact of searching very large lists.\n4. Not considering that `index-of` returns a 0-based index.\n\n## Related Functions\n\n- `filter`: Used to create a new list containing only elements that match a condition.\n- `map`: Applies a function to each element in a list, transforming the elements.\n- `len`: Returns the length of a list.\n\n## Conclusion\n\nThe `index-of` function is a powerful tool for locating elements within lists in Clarity smart contracts. It provides a straightforward way to search for elements and retrieve their positions, enabling more complex list operations and conditional logic. When used effectively, `index-of` simplifies list search operations and enhances the readability and maintainability of your smart contract code.\n"
  },
  {
    "title": "stx-transfer-memo?",
    "description": "Transfer STX with a memo field in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/stx-transfer-memo",
    "content": "\n## Function Signature\n\n```clarity\n(stx-transfer-memo? amount sender recipient memo)\n```\n\n- Input: `uint, principal, principal, buff`\n- Output: `(response bool uint)`\n\n## Why it matters\n\nThe `stx-transfer-memo?` function is crucial for:\n\n1. Transferring STX between principals with an additional memo field.\n2. Implementing logic that requires recording a memo with each transfer.\n3. Ensuring data integrity by validating the transfer operation.\n4. Simplifying the process of handling STX transfers with memos in smart contracts.\n\n## When to use it\n\nUse `stx-transfer-memo?` when you need to:\n\n- Transfer STX between principals with an additional memo field.\n- Implement logic that requires recording a memo with each transfer.\n- Validate the transfer operation to ensure data integrity.\n- Handle STX transfers with memos in your smart contract.\n\n## Best Practices\n\n- Ensure the `amount` is positive and the `sender` has sufficient balance.\n- Use meaningful variable names for better readability.\n- Combine with other STX functions for comprehensive account management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Transferring STX with a Memo\n\nLet's implement a function that transfers STX with a memo from the `tx-sender` to a recipient:\n\n```clarity\n(define-public (transfer-stx-with-memo (amount uint) (recipient principal) (memo (buff 34)))\n  (stx-transfer-memo? amount tx-sender recipient memo)\n)\n\n;; Usage\n(transfer-stx-with-memo u60 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR 0x010203) \n;; Returns (ok true) if successful\n(transfer-stx-with-memo u50 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR 0x040506) \n;; Returns (err u1) if the sender does not have enough balance\n```\n\nThis example demonstrates:\n1. Using `stx-transfer-memo?` to transfer STX with a memo.\n2. Implementing a public function to handle the STX transfer with a memo.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `stx-transfer-memo?` with a non-positive amount, causing the operation to fail.\n2. Assuming the transfer operation will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete account management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `stx-get-balance`: Queries the STX balance of a principal.\n- `stx-transfer?`: Transfers STX from one principal to another without a memo.\n- `stx-burn?`: Burns STX from a principal's account.\n\n## Conclusion\n\nThe `stx-transfer-memo?` function is a fundamental tool for transferring STX with a memo in Clarity smart contracts. It allows you to implement logic that requires recording a memo with each transfer, ensuring data integrity and simplifying STX transfer operations. When used effectively, `stx-transfer-memo?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle STX transfers with memos.\n"
  },
  {
    "title": "pow",
    "description": "Calculate the power of a number in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/pow",
    "content": "\n## Function Signature\n\n```clarity\n(pow base exponent)\n```\n\n- Input: `int, int | uint, uint`\n- Output: `int | uint`\n\n## Why it matters\n\nThe `pow` function is crucial for:\n\n1. Performing exponentiation operations.\n2. Implementing logic that depends on power calculations.\n3. Simplifying the process of raising numbers to a power.\n4. Enhancing code readability and maintainability by abstracting exponentiation.\n\n## When to use it\n\nUse `pow` when you need to:\n\n- Perform exponentiation operations.\n- Implement logic that depends on power calculations.\n- Raise numbers to a power.\n- Simplify and abstract exponentiation operations.\n\n## Best Practices\n\n- Ensure the base and exponent are correctly formatted and within acceptable ranges.\n- Use meaningful variable names for better readability.\n- Combine with other mathematical functions for comprehensive calculations.\n- Be aware of the performance implications of large exponentiation operations.\n\n## Practical Example: Calculating Token Balances in Decimal Format\n\nLet's implement a function that calculates the power of a number, specifically for converting integer representations of tokens or uStx:\n\n```clarity\n(define-constant MICRO_TOKENS (pow u10 u6)) ;; 6 decimal places\n(define-data-var userBalance uint u100) ;; Amount reprented in a clear and readable format\n\n(define-read-only (get-total-micro-balance (userAddress principal))\n  (* (var-get userBalance) MICRO_TOKENS)\n)\n\n;; Usage\n(get-total-micro-balance tx-sender)\n```\n\nThis example demonstrates:\n1. Using `pow` to define a constant for micro tokens with 6 decimal places.\n2. Implementing a read-only function to calculate the total balance in decimal format.\n3. Handling balances from different versions of a token contract.\n\n## Common Pitfalls\n\n1. Using `pow` with negative exponents, which is not supported and will cause a runtime error.\n2. Assuming the result will always be within acceptable ranges, leading to overflow errors.\n3. Not handling all possible conditions, resulting in incomplete calculations.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `*`: Multiplies two or more numbers.\n- `+`: Adds two or more numbers.\n- `-`: Subtracts one number from another.\n- `/`: Divides one number by another.\n\n## Conclusion\n\nThe `pow` function is a fundamental tool for performing exponentiation in Clarity smart contracts. It allows you to raise numbers to a power, enabling robust and comprehensive mathematical operations. When used effectively, `pow` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage power calculations.\n"
  },
  {
    "title": "nft-mint?",
    "description": "Mint a non-fungible token (NFT) in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/nft-mint",
    "content": "\n## Function Signature\n\n```clarity\n(nft-mint? asset-class asset-identifier recipient)\n```\n\n- Input: `AssetName, A, principal`\n- Output: `(response bool uint)`\n\n## Why it matters\n\nThe `nft-mint?` function is crucial for:\n\n1. Creating new non-fungible tokens (NFTs).\n2. Assigning ownership of newly created NFTs.\n3. Ensuring data integrity by preventing duplicate NFT creation.\n4. Simplifying the process of minting NFTs in smart contracts.\n\n## When to use it\n\nUse `nft-mint?` when you need to:\n\n- Create a new NFT.\n- Assign ownership of a newly created NFT.\n- Prevent duplicate NFT creation.\n- Handle NFT minting operations in your smart contract.\n\n## Best Practices\n\n- Ensure the `asset-identifier` is unique and correctly formatted.\n- Use meaningful variable names for better readability.\n- Combine with other NFT functions for comprehensive NFT management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Minting an NFT\n\nLet's implement a function that mints a new NFT and assigns it to the recipient:\n\n```clarity\n(define-non-fungible-token Stackaroo (string-ascii 40))\n\n(define-public (mint-nft (id (string-ascii 40)) (recipient principal))\n  (nft-mint? Stackaroo id recipient)\n)\n\n;; Usage\n(mint-nft \"Roo\" tx-sender) ;; Returns (ok true)\n(mint-nft \"Roo\" tx-sender) ;; Returns (err u1) because the asset already exists\n```\n\nThis example demonstrates:\n1. Using `nft-mint?` to create a new NFT and assign it to the recipient.\n2. Implementing a public function to handle the minting operation.\n3. Handling both the successful mint and the case where the asset already exists.\n\n## Common Pitfalls\n\n1. Using `nft-mint?` with a non-unique `asset-identifier`, causing the operation to fail.\n2. Assuming the NFT will always be minted, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete NFT management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `nft-get-owner?`: Retrieves the owner of a non-fungible token.\n- `nft-transfer?`: Transfers ownership of a non-fungible token.\n- `nft-burn?`: Burns a non-fungible token.\n\n## Conclusion\n\nThe `nft-mint?` function is a fundamental tool for creating non-fungible tokens in Clarity smart contracts. It allows you to mint new NFTs, assign ownership, and ensure data integrity by preventing duplicate NFT creation. When used effectively, `nft-mint?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage NFT minting operations.\n"
  },
  {
    "title": "bit-not",
    "description": "Use the bit-not function for bitwise complement operations in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/bit-not",
    "content": "\n## Function Signature\n\n```clarity\n(bit-not i1)\n```\n\n- Input: An integer (`int` or `uint`)\n- Output: An integer of the same type as the input (`int` or `uint`)\n\n## Why it matters\n\nThe `bit-not` function is crucial for:\n\n1. Performing bitwise complement operations in smart contracts.\n2. Implementing certain logical operations and algorithms.\n3. Manipulating binary data at the bit level.\n4. Creating bitmasks for various purposes.\n\n## When to use it\n\nUse the `bit-not` function when you need to:\n\n- Invert all bits in an integer value.\n- Create a bitmask for bitwise operations.\n- Implement certain cryptographic or hashing algorithms.\n- Perform low-level data manipulations.\n\n## Best Practices\n\n- Be aware of the differences between signed (`int`) and unsigned (`uint`) integers when using `bit-not`.\n- Remember that `bit-not` on a `uint` will result in a large positive number due to two's complement representation.\n- Use `bit-not` in combination with other bitwise operations (`bit-and`, `bit-or`, `bit-xor`) for complex bit manipulations.\n- Consider the readability of your code when using bitwise operations extensively.\n\n## Practical Example: Simple Flag System\n\nLet's implement a simple flag system using `bit-not` and other bitwise operations:\n\n```clarity\n(define-constant FLAG_A u1)  ;; 0001\n(define-constant FLAG_B u2)  ;; 0010\n(define-constant FLAG_C u4)  ;; 0100\n(define-constant FLAG_D u8)  ;; 1000\n\n(define-data-var userFlags uint u0)\n\n(define-public (toggle-flag (flag uint))\n  (ok (var-set userFlags (bit-xor (var-get userFlags) flag)))\n)\n\n(define-public (clear-all-flags-except (flag uint))\n  (ok (var-set userFlags (bit-and (var-get userFlags) flag)))\n)\n\n(define-public (set-all-flags-except (flag uint))\n  (ok (var-set userFlags (bit-and (bit-not (var-get userFlags)) flag)))\n)\n\n(define-read-only (has-flag (flag uint))\n  (is-eq flag (bit-and (var-get userFlags) flag))\n)\n```\n\nThis example demonstrates:\n1. Using `bit-not` in combination with `bit-and` to set all flags except a specific one.\n2. Implementing a flag system using bitwise operations for efficient storage and manipulation.\n3. Combining `bit-not` with other bitwise operations for complex flag manipulations.\n\n## Common Pitfalls\n\n1. Forgetting that `bit-not` on a `uint` results in a large positive number, not a negative number.\n2. Overlooking the sign bit when using `bit-not` with signed integers.\n3. Not considering the full range of bits when applying `bit-not` to smaller integer values.\n\n## Related Functions\n\n- `bit-and`: Used for bitwise AND operations.\n- `bit-or`: Used for bitwise OR operations.\n- `bit-xor`: Used for bitwise XOR operations.\n- `bit-shift-left`: Used for left-shifting bits.\n- `bit-shift-right`: Used for right-shifting bits.\n\n## Conclusion\n\nThe `bit-not` function is a powerful tool for bitwise operations in Clarity smart contracts. When used in combination with other bitwise functions, this function enables efficient implementation of flags, bitmasks, and low-level data manipulations. However, you should be mindful of the differences between signed and unsigned integers and the potential for unexpected results when not used carefully.\n"
  },
  {
    "title": "hash160",
    "description": "Compute the RIPEMD160(SHA256(x)) hash in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/hash160",
    "content": "\n## Function Signature\n\n```clarity\n(hash160 value)\n```\n\n- Input: `buff|uint|int`\n- Output: `(buff 20)`\n\n## Why it matters\n\nThe `hash160` function is crucial for:\n\n1. Creating compact, unique identifiers for data or addresses.\n2. Implementing cryptographic operations commonly used in blockchain systems.\n3. Generating Bitcoin-style addresses from public keys.\n4. Providing a way to create short, collision-resistant hashes.\n\n## When to use it\n\nUse `hash160` when you need to:\n\n- Generate a compact hash of data, especially for address creation.\n- Implement Bitcoin-style address generation within Clarity contracts.\n- Create short, unique identifiers for data structures.\n- Perform cryptographic operations that require RIPEMD160(SHA256(x)).\n\n## Best Practices\n\n- Use `hash160` when you need a shorter hash than SHA256 but still want strong collision resistance.\n- Be aware that `hash160` is not reversible; it's a one-way function.\n- When hashing sensitive data, consider using additional security measures like salting.\n- Remember that for integers, the hash is computed over their little-endian representation.\n\n## Practical Example: Simple Address Generation\n\nLet's implement a function that generates a simple hash-based identifier:\n\n```clarity\n(define-read-only (generate-identifier (input (buff 32)))\n  (hash160 input)\n)\n\n;; Usage\n(generate-identifier 0x000000000000000000000000000000000000000000000000000000000000000a)\n;; Returns 0x3bf3d2e8f7a4d7c5f9e6d0d5c6b0f5c7d8e9f0a1\n```\n\nThis example demonstrates:\n1. Using `hash160` to create a compact identifier from input data.\n2. The function takes a 32-byte buffer and returns a 20-byte hash.\n\n## Common Pitfalls\n\n1. Assuming `hash160` output is the same length as `sha256` output (it's shorter at 20 bytes).\n2. Using `hash160` where a longer hash might be more appropriate for security reasons.\n3. Forgetting that integer inputs are hashed in their little-endian representation.\n4. Not considering that `hash160` is computationally more expensive than a single `sha256`.\n\n## Related Functions\n\n- `sha256`: Computes the SHA256 hash of the input.\n- `ripemd160`: Computes the RIPEMD160 hash of the input (not directly available in Clarity, but `hash160` combines SHA256 and RIPEMD160).\n- `keccak256`: Another cryptographic hash function available in Clarity.\n\n## Conclusion\n\nThe `hash160` function is a powerful tool for creating compact, unique identifiers in Clarity smart contracts. It combines the security of SHA256 with the compactness of RIPEMD160, making it particularly useful for address generation and creating short but collision-resistant hashes. When used appropriately, `hash160` can enhance the efficiency and security of your smart contract operations, especially in scenarios where space efficiency is a concern.\n"
  },
  {
    "title": "merge",
    "description": "Merge tuples in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/merge",
    "content": "\n## Function Signature\n\n```clarity\n(merge tuple1 tuple2)\n```\n\n- Input: `tuple, tuple`\n- Output: `tuple`\n\n## Why it matters\n\nThe `merge` function is crucial for:\n\n1. Combining fields from two tuples into a single tuple.\n2. Simplifying the process of updating and managing data structures.\n3. Ensuring data integrity by creating new tuples without mutating the original ones.\n4. Enhancing code readability and maintainability by abstracting tuple merging operations.\n\n## When to use it\n\nUse `merge` when you need to:\n\n- Combine fields from two tuples into a single tuple.\n- Update and manage data structures in a clean and efficient manner.\n- Ensure data integrity by creating new tuples without mutating the original ones.\n- Simplify and abstract tuple merging operations.\n\n## Best Practices\n\n- Ensure the tuples being merged have compatible fields.\n- Use meaningful variable names for better readability.\n- Combine with other tuple and map functions for comprehensive data management.\n- Be aware of the performance implications of frequent tuple merging in large data structures.\n\n## Practical Example: Merging User Data\n\nLet's implement a function that merges additional data into a user's existing data:\n\n```clarity\n(define-map Users { id: int } { name: (string-ascii 12), address: (optional principal) })\n\n(define-public (update-user-address (user-id int) (new-address principal))\n  (let\n    (\n      (user (unwrap-panic (map-get? Users { id: user-id })))\n      (updated-user (merge user { address: (some new-address) }))\n    )\n    (map-set Users { id: user-id } updated-user)\n  )\n)\n\n;; Usage\n(map-insert Users { id: 1337 } { name: \"john\", address: none }) ;; Returns true\n(update-user-address 1337 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns true\n(map-get? Users { id: 1337 }) ;; Returns (some (tuple (name \"john\") (address (some SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF))))\n```\n\nThis example demonstrates:\n1. Using `merge` to combine a user's existing data with new address data.\n2. Implementing a public function to update the user's address.\n3. Handling both the retrieval and updating of user data in a clean and efficient manner.\n\n## Common Pitfalls\n\n1. Using `merge` with tuples that have incompatible fields, causing runtime errors.\n2. Assuming the tuples will always have the expected fields, leading to unhandled cases.\n3. Not handling all possible conditions, resulting in incomplete data management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `map-set`: Sets the value associated with a key in a map.\n- `map-get?`: Retrieves an entry from a map.\n- `map-insert`: Inserts a value into a map if the key does not already exist.\n\n## Conclusion\n\nThe `merge` function is a fundamental tool for combining tuples in Clarity smart contracts. It allows you to manage and update data structures efficiently, ensuring data integrity and enhancing code readability. When used effectively, `merge` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage tuple merging operations.\n"
  },
  {
    "title": "ft-get-balance",
    "description": "Retrieve the balance of a fungible token for a principal in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/ft-get-balance",
    "content": "\n## Function Signature\n\n```clarity\n(ft-get-balance token-name principal)\n```\n\n- Input: \n  - `token-name`: The name of the fungible token\n  - `principal`: The principal whose balance to check\n- Output: `uint`\n\n## Why it matters\n\nThe `ft-get-balance` function is crucial for:\n\n1. Querying the current balance of a fungible token for any principal.\n2. Implementing balance checks before transfers or other token operations.\n3. Providing transparency and visibility into token holdings.\n4. Enabling other contracts or off-chain applications to verify token balances.\n\n## When to use it\n\nUse `ft-get-balance` when you need to:\n\n- Check a user's token balance before performing operations.\n- Implement balance-dependent logic in your contract.\n- Provide balance information to users or other contracts.\n- Verify sufficient funds for token transfers or burns.\n\n## Best Practices\n\n- Use `ft-get-balance` before attempting transfers to ensure sufficient balance.\n- Consider caching balance results if queried frequently to optimize gas usage.\n- Be aware that balances can change between checks and actual token operations.\n- Use in combination with other ft-* functions for comprehensive token management.\n\n## Practical Example: Balance Check Before Transfer\n\nLet's implement a function that checks balance before transferring tokens:\n\n```clarity\n(define-fungible-token cBtc)\n\n(define-public (transfer (amount uint) (recipient principal))\n  (let\n    (\n      (senderBalance (ft-get-balance cBtc tx-sender))\n    )\n    (if (>= senderBalance amount)\n      (ft-transfer? cBtc amount tx-sender recipient)\n      (err u1)\n    )\n  )\n)\n\n;; Usage\n(ft-mint? cBtc u100 tx-sender)\n(transfer u50 'SPAXYA5XS51713FDTQ8H94EJ4V579CXMTRNBZKSF) ;; Returns (ok true)\n(ft-get-balance cBtc tx-sender) ;; Returns u50\n```\n\nThis example demonstrates:\n1. Using `ft-get-balance` to check the sender's balance before attempting a transfer.\n2. Implementing a conditional transfer based on the balance check.\n3. Combining `ft-get-balance` with other ft-* functions for token management.\n\n## Common Pitfalls\n\n1. Assuming balances remain constant between checking and performing operations.\n2. Not handling the case where a principal might not have any balance (returns 0).\n3. Overusing `ft-get-balance` in loops, which can be inefficient for gas consumption.\n\n## Related Functions\n\n- `ft-transfer?`: Used to transfer tokens between principals.\n- `ft-mint?`: Used to create new tokens, increasing the balance of a principal.\n- `ft-burn?`: Used to destroy tokens, decreasing the balance of a principal.\n- `ft-get-supply`: Used to get the current total supply of tokens.\n\n## Conclusion\n\nThe `ft-get-balance` function is a fundamental tool for managing fungible tokens in Clarity smart contracts. It provides a straightforward way to query token balances, enabling you to implement robust token-based systems with proper balance checks and validations. When used effectively in combination with other token functions, this function ensures the integrity and accuracy of token operations within your smart contracts.\n"
  },
  {
    "title": "greater than or equal",
    "description": "Use the greater than or equal function for comparisons in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/greater-than-or-equal",
    "content": "\nThe greater than or equal function (`>=`) in Clarity compares two values and returns true if the first value is greater than or equal to the second. It's a fundamental comparison operation used in many smart contract conditions and logic flows.\n\n## Function Signature\n\n```clarity\n(>= v1 v2)\n```\n\n- Input: Two values of the same type (int, uint, string-ascii, string-utf8, or buff)\n- Output: A boolean (true or false)\n\n## Why it matters\n\nThe greater than or equal function is crucial for:\n\n1. Implementing conditional logic in smart contracts.\n2. Comparing numerical values for financial operations.\n3. Ordering and sorting data.\n4. Implementing minimum thresholds or limits in contract logic.\n5. Checking for equality alongside greater than comparisons.\n\n## When to use it\n\nUse the greater than or equal function when you need to:\n\n- Compare two numerical values to determine if one is larger or equal.\n- Implement minimum thresholds for certain operations, including the threshold value itself.\n- Create conditional logic based on numerical comparisons, including equality.\n- Sort or order data based on numerical or lexicographical order, including equal values.\n\n## Best Practices\n\n- Ensure that both inputs are of the same type to avoid runtime errors.\n- Be aware of the differences in comparison between signed (int) and unsigned (uint) integers.\n- When comparing strings or buffers, understand that the comparison is lexicographical.\n- Consider edge cases, especially when dealing with the limits of integer ranges.\n- Use `>=` instead of `>` when you want to include equality in your comparison.\n\n## Practical Example: Token Unlock Schedule\n\nLet's implement a simple token unlock schedule that uses the greater than or equal function to manage token releases:\n\n```clarity\n;; Define constants\n(define-constant UNLOCK_AMOUNT u1000000) ;; 1 million tokens per unlock\n(define-constant UNLOCK_INTERVAL u17280) ;; Approximately 30 days in blocks\n(define-constant TOTAL_UNLOCKS u10) ;; 10 total unlocks\n\n;; Define data variables\n(define-data-var startBlock uint u0)\n(define-data-var unlocksClaimed uint u0)\n\n;; Function to start the unlock schedule\n(define-public (start-unlock-schedule)\n  (begin\n    (asserts! (is-eq (var-get startBlock) u0) (err u1))\n    (var-set startBlock block-height)\n    (ok true)\n  )\n)\n\n;; Function to calculate claimable tokens\n(define-read-only (get-claimable-tokens)\n  (let\n    (\n      (elapsedBlocks (- block-height (var-get startBlock)))\n      (unlocksDue (/ elapsedBlocks UNLOCK_INTERVAL))\n    )\n    (if (>= unlocksDue TOTAL_UNLOCKS)\n      (* UNLOCK_AMOUNT (- TOTAL_UNLOCKS (var-get unlocksClaimed)))\n      (* UNLOCK_AMOUNT (- unlocksDue (var-get unlocksClaimed)))\n    )\n  )\n)\n\n;; Function to claim tokens\n(define-public (claim-tokens)\n  (let\n    (\n      (claimableAmount (get-claimable-tokens))\n    )\n    (asserts! (> claimableAmount u0) (err u2))\n    (var-set unlocksClaimed (+ (var-get unlocksClaimed) (/ claimableAmount UNLOCK_AMOUNT)))\n    ;; Here you would typically transfer tokens\n    ;; For simplicity, we're just returning the claimed amount\n    (ok claimableAmount)\n  )\n)\n```\n\nThis example demonstrates:\n1. Using `>=` to check if the number of unlocks due is greater than or equal to the total number of unlocks.\n2. Combining the greater than or equal check with other contract logic for a token unlock system.\n3. Implementing a minimum threshold (the unlock interval) that includes the exact unlock time.\n\n## Common Pitfalls\n\n1. Comparing values of different types, which will result in a runtime error.\n2. Confusing `>=` with `>` when setting thresholds, potentially excluding valid values.\n3. Overlooking the inclusive nature of `>=` in boundary conditions.\n\n## Related Functions\n\n- `>`: Used for strict greater than comparisons.\n- `<`: Used for less than comparisons.\n- `<=`: Used for less than or equal to comparisons.\n\n## Conclusion\n\nThe greater than or equal function is a fundamental tool for implementing comparison logic in Clarity smart contracts. By understanding its behavior with different types and potential edge cases, you can create robust conditional logic and enforce important thresholds in your contracts, including scenarios where equality is a valid condition.\n"
  },
  {
    "title": "as-contract",
    "description": "Use the as-contract function to execute expressions as the contract principal in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/as-contract",
    "content": "\n## Function Signature\n\n```clarity\n(as-contract expr)\n```\n\n- Input: An expression `expr`\n- Output: The result of `expr`\n\n## Why it matters\n\nThe `as-contract` function is crucial for:\n\n1. Executing operations with the contract's authority.\n2. Allowing the contract to send assets or perform privileged actions.\n3. Implementing contract-owned resources or funds.\n4. Enabling more complex contract interactions and architectures.\n\n## When to use it\n\nUse the `as-contract` function when you need to:\n\n- Perform actions that require the contract's principal.\n- Send assets (like STX or tokens) from the contract's balance.\n- Execute privileged operations that should only be done by the contract itself.\n- Implement contract-owned resources or escrow-like functionality.\n\n## Best Practices\n\n- Use `as-contract` sparingly and only when necessary to minimize potential security risks.\n- Ensure that the logic leading to `as-contract` calls is properly secured and access-controlled.\n- Be aware that `as-contract` changes the `tx-sender` context for the duration of the expression.\n- Combine `as-contract` with other security measures like `contract-caller` checks for robust security.\n\n## Practical Example: Contract-Managed Treasury\n\nLet's implement a simple treasury system where the contract can distribute funds:\n\n```clarity\n(define-constant CONTRACT_OWNER tx-sender)\n(define-data-var treasuryBalance uint u0)\n\n(define-public (deposit (amount uint))\n  (begin\n    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))\n    (var-set treasuryBalance (+ (var-get treasuryBalance) amount))\n    (ok true)\n  )\n)\n\n(define-public (withdraw (recipient principal) (amount uint))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT_OWNER) (err u403))\n    (asserts! (<= amount (var-get treasuryBalance)) (err u401))\n    (try! (as-contract (stx-transfer? amount tx-sender recipient)))\n    (var-set treasuryBalance (- (var-get treasuryBalance) amount))\n    (ok true)\n  )\n)\n```\n\nThis example demonstrates:\n1. Using `as-contract` in the `deposit` function to receive funds as the contract.\n2. Using `as-contract` in the `withdraw` function to send funds from the contract's balance.\n3. Combining `as-contract` with access control (`is-eq tx-sender CONTRACT_OWNER`) for security.\n\n## Common Pitfalls\n\n1. Using `as-contract` unnecessarily, which can lead to unexpected behavior.\n2. Forgetting that `as-contract` changes the `tx-sender` context, potentially affecting other parts of the code.\n3. Not implementing proper access controls around `as-contract` calls, which could lead to unauthorized actions.\n\n## Related Functions\n\n- `contract-caller`: Used to get the original caller of a contract function.\n- `tx-sender`: Represents the current sender (changes within `as-contract`).\n- `stx-transfer?`: Often used with `as-contract` for token transfers.\n\n## Conclusion\n\nThe `as-contract` function is a powerful tool in Clarity that allows contracts to perform actions with their own authority. While it enables complex contract architectures and functionalities, it should be used judiciously and with proper security measures to prevent potential vulnerabilities or unintended behaviors in smart contracts.\n"
  },
  {
    "title": "asserts!",
    "description": "Use the asserts! function for conditional assertions in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/asserts",
    "content": "\n## Function Signature\n\n```clarity\n(asserts! bool-expr thrown-value)\n```\n\n- Input: \n  - `bool-expr`: A boolean expression\n  - `thrown-value`: The value to be returned if the assertion fails\n- Output: `bool` or `thrown-value`\n\n## Why it matters\n\nThe `asserts!` function is crucial for:\n\n1. Implementing conditional checks in smart contracts.\n2. Enforcing preconditions before executing critical operations.\n3. Providing meaningful error responses when conditions are not met.\n4. Improving contract security by validating inputs and state.\n\n## When to use it\n\nUse the `asserts!` function when you need to:\n\n- Validate conditions before proceeding with contract execution.\n- Ensure certain requirements are met before performing sensitive operations.\n- Provide clear error messages or codes when conditions are not satisfied.\n- Implement guard clauses to protect against invalid inputs or states.\n\n## Best Practices\n\n- Use `asserts!` early in functions to validate preconditions.\n- Provide meaningful error values that can be easily interpreted by users or other contracts.\n- Combine multiple conditions using `and` or `or` for complex assertions.\n- Consider using `asserts!` in combination with `unwrap!` for handling optional values.\n\n## Practical Example: Token Transfer with Balance Check\n\nLet's implement a simple token transfer function that uses `asserts!` to check the sender's balance:\n\n```clarity\n(define-map Balances principal uint)\n\n(define-public (transfer (amount uint) (recipient principal))\n  (let\n    (\n      (senderBalance (default-to u0 (map-get? Balances tx-sender)))\n    )\n    (asserts! (>= senderBalance amount) (err u1)) ;; Insufficient balance\n    (asserts! (not (is-eq tx-sender recipient)) (err u2)) ;; Can't send to self\n    \n    (map-set Balances tx-sender (- senderBalance amount))\n    (map-set Balances recipient (+ (default-to u0 (map-get? Balances recipient)) amount))\n    (ok true)\n  )\n)\n\n(map-set Balances tx-sender u1000) ;; Set the sender's balance to 1000\n\n;; Usage\n(transfer u100 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5) ;; Returns (ok true)\n(transfer u100 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM) ;; Returns (err u2) Can't send to self\n(transfer u1000 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5) ;; Returns (err u1) Insufficient balance\n```\n\nThis example demonstrates:\n1. Using `asserts!` to check if the sender has sufficient balance before transferring.\n2. Using `asserts!` to prevent sending tokens to oneself.\n3. Providing different error codes for different types of failures.\n\n## Common Pitfalls\n\n1. Forgetting to handle the error case when calling functions that use `asserts!`.\n2. Using `asserts!` excessively, which can make code harder to read and maintain.\n3. Providing vague or unhelpful error values when assertions fail.\n\n## Related Functions\n\n- `unwrap!`: Used to extract values from optionals with a fallback error.\n- `unwrap-panic`: Similar to `unwrap!` but causes a panic instead of returning an error.\n- `try!`: Used for propagating errors in a chain of operations.\n\n## Conclusion\n\nThe `asserts!` function is a powerful tool for implementing conditional checks and enforcing invariants in Clarity smart contracts. By using it effectively, you can create more robust and secure contracts that gracefully handle edge cases and provide meaningful feedback when conditions are not met.\n"
  },
  {
    "title": "slice?",
    "description": "Extract a sub-sequence from a sequence in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/slice",
    "content": "\n## Function Signature\n\n```clarity\n(slice? sequence left-position right-position)\n```\n\n- Input: `sequence_A, uint, uint`\n- Output: `(optional sequence_A)`\n\n## Why it matters\n\nThe `slice?` function is crucial for:\n\n1. Extracting sub-sequences from sequences.\n2. Implementing logic that requires partial data extraction.\n3. Ensuring data integrity by validating indices for slicing.\n4. Simplifying the process of handling sub-sequence extraction in smart contracts.\n\n## When to use it\n\nUse `slice?` when you need to:\n\n- Extract a sub-sequence from a sequence.\n- Implement logic that requires partial data extraction.\n- Validate indices for slicing to ensure data integrity.\n- Handle sub-sequence extraction operations.\n\n## Best Practices\n\n- Ensure the `left-position` and `right-position` are within the bounds of the sequence.\n- Use meaningful variable names for better readability.\n- Combine with other sequence functions for comprehensive sequence management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Extracting a Sub-sequence from a String\n\nLet's implement a function that extracts a sub-sequence from a string:\n\n```clarity\n(define-read-only (extract-substring (input (string-ascii 20)) (start uint) (end uint))\n  (slice? input start end)\n)\n\n;; Usage\n(extract-substring \"blockstack\" u5 u10) ;; Returns (some \"stack\")\n(extract-substring \"blockstack\" u0 u5) ;; Returns (some \"block\")\n(extract-substring \"blockstack\" u5 u15) ;; Returns none (out of bounds)\n```\n\nThis example demonstrates:\n1. Using `slice?` to extract a sub-sequence from a string.\n2. Implementing a public function to handle the sub-sequence extraction.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `slice?` with indices that are out of bounds, causing the operation to fail.\n2. Assuming the sub-sequence will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete sequence management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `len`: Returns the length of a sequence.\n- `concat`: Concatenates two sequences.\n- `index-of?`: Returns the first index at which an item can be found in a sequence.\n\n## Conclusion\n\nThe `slice?` function is a fundamental tool for extracting sub-sequences in Clarity smart contracts. It allows you to implement logic that requires partial data extraction, ensuring data integrity and simplifying sequence handling. When used effectively, `slice?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle sub-sequence extraction operations.\n"
  },
  {
    "title": "nft-get-owner?",
    "description": "Retrieve the owner of a non-fungible token (NFT) in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/nft-get-owner",
    "content": "\n## Function Signature\n\n```clarity\n(nft-get-owner? asset-class asset-identifier)\n```\n\n- Input: `AssetName, A`\n- Output: `(optional principal)`\n\n## Why it matters\n\nThe `nft-get-owner?` function is crucial for:\n\n1. Retrieving the owner of a non-fungible token (NFT).\n2. Implementing logic that depends on the ownership of NFTs.\n3. Ensuring data integrity by verifying ownership records.\n4. Simplifying the process of accessing ownership information in smart contracts.\n\n## When to use it\n\nUse `nft-get-owner?` when you need to:\n\n- Retrieve the owner of an NFT.\n- Implement logic that depends on the ownership of NFTs.\n- Verify ownership records in your smart contract.\n- Access ownership information for NFTs.\n\n## Best Practices\n\n- Ensure the `asset-identifier` is correctly formatted and exists.\n- Use meaningful variable names for better readability.\n- Combine with other NFT functions for comprehensive NFT management.\n- Handle the `none` case to avoid runtime errors.\n\n## Practical Example: Retrieving NFT Owner\n\nLet's implement a function that retrieves the owner of an NFT:\n\n```clarity\n(define-non-fungible-token Stackaroo (string-ascii 40))\n\n(define-read-only (get-nft-owner (id (string-ascii 40)))\n  (nft-get-owner? Stackaroo id)\n)\n\n;; Usage\n(nft-mint? Stackaroo \"Roo\" tx-sender) ;; Returns (ok true)\n(get-nft-owner \"Roo\") ;; Returns (some tx-sender)\n(get-nft-owner \"NonExistent\") ;; Returns none\n```\n\nThis example demonstrates:\n1. Using `nft-get-owner?` to retrieve the owner of an NFT.\n2. Implementing a read-only function to return the owner's principal.\n3. Handling both the case where the NFT exists and where it does not.\n\n## Common Pitfalls\n\n1. Using `nft-get-owner?` with an incorrect or non-existent `asset-identifier`, causing the function to return `none`.\n2. Assuming the NFT will always exist, leading to unhandled `none` cases.\n3. Not handling all possible conditions, resulting in incomplete ownership checks.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `nft-mint?`: Mints a new non-fungible token.\n- `nft-transfer?`: Transfers ownership of a non-fungible token.\n- `nft-burn?`: Burns a non-fungible token.\n\n## Conclusion\n\nThe `nft-get-owner?` function is a fundamental tool for retrieving the owner of non-fungible tokens in Clarity smart contracts. It allows you to access ownership information, verify ownership records, and implement logic based on NFT ownership. When used effectively, `nft-get-owner?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage NFT ownership.\n"
  },
  {
    "title": "if",
    "description": "Conditional evaluation in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/if",
    "content": "\n## Function Signature\n\n```clarity\n(if bool expr1 expr2)\n```\n\n- Input: \n  - `bool`: A boolean expression\n  - `expr1`: An expression to evaluate if `bool` is true\n  - `expr2`: An expression to evaluate if `bool` is false\n- Output: The result of `expr1` if `bool` is true, otherwise the result of `expr2`\n\n## Why it matters\n\nThe `if` function is crucial for:\n\n1. Implementing conditional logic in smart contracts.\n2. Making decisions based on dynamic conditions.\n3. Controlling the flow of contract execution.\n4. Simplifying complex logic by branching based on conditions.\n\n## When to use it\n\nUse `if` when you need to:\n\n- Execute different code paths based on a condition.\n- Implement logic that depends on the state or input values.\n- Control the flow of your contract based on dynamic conditions.\n- Simplify complex decision-making processes.\n\n## Best Practices\n\n- Ensure that both `expr1` and `expr2` return the same type.\n- Use clear and meaningful boolean expressions for readability.\n- Avoid deeply nested `if` statements for better maintainability.\n- Combine with other control flow functions like `match` for more complex logic.\n\n## Practical Example: Conditional Token Transfer\n\n```clarity\n(define-map UserBalances { userId: principal } { balance: uint })\n\n(define-public (transfer-tokens (amount uint) (recipient principal))\n  (let\n    (\n      (senderBalance (default-to u0 (map-get? UserBalances { userId: tx-sender })))\n    )\n    (if (>= senderBalance amount)\n      (begin\n        (map-set UserBalances { userId: tx-sender } { balance: (- senderBalance amount) })\n        (map-set UserBalances { userId: recipient } { balance: (+ (default-to u0 (map-get? UserBalances { userId: recipient })) amount) })\n        (ok true)\n      )\n      (err u1)\n    )\n  )\n)\n```\n\nThis example demonstrates:\n1. Using `if` to check if the sender has sufficient balance before transferring tokens.\n2. Executing different code paths based on the result of the balance check.\n3. Handling both the success and failure cases appropriately.\n\n## Common Pitfalls\n\n1. Forgetting that both `expr1` and `expr2` must return the same type.\n2. Using overly complex boolean expressions, making the code hard to read.\n3. Not handling all possible conditions, leading to unexpected behavior.\n4. Overusing `if` for logic that could be simplified with other control flow functions.\n\n## Related Functions\n\n- `match`: Used for pattern matching and handling multiple conditions.\n- `and`: Logical AND operator for combining boolean expressions.\n- `or`: Logical OR operator for combining boolean expressions.\n\n## Conclusion\n\nThe `if` function is a fundamental tool for implementing conditional logic in Clarity smart contracts. It allows you to control the flow of contract execution based on dynamic conditions, enabling more complex and responsive contract behavior. When used effectively, `if` simplifies decision-making processes and enhances the readability and maintainability of your smart contract code.\n"
  },
  {
    "title": "mod",
    "description": "Calculate the remainder of integer division in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/mod",
    "content": "\n## Function Signature\n\n```clarity\n(mod i1 i2)\n```\n\n- Input: `int, int | uint, uint | string-ascii, string-ascii | string-utf8, string-utf8 | buff, buff`\n- Output: `int | uint`\n\n## Why it matters\n\nThe `mod` function is crucial for:\n\n1. Calculating the remainder of integer division.\n2. Implementing logic that depends on modular arithmetic.\n3. Simplifying the process of performing operations that require remainders.\n4. Enhancing code readability and maintainability by abstracting modular operations.\n\n## When to use it\n\nUse `mod` when you need to:\n\n- Calculate the remainder of integer division.\n- Implement logic that depends on modular arithmetic.\n- Perform operations that require remainders.\n- Simplify and abstract modular operations.\n\n## Best Practices\n\n- Ensure the divisor is not zero to avoid runtime errors.\n- Use meaningful variable names for better readability.\n- Combine with other mathematical functions for comprehensive calculations.\n- Be aware of the performance implications of frequent modular operations.\n\n## Practical Example: Calculating Remainders\n\nLet's implement a function that calculates the remainder of dividing two numbers:\n\n```clarity\n(define-read-only (calculate-remainder (a int) (b int))\n  (mod a b)\n)\n\n;; Usage\n(calculate-remainder 5 2) ;; Returns 1\n(calculate-remainder 7 3) ;; Returns 1\n(calculate-remainder 10 4) ;; Returns 2\n```\n\nThis example demonstrates:\n1. Using `mod` to calculate the remainder of dividing two numbers.\n2. Implementing a read-only function to return the remainder.\n3. Handling both small and large input values.\n\n## Common Pitfalls\n\n1. Using `mod` with a divisor of zero, causing a runtime error.\n2. Assuming the result will always be positive, leading to incorrect expectations.\n3. Not handling all possible conditions, resulting in incomplete calculations.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `+`: Adds two numbers.\n- `-`: Subtracts one number from another.\n- `*`: Multiplies two numbers.\n- `/`: Divides one number by another.\n\n## Conclusion\n\nThe `mod` function is a fundamental tool for calculating the remainder of integer division in Clarity smart contracts. It allows you to perform modular arithmetic, enabling robust and comprehensive mathematical operations. When used effectively, `mod` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to manage modular calculations.\n"
  },
  {
    "title": "stx-get-balance",
    "description": "Query the STX balance of a principal in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/stx-get-balance",
    "content": "\n## Function Signature\n\n```clarity\n(stx-get-balance owner)\n```\n\n- Input: `principal`\n- Output: `uint`\n\n## Why it matters\n\nThe `stx-get-balance` function is crucial for:\n\n1. Querying the STX balance of a principal.\n2. Implementing logic that requires checking account balances.\n3. Ensuring data integrity by providing accurate balance information.\n4. Simplifying the process of handling balance-related operations in smart contracts.\n\n## When to use it\n\nUse `stx-get-balance` when you need to:\n\n- Query the STX balance of a principal.\n- Implement logic that requires checking account balances.\n- Ensure accurate balance information for data integrity.\n- Handle balance-related operations in your smart contract.\n\n## Best Practices\n\n- Ensure the `principal` is correctly formatted and valid.\n- Use meaningful variable names for better readability.\n- Combine with other account functions for comprehensive account management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Querying STX Balance\n\nLet's implement a function that queries the STX balance of a given principal:\n\n```clarity\n(define-read-only (get-stx-balance (account principal))\n  (stx-get-balance account)\n)\n\n;; Usage\n(get-stx-balance 'SZ2J6ZY48GV1EZ5V2V5RB9MP66SW86PYKKQ9H6DPR) \n;; Returns u0 if the account has no balance\n(get-stx-balance (as-contract tx-sender)) \n;; Returns the balance of the contract's principal\n```\n\nThis example demonstrates:\n1. Using `stx-get-balance` to query the STX balance of a principal.\n2. Implementing a public function to handle the balance query.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `stx-get-balance` with an incorrectly formatted or invalid `principal`, causing the operation to fail.\n2. Assuming the balance query will always succeed, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete account management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `stx-transfer?`: Transfers STX from one principal to another.\n- `stx-burn?`: Burns STX from a principal's account.\n- `stx-account`: Queries detailed STX account information.\n\n## Conclusion\n\nThe `stx-get-balance` function is a fundamental tool for querying the STX balance of a principal in Clarity smart contracts. It allows you to implement logic that requires checking account balances, ensuring data integrity and simplifying balance-related operations. When used effectively, `stx-get-balance` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle balance queries.\n"
  },
  {
    "title": "print",
    "description": "Evaluate and printing expressions in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/print",
    "content": "\n## Function Signature\n\n```clarity\n(print expr)\n```\n\n- Input: `A`\n- Output: `A`\n\n## Why it matters\n\nThe `print` function is crucial for:\n\n1. Debugging and logging expressions during contract development.\n2. Evaluating and returning the input expression.\n3. Enhancing code readability and maintainability by providing a way to output intermediate values.\n\n## When to use it\n\nUse `print` when you need to:\n\n- Debug and log expressions during contract development.\n- Evaluate and return an input expression.\n- Output intermediate values for better understanding of contract behavior.\n\n## Best Practices\n\n- Use `print` primarily for debugging and development purposes.\n- Ensure that the expression passed to `print` is meaningful and necessary for debugging.\n- Remove or comment out `print` statements in production code to avoid unnecessary output.\n\n## Practical Example: Printing an Expression\n\nLet's implement a function that prints the result of an addition operation:\n\n```clarity\n(define-read-only (add-and-print (a int) (b int))\n  (print (+ a b))\n)\n\n;; Usage\n(add-and-print 3 4) ;; Prints 7 and returns 7\n(add-and-print 10 20) ;; Prints 30 and returns 30\n```\n\nThis example demonstrates:\n1. Using `print` to output the result of an addition operation.\n2. Implementing a public function to handle the addition and printing.\n3. Handling both small and large input values.\n\n## Common Pitfalls\n\n1. Using `print` excessively, leading to cluttered output and reduced readability.\n2. Assuming `print` is necessary for all expressions, leading to overuse.\n3. Not removing or commenting out `print` statements in production code, resulting in unnecessary output.\n\n## Related Functions\n\n- `+`: Adds two or more numbers.\n- `-`: Subtracts one number from another.\n- `*`: Multiplies two or more numbers.\n- `/`: Divides one number by another.\n\n## Conclusion\n\nThe `print` function is a fundamental tool for debugging and logging expressions in Clarity smart contracts. It allows you to evaluate and return input expressions, providing a way to output intermediate values for better understanding of contract behavior. When used effectively, `print` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to debug and log expressions.\n"
  },
  {
    "title": "principal-construct?",
    "description": "Construct a principal in Clarity smart contracts.",
    "slug": "/stacks/clarity/functions/principal-construct",
    "content": "\n## Function Signature\n\n```clarity\n(principal-construct? version-byte hash-bytes [contract-name])\n```\n\n- Input: `(buff 1), (buff 20), [(string-ascii 40)]`\n- Output: `(response principal { error_code: uint, principal: (optional principal) })`\n\n## Why it matters\n\nThe `principal-construct?` function is crucial for:\n\n1. Creating standard or contract principals.\n2. Managing identities and permissions in smart contracts.\n3. Ensuring data integrity by validating principal construction.\n4. Simplifying the process of creating principals in smart contracts.\n\n## When to use it\n\nUse `principal-construct?` when you need to:\n\n- Create a standard or contract principal.\n- Manage identities and permissions in your smart contract.\n- Validate the construction of principals.\n- Handle principal creation operations.\n\n## Best Practices\n\n- Ensure the `version-byte` and `hash-bytes` are correctly formatted.\n- Use meaningful variable names for better readability.\n- Combine with other principal functions for comprehensive identity management.\n- Handle the possible error cases to ensure robust contract behavior.\n\n## Practical Example: Constructing a Principal\n\nLet's implement a function that constructs a standard principal:\n\n```clarity\n(define-public (create-standard-principal (versionByte (buff 1)) (hashBytes (buff 20)))\n  (principal-construct? versionByte hashBytes)\n)\n\n;; Usage\n(create-standard-principal 0x1a 0xfa6bf38ed557fe417333710d6033e9419391a320) ;; Returns (ok 'ST3X6QWWETNBZWGBK6DRGTR1KX50S74D3425Q1TPK)\n```\n\nThis example demonstrates:\n1. Using `principal-construct?` to create a standard principal.\n2. Implementing a public function to handle the principal construction.\n3. Handling both successful and error cases.\n\n## Common Pitfalls\n\n1. Using `principal-construct?` with incorrectly formatted `versionByte` or `hashBytes`, causing the operation to fail.\n2. Assuming the principal will always be valid, leading to unhandled error cases.\n3. Not handling all possible conditions, resulting in incomplete principal management.\n4. Overlooking the need for proper error handling and validation.\n\n## Related Functions\n\n- `principal-of?`: Returns the principal derived from a public key.\n- `contract-caller`: Returns the caller of the current contract context.\n- `tx-sender`: Returns the sender of the current transaction.\n\n## Conclusion\n\nThe `principal-construct?` function is a fundamental tool for creating principals in Clarity smart contracts. It allows you to manage identities and permissions, ensuring data integrity and simplifying principal creation. When used effectively, `principal-construct?` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle principal construction operations.\n"
  },
  {
    "title": "Optional values and error handling",
    "description": "Safely handling optional values and error cases in Clarity smart contracts.",
    "slug": "/stacks/clarity/handling-optionals-and-errors",
    "content": "\nClarity provides robust mechanisms for dealing with optional values and error cases. These features are crucial for writing secure and predictable smart contracts that can gracefully handle unexpected situations.\n\n## Why these functions matter\n\nClarity's optional value and error handling functions are designed with several important considerations in mind:\n\n1. Safety: They prevent unexpected null or undefined errors that could crash a contract.\n2. Explicitness: They force developers to consider and handle all possible outcomes.\n3. Readability: They make the code's intent clear, improving maintainability.\n4. Composability: They allow for clean function composition and chaining of operations.\n\n## Core optional and error handling functions\n\n### 1. is-some and is-none\n\n**What**: Check if an optional value contains a value (some) or is empty (none).\n\n**Why**: Essential for safely working with optional values before attempting to use them.\n\n**When**: Use when you need to check if an optional value is present before proceeding.\n\n**How**: \n```clarity\n(is-some value)\n(is-none value)\n```\n\n**Best practices**: \n- Always check optional values before unwrapping them.\n- Use in combination with unwrap functions for safe value extraction.\n\n**Example use case**: Checking if a user exists in a map before performing an operation.\n\n```clarity\n(define-map Users principal { balance: uint })\n\n(define-public (check-balance (user principal))\n  (if (is-some (map-get? Users user))\n      (ok \"User exists\")\n      (err \"User not found\")\n  )\n)\n```\n\n### 2. unwrap! and unwrap-panic\n\n**What**: Extract the value from an optional or response type.\n\n**Why**: Allows safe extraction of values, with controlled behavior on failure.\n\n**When**: Use when you're certain a value exists or when you want to halt execution if it doesn't.\n\n**How**: \n```clarity\n(unwrap! value error-expr)\n(unwrap-panic value)\n```\n\n**Best practices**: \n- Use `unwrap!` when you want to provide a custom error message or value.\n- Use `unwrap-panic` sparingly, typically only in situations where failure is truly unexpected.\n\n**Example use case**: Retrieving a user's balance, with a custom error if the user doesn't exist.\n\n```clarity\n(define-map Users principal { balance: uint })\n\n(define-public (get-balance (user principal))\n  (ok (unwrap! (get balance (map-get? Users user)) (err \"User not found\")))\n)\n```\n\n### 3. try!\n\n**What**: Attempts to unwrap a response, returning early with an error if it fails.\n\n**Why**: Simplifies error handling in functions that return responses.\n\n**When**: Use when you want to propagate errors up the call stack.\n\n**How**: \n```clarity\n(try! expression)\n```\n\n**Best practices**: \n- Use to chain multiple operations that might fail.\n- Helps keep code clean by avoiding nested if-else statements.\n\n**Example use case**: Transferring tokens between users, with multiple checks.\n\n```clarity\n(define-public (transfer (from principal) (to principal) (amount uint))\n  (let\n    (\n      (senderBalance (try! (get-balance from)))\n      (recipientBalance (try! (get-balance to)))\n    )\n    (try! (check-sufficient-balance senderBalance amount))\n    (try! (update-balance from (- senderBalance amount)))\n    (try! (update-balance to (+ recipientBalance amount)))\n    (ok true)\n  )\n)\n```\n\n## Practical example: safe token transfer system\n\nLet's implement a simple token system that demonstrates the use of optional values and error handling:\n\n```clarity\n(define-map Balances principal uint)\n\n(define-read-only (get-balance (user principal))\n  (default-to u0 (map-get? Balances user))\n)\n\n(define-public (transfer (to principal) (amount uint))\n  (let\n    (\n      (senderBalance (get-balance tx-sender))\n      (recipientBalance (get-balance to))\n    )\n    (if (>= senderBalance amount)\n        (begin\n          (try! (as-contract (stx-transfer? amount tx-sender to)))\n          (map-set Balances tx-sender (- senderBalance amount))\n          (map-set Balances to (+ recipientBalance amount))\n          (ok true)\n        )\n        (err u1)\n    )\n  )\n)\n\n(define-public (deposit (amount uint))\n  (let\n    (\n      (currentBalance (get-balance tx-sender))\n    )\n    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))\n    (ok (map-set Balances tx-sender (+ currentBalance amount)))\n  )\n)\n```\n\nThis example demonstrates:\n1. Using `try!` to handle potential errors in the STX transfer operations.\n2. Proper error handling and propagation throughout the contract functions.\n\n## Conclusion\n\nProper handling of optional values and error cases is crucial for writing secure and reliable Clarity smart contracts. By leveraging Clarity's built-in functions like `is-some`, `unwrap!`, and `try!`, you can create robust contracts that gracefully handle unexpected situations and provide clear feedback when errors occur. Always consider all possible outcomes and use these tools to make your contracts more predictable and maintainable.\n"
  },
  {
    "title": "Time-based logic",
    "description": "Implementing time-based logic with block info functions in Clarity.",
    "slug": "/stacks/clarity/time-and-blocks",
    "content": "\nBlock info functions in Clarity provide crucial tools for implementing time-based logic in smart contracts. These functions allow developers to create contracts that can respond to the passage of time and changing blockchain states.\n\n## Why these functions matter\n\nClarity's block info functions are designed with blockchain-specific considerations in mind:\n\n1. Determinism: These functions provide a consistent view of time across all nodes, ensuring contract behavior is predictable.\n2. Security: By relying on block information rather than system time, contracts are protected against time-based manipulations.\n3. Flexibility: Developers can create time-locked features, scheduled events, and other time-dependent logic.\n4. Blockchain Awareness: Contracts can make decisions based on the current state of the blockchain.\n\n## Core Block Info Functions\n\n### 1. block-height\n\n**What**: Returns the current block height of the Stacks blockchain.\n**Why**: Essential for creating logic based on blockchain progression.\n**When**: Use when you need to trigger actions or changes based on block height milestones.\n**How**: \n```clarity\n(block-height)\n```\n\n**Best Practices**: \n- Use for long-term time measurements (hours/days) rather than short intervals.\n- Consider potential variations in block time when planning time-sensitive operations.\n\n**Example Use Case**: Implementing a phased token release schedule.\n\n```clarity\n(define-public (claim-tokens)\n  (let ((release-height u100000))\n    (if (>= block-height release-height)\n        (ok (release-tokens))\n        (err u1))))\n```\n\n### 2. burn-block-height\n\n**What**: Returns the current block height of the underlying burn chain (Bitcoin).\n**Why**: Provides a more stable time reference, as Bitcoin has more consistent block times.\n**When**: Use for more precise time-based logic or when synchronizing with Bitcoin network events.\n**How**: \n```clarity\n(burn-block-height)\n```\n\n**Best Practices**: \n- Prefer this over `block-height` for more accurate time estimations.\n- Remember that Bitcoin block times can still vary, so allow for some flexibility.\n\n**Example Use Case**: Creating a time-locked vault that opens after a specific Bitcoin block height.\n\n```clarity\n(define-constant unlock-height u700000)\n\n(define-public (withdraw-from-vault (amount uint))\n  (if (>= burn-block-height unlock-height)\n      (ok (transfer-tokens amount))\n      (err u2)))\n```\n\n### 3. get-block-info?\n\n**What**: Retrieves information about a specific block.\n**Why**: Allows contracts to access historical block data for complex time-based logic.\n**When**: Use when you need to verify or act on information from past blocks.\n**How**: \n```clarity\n(get-block-info? property-name block-height-int)\n```\n\n**Best Practices**: \n- Cache retrieved information when possible to save processing costs.\n- Be aware of the limit on how far back you can query block information.\n\n**Example Use Case**: Implementing a reward system based on user activity in specific time periods.\n\n```clarity\n(define-public (claim-period-reward (period uint))\n  (let ((period-end-height (get-period-end-height period))\n        (current-winner (get-block-info? winner-id period-end-height)))\n    (if (is-eq current-winner tx-sender)\n        (ok (distribute-reward tx-sender))\n        (err u3))))\n```\n\n### Practical Example: Token Balance Snapshot for Voting\n\nLet's implement a simple voting system where voting power is determined by a user's token balance at a specific \"snapshot\" block height. This example combines the use of `at-block` and `get-block-info?` functions to create a time-based voting mechanism.\n\n```clarity\n;; Define a simple token balance map\n(define-map token-balances principal uint)\n\n;; Define a map to store votes\n(define-map votes principal uint)\n\n;; Set a snapshot block height\n(define-data-var snapshot-height uint u100000)\n\n;; Function to get a user's balance at the snapshot height\n(define-read-only (get-snapshot-balance (user principal))\n  (match (get-block-info? id-header-hash (var-get snapshot-height))\n    snapshot-block (at-block snapshot-block\n      (default-to u0 (map-get? token-balances user)))\n    u0))\n\n;; Function to cast a vote\n(define-public (cast-vote (amount uint))\n  (let \n    ((snapshot-balance (get-snapshot-balance tx-sender))\n     (current-votes (default-to u0 (map-get? votes tx-sender))))\n    (asserts! (<= amount snapshot-balance) (err u1)) ;; Can't vote more than snapshot balance\n    (asserts! (< (+ amount current-votes) (+ snapshot-balance u1)) (err u2)) ;; Prevent overflow\n    (map-set votes tx-sender (+ amount current-votes))\n    (ok true)))\n\n;; Function to check total votes\n(define-read-only (get-total-votes)\n  (fold + (map-values votes) u0))\n```\n\n## Conclusion\n\nBlock info functions in Clarity provide powerful tools for implementing time-based logic in smart contracts. By understanding when and how to use these functions, developers can create contracts that respond dynamically to the progression of the blockchain, enabling features like time-locks, scheduled events, and historical data analysis. Always consider the specific requirements of your application and the potential for block time variations when implementing time-based logic using these block info functions."
  },
  {
    "title": "Web app development",
    "description": "Build your web apps on Stacks.",
    "slug": "/stacks/web-app-development",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nLFG!\n\n## Related tools\n\n- **[Clarinet](/stacks/clarinet)**: Build your app in a local environment on Stacks.\n- **[Stacks.js](/stacks/stacks.js)**: Don’t reinvent the wheel and build faster with a JS library that handles basic blockchain functionality.\n- **[Stacks Blockchain API](/stacks/api)**: Fetch data and broadcast transactions with the Stacks Blockchain API.\n\n<br />\n\n<Callout title=\"Need help building with Clarinet JS SDK?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#clarinet</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>"
  },
  {
    "title": "Token development",
    "description": "Build your tokens on Stacks.",
    "slug": "/stacks/token-development",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nLFG!\n\n## Related tools\n\n- **[Clarinet](/stacks/clarinet)**: Build your app in a local environment on Stacks.\n- **[Stacks.js](/stacks/stacks.js)**: Don’t reinvent the wheel and build faster with a JS library that handles basic blockchain functionality.\n- **[Stacks Blockchain API](/stacks/api)**: Fetch data and broadcast transactions with the Stacks Blockchain API.\n\n<br />\n\n<Callout title=\"Need help building with Clarinet JS SDK?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#clarinet</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>"
  },
  {
    "title": "Blocks",
    "description": "Get aggregated signer information for blocks.",
    "slug": "/stacks/signer-metrics-api/blocks/index",
    "content": ""
  },
  {
    "title": "Aggregated signer information for a block",
    "description": "Get aggregated signer information for a specific block.",
    "slug": "/stacks/signer-metrics-api/blocks/aggregated-signer-information-for-a-block",
    "content": "\n<APIPage\n  document=\"./openapi/signer-metrics-api.json\"\n  operations={[{ path: '/signer-metrics/v1/blocks/{height_or_hash}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Aggregated signer information for most recent blocks",
    "description": "Get aggregated signer information for most recent blocks.",
    "slug": "/stacks/signer-metrics-api/blocks/aggregated-signer-information-for-most-recent-blocks",
    "content": "\n<APIPage\n  document=\"./openapi/signer-metrics-api.json\"\n  operations={[{ path: '/signer-metrics/v1/blocks', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Overview",
    "description": "Monitor and analyze signer behavior on the Stacks network.",
    "slug": "/stacks/signer-metrics-api/index",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nThe Signer Metrics API enables you to monitor signers on the Stacks network. With a familiar REST interface, you can easily fetch information about the signer network, such as lists of active signers in a particular PoX cycle and signer information for a particular block. \n\nThis API also lets you analyze and evaluate the behavior of individual signers, such as their block acceptance rate, their average block push time, and more.\n\n## Popular endpoints\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/signer-metrics-api/signers/pox-cycle-signers\"\n    title=\"Get a list of signers\"\n    description=\"Fetches a list of signers in a given PoX cycle.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/signer-metrics-api/blocks/aggregated-signer-information-for-a-block\"\n    title=\"Get signer information for a block\"\n    description=\"Fetches aggregated signer information for a specific block.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/signer-metrics-api/prometheus/metrics\"\n    title=\"Query for Prometheus metrics\"\n    description=\"Fetch behavioral data around individual signers and block proposals\"\n  />\n</Cards>\n\n## Related tools\n\n- **[Stacks Blockchain API](/stacks/api)**: Fetch richer data from Hiro's Stacks Blockchain API.\n- **[Stacks Node RPC API](/stacks/rpc-api)**: Query the Stacks Node RPC API, interact with smart contracts, and broadcast transactions all via a familiar REST interface.\n- **[Token Metadata API](/stacks/token-metadata-api)**: Fetch fungible and non-fungible token data on the Stacks blockchain.\n\n<br />\n\n<Callout title=\"Need help building with the Stacks Node RPC API?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#api</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>\n\n\n"
  },
  {
    "title": "Info",
    "description": "Service status endpoints",
    "slug": "/stacks/signer-metrics-api/info/index",
    "content": ""
  },
  {
    "title": "API Status",
    "description": "Displays the status of the API and its current workload.",
    "slug": "/stacks/signer-metrics-api/info/status",
    "content": "\n<APIPage\n  document=\"./openapi/signer-metrics-api.json\"\n  operations={[{ path: '/signer-metrics/', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Prometheus Metrics",
    "description": "Get Prometheus metrics for the Signer Metrics API.",
    "slug": "/stacks/signer-metrics-api/prometheus/index",
    "content": ""
  },
  {
    "title": "Prometheus Metrics",
    "description": "Get Prometheus metrics for the Signer Metrics API.",
    "slug": "/stacks/signer-metrics-api/prometheus/metrics",
    "content": "\n<APIPage\n  document=\"./openapi/signer-metrics-api.json\"\n  operations={[{ path: '/signer-metrics/metrics', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Signers",
    "description": "Get information about signers on the Stacks blockchain.",
    "slug": "/stacks/signer-metrics-api/signers/index",
    "content": ""
  },
  {
    "title": "PoX Cycle Signer",
    "description": "Get stats for a specific signer in a given PoX cycle.",
    "slug": "/stacks/signer-metrics-api/signers/pox-cycle-signer",
    "content": "\n<APIPage\n  document=\"./openapi/signer-metrics-api.json\"\n  operations={[{ path: '/signer-metrics/v1/cycles/{cycle_number}/signers/{signer_id}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "PoX Cycle Signers",
    "description": "Get a list of signers in a given PoX cycle.",
    "slug": "/stacks/signer-metrics-api/signers/pox-cycle-signers",
    "content": "\n<APIPage\n  document=\"./openapi/signer-metrics-api.json\"\n  operations={[{ path: '/signer-metrics/v1/cycles/{cycle_number}/signers', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Signer information for a block",
    "description": "Get signer information for a specific block.",
    "slug": "/stacks/signer-metrics-api/block-proposals/signer-information-for-a-block",
    "content": "\n<APIPage\n  document=\"./openapi/signer-metrics-api.json\"\n  operations={[{ path: '/signer-metrics/v1/block_proposals/{block_hash}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Block proposals",
    "description": "Get information about block proposals.",
    "slug": "/stacks/signer-metrics-api/block-proposals/index",
    "content": ""
  },
  {
    "title": "Signer information for most recent block proposals",
    "description": "Get signer information for most recent block proposals.",
    "slug": "/stacks/signer-metrics-api/block-proposals/signer-information-for-most-recent-block-proposals",
    "content": "\n<APIPage\n  document=\"./openapi/signer-metrics-api.json\"\n  operations={[{ path: '/signer-metrics/v1/block_proposals', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Overview",
    "description": "Discover updates to Hiro tools related to the Nakamoto upgrade.",
    "slug": "/stacks/nakamoto/index",
    "content": "\nNakamoto is an upcoming upgrade to Stacks that brings faster blocks and paves the way for sBTC. [Start here](https://docs.stacks.co/nakamoto-upgrade/nakamoto-upgrade-start-here) if you need an overview of how Nakamoto impacts the network. This document is about how Nakamoto impacts your applications and Hiro tooling specifically.\n\nThe good news for you is that the Nakamoto upgrade does not bring breaking changes to applications on Stacks. Your app will continue to work as expected post-upgrade, apart from you and your users experiencing the better UX of faster block times.\n\nIn terms of what you need to do to prepare for Nakamoto, just make sure you are running the latest versions of our tooling. We are shipping updates across all Hiro tools to make sure they support Nakamoto and that you can stay focused on building.\n\nBelow find a list of how Hiro tools have been updated to support Nakamoto:\n\n## Stacks Explorer: What's new\n\n### Introducing a fresh view for blocks\n\nThe Stacks Explorer now features a new way to display blocks, aligning with the Nakamoto upgrade's approach of multiple STX blocks settling into one BTC block.\n\n![Block View](./images/nakamoto-explorer.png)\n\n### Tailored viewing experience\n\nThis new view is now live on both [testnet](https://explorer.hiro.so/?chain=testnet) and [mainnet](https://explorer.hiro.so/?chain=mainnet), accessible via the network dropdown.\n\n#### Two distinctive display modes\n\n1. **Independent Display:** Focuses on STX blocks progress.\n2. **COMING SOON—Grouped by Bitcoin Block:** Shows BTC blocks flow alongside STX blocks.\n\n![Block View](./images/group-by-block.png)\n\n### Stay in the loop with live view\n\nKeep up-to-date with blocks in real-time with our new live view option.\n\n---\n\n## Stacks.js: What’s new\n\n### StackingClient\n\nInstall the latest nakamoto version with `npm install @stacks/stacking@6.13.0`.\n\nThe StackingClient in `@stacks/stacking` was updated to match the latest pox-4 contract.\n\n- Added `StackingClient.signPoxSignature()`\n- Added `Pox4SignatureTopic` enum\n- New stacking arguments for `StackingClient.stack`, `StackingClient.stackExtend`, `StackingClient.stackIncrease`, `StackingClient.stackAggregationCommit`, and `StackingClient.stackAggregationCommitIndexed`\n\n[Learn more](/stacks/nakamoto/guides/stacks-js) about the new Stacks.js updates.\n\n---\n\n## Clarinet: What’s new\n\nMake sure to install [Clarinet 2.8.0](https://github.com/hirosystems/clarinet/releases/tag/v2.8.0) or above.\n\n- Clarinet's devnet can now be used to test Nakamoto functionality.\n- The devnet now starts 2 signer nodes in Nakamoto mode.\n- Running `clarinet check --enable-clarity-wasm` now runs the current interpreter and clarity wasm side-by-side to allow comparing outputs.\n- `clarinet console --enable-clarity-wasm` now automatically runs the current interpreter and clarity wasm side-by-side and logs any difference in outputs.\n\nBy default, the Devnet won't start in epoch 3.0, [see this guide](/stacks/nakamoto/guides/clarinet) to configure it.\n\n---\n\n## Stacks Blockchain API: What’s new\n\n> **_NOTE:_**\n>\n> The `/extended/v2/*` endpoints represent the modern API that is being continually expanded to support the Nakamoto upgrade. We encourage developers to use v2 endpoints for new developments. Be aware that `/extended/v1/*` are the older set of endpoints. Though they continue to function alongside v2, they will be deprecated in the coming months.\n\n### Nakamoto endpoints\n\nThe Stacks Blockchain API has a series of new endpoints to support the upcoming Nakamoto upgrade:\n\n- Get Proof-of-Transfer details per Cycle, including Signers and Stackers, with information about stacked STX amounts, payout addresses and signer weights\n- Get a list of Stacks blocks per Bitcoin block to support the new Nakamoto mining mechanism\n- Get all transactions relevant to a STX address or contract ID, including filters for FT and NFT transfers\n- Support for the new Nakamoto `tenure_change` transaction type across all our transaction endpoints\n- Get a summary of current network mempool transaction fees, including statistics for expected confirmation priorities\n- Get the deployment status of multiple smart contracts in one call\n\nAll of these endpoints are backwards compatible with Stacks nodes running version 2.4 or earlier\n\n### Event replay optimizations\n\n- Optimize replay speed by creating a new parquet-based ingestion that optimizes for canonical chain information\n- Optimize classic TSV event replay by improving block ingestion times\n\n### New transaction type `tenure_change`\n\nAffects endpoints:\n\n- `/extended/v1/address/{principal}/transactions`\n- `/extended/v1/tx`\n- `/extended/v1/tx/{tx_id}`\n- `/extended/v1/tx/{tx_id}/raw`\n- `/extended/v1/tx/mempool`\n- `/extended/v1/tx/multiple`\n\n### New endpoints: `/extended/v2/*`\n\n- `/extended/v2/mempool/fees`\n- `/extended/v2/burn-blocks`\n- `/extended/v2/burn-blocks/{height_or_hash}`\n- `/extended/v2/burn-blocks/{height_or_hash}/blocks`\n- `/extended/v2/blocks`\n- `/extended/v2/blocks/{height_or_hash}`\n- `/extended/v2/blocks/{height_or_hash}/transactions`\n- `/extended/v2/addresses/{address}/transactions:`\n- `/extended/v2/addresses/{address}/transactions/{tx_id}/events:`\n- `/extended/v2/smart-contracts/status`\n- `/extended/v2/pox/cycles`\n- `/extended/v2/pox/cycles/{cycle_number}`\n- `/extended/v2/pox/cycles/{cycle_number}/signers`\n- `/extended/v2/pox/cycles/{cycle_number}/signers/{signer_key}`\n- `/extended/v2/pox/cycles/{cycle_number}/signers/{signer_key}/stackers`\n\n### Deprecated endpoints\n\n- `/extended/v1/block`\n- `/extended/v1/block/{hash}`\n- `/extended/v1/block/by_height/{height}`\n- `/extended/v1/block/by_burn_block_hash/{burn_block_hash}`\n- `/extended/v1/block/by_burn_block_height/{burn_block_height}`\n- `/extended/v1/address/{principal}/transactions`\n- `/extended/v1/address/{principal}/{tx_id}/with_transfers`\n- `/extended/v1/address/{principal}/transactions_with_transfers`\n- `/extended/v1/fee_rate`\n- `/extended/v1/tx/block/{block_hash}`\n- `/extended/v1/tx/block_height/{height}`\n\nView the [API reference](/stacks/api/info).\n"
  },
  {
    "title": "Updates for Stacks Explorer",
    "description": "Discover Stacks Explorer updates related to the Nakamoto upgrade.",
    "slug": "/stacks/nakamoto/guides/explorer",
    "content": "\n## What's new\n\n### Introducing a fresh view for blocks\n\nThe Stacks Explorer now features a new way to display blocks, aligning with the Nakamoto upgrade's approach of multiple STX blocks settling into one BTC block.\n\n![Block View](../images/nakamoto-explorer.png)\n\n### Tailored viewing experience\n\nThis new view is now live on both [testnet](https://explorer.hiro.so/?chain=testnet) and [mainnet](https://explorer.hiro.so/?chain=mainnet), accessible via the network dropdown.\n\n#### Two distinctive display modes\n\n1. **Independent Display:** Focuses on STX blocks progress.\n2. **COMING SOON—Grouped by Bitcoin Block:** Shows BTC blocks flow alongside STX blocks.\n\n![Block View](../images/group-by-block.png)\n\n### Stay in the loop with live view\n\nKeep up-to-date with blocks in real-time with our new live view option.\n"
  },
  {
    "title": "Updates for Clarinet",
    "description": "Discover Clarinet upgrades related to the Nakamoto release.",
    "slug": "/stacks/nakamoto/guides/clarinet",
    "content": "\n## Setting up a project for Nakamoto\n\nAs of [version 2.11.0](https://github.com/hirosystems/clarinet/releases/tag/v2.11.0), Clarinet runs\nin epoch 3.0 (Nakamoto) by default.\n\n- Contracts are set to be deployed in epoch 3.0 and support Clarity 3.\n- The Devnet runs the latest Stacks blockchain version by default, enabling Nakamoto and support\n  Clarity 3 contracts.\n\nOnce the Devnet reaches the right block height, (Bitcoin block #108 by default), it will deploy the\n_`pox-4.clar`_ contract and run in Epoch 2.5. From there, Clarinet will send _`stack-stx`_ and\n_`stack-extend`_ requests to the new PoX contract. Eventually, you can observe the\n_`vote-for-aggregate-public-key`_ transactions that they send.\n\n**At Bitcoin block #142, the Devnet will switch the epoch 3.0.**\n\nAt the end of the _`Devnet.toml`_ file, you must make sure that the _`pox_stacking_orders`_ are properly\nset. You should have 3 stacking orders from 3 different accounts. All should start at **cycle 1**\nand take at least **2 slots**. You also need to enable the _`auto-extend`_ property. Because Nakamoto\nrelies on the Stackers to sign blocks, these settings ensure that there are engouh stacked STX for\neach cycles. Here is what it looks like by default in new projects:\n\n```toml\n# settings/Devnet.toml\n[[devnet.pox_stacking_orders]]\nstart_at_cycle = 1\nduration = 10\nauto_extend = true\nwallet = \"wallet_1\"\nslots = 2\nbtc_address = \"mr1iPkD9N3RJZZxXRk7xF9d36gffa6exNC\"\n\n[[devnet.pox_stacking_orders]]\nstart_at_cycle = 1\nduration = 10\nauto_extend = true\nwallet = \"wallet_2\"\nslots = 2\nbtc_address = \"muYdXKmX9bByAueDe6KFfHd5Ff1gdN9ErG\"\n\n[[devnet.pox_stacking_orders]]\nstart_at_cycle = 1\nduration = 10\nauto_extend = true\nwallet = \"wallet_3\"\nslots = 2\nbtc_address = \"mvZtbibDAAA3WLpY7zXXFqRa3T4XSknBX7\"\n```\n\nSet a contract to be deployed in epoch 3.0 with Clarity 3. You can create a new one with\n`$ clarinet contract new <contract-name>`). It needs to be manually update in the project manifest\n(Clarinet.toml)\n\n```toml\n# Clarinet.toml\n[contracts.nakademo]\npath = 'contracts/nakademo.clar'\nclarity_version = 3\nepoch = 3.0\n```\n\nStart Devnet with `clarinet devnet start`, you should see epoch 3.0 and fast blocks at Bitcoin\nblock 142.\n\n<Callout title=\"New Clarity keywords\">\nClarity 3 introduces two new keywords after the Nakamoto hard fork:\n\n- `tenure-height`: Returns the number of tenures passed.\n- `stacks-block-height`: Returns the current Stacks block height.\n\nNote: `block-height` is removed.\n\nFor more details on these and other Clarity keywords, see the [Clarity Keywords Reference](https://docs.stacks.co/reference/keywords).\n</Callout>"
  },
  {
    "title": "Updates for Stacks API",
    "description": "Discover Stacks Blockchain API updates related to the Nakamoto upgrade.",
    "slug": "/stacks/nakamoto/guides/stacks-api",
    "content": "\n## What's new\n\n<Callout title=\"Note\" type=\"info\">\n  The `/extended/v2/*` endpoints represent the modern API that is being\n  continually expanded to support the Nakamoto upgrade. We encourage developers\n  to use v2 endpoints for new developments. Be aware that `/extended/v1/*` are\n  the older set of endpoints. Though they continue to function alongside v2, they will be deprecated in the coming months.\n</Callout>\n\n### Nakamoto endpoints\n\nThe Stacks Blockchain API has a series of new endpoints to support the upcoming Nakamoto upgrade:\n\n- Get Proof-of-Transfer details per Cycle, including Signers and Stackers, with information about stacked STX amounts, payout addresses and signer weights\n- Get a list of Stacks blocks per Bitcoin block to support the new Nakamoto mining mechanism\n- Get all transactions relevant to a STX address or contract ID, including filters for FT and NFT transfers\n- Support for the new Nakamoto `tenure_change` transaction type across all our transaction endpoints\n- Get a summary of current network mempool transaction fees, including statistics for expected confirmation priorities\n- Get the deployment status of multiple smart contracts in one call\n\nAll of these endpoints are backwards compatible with Stacks nodes running version 2.4 or earlier\n\n### Event replay optimizations\n\n- Optimize replay speed by creating a new parquet-based ingestion that optimizes for canonical chain information\n- Optimize classic TSV event replay by improving block ingestion times\n\n### New transaction type `tenure_change`\n\nThis new type affects the following endpoints:\n\n- `/extended/v1/address/{principal}/transactions`\n- `/extended/v1/tx`\n- `/extended/v1/tx/{tx_id}`\n- `/extended/v1/tx/{tx_id}/raw`\n- `/extended/v1/tx/mempool`\n- `/extended/v1/tx/multiple`\n\n### New endpoints: `/extended/v2/*`\n\nOne important difference to note between the `/extended/v1` vs the `/extended/v2` endpoints is that the ﻿/extended/v2/_ endpoints represent the current API that is being continually expanded to support the Nakamoto upgrade. We encourage developers to use v2 endpoints for new developments. Be aware that ﻿/extended/v1/_ are the older set of endpoints. Though they continue to function alongside v2, they will be deprecated in the coming months.\n\n- `/extended/v2/mempool/fees`\n- `/extended/v2/burn-blocks`\n- `/extended/v2/burn-blocks/{height_or_hash}`\n- `/extended/v2/burn-blocks/{height_or_hash}/blocks`\n- `/extended/v2/blocks`\n- `/extended/v2/blocks/{height_or_hash}`\n- `/extended/v2/blocks/{height_or_hash}/transactions`\n- `/extended/v2/addresses/{address}/transactions:`\n- `/extended/v2/addresses/{address}/transactions/{tx_id}/events:`\n- `/extended/v2/smart-contracts/status`\n- `/extended/v2/pox/cycles`\n- `/extended/v2/pox/cycles/{cycle_number}`\n- `/extended/v2/pox/cycles/{cycle_number}/signers`\n- `/extended/v2/pox/cycles/{cycle_number}/signers/{signer_key}`\n- `/extended/v2/pox/cycles/{cycle_number}/signers/{signer_key}/stackers`\n\n### Deprecated endpoints\n\n- `/extended/v1/block`\n- `/extended/v1/block/{hash}`\n- `/extended/v1/block/by_height/{height}`\n- `/extended/v1/block/by_burn_block_hash/{burn_block_hash}`\n- `/extended/v1/block/by_burn_block_height/{burn_block_height}`\n- `/extended/v1/address/{principal}/transactions`\n- `/extended/v1/address/{principal}/{tx_id}/with_transfers`\n- `/extended/v1/address/{principal}/transactions_with_transfers`\n- `/extended/v1/fee_rate`\n- `/extended/v1/tx/block/{block_hash}`\n- `/extended/v1/tx/block_height/{height}`\n\nView the [API reference](/stacks/api/info).\n"
  },
  {
    "title": "Updates for Stacks.js",
    "description": "Discover Stacks.js changes related to the Nakamoto upgrade.",
    "slug": "/stacks/nakamoto/guides/stacks-js",
    "content": "\n## What's new\n\n### StackingClient\n\nInstall the latest nakamoto version with `npm install @stacks/stacking@latest`.\n\nThe StackingClient in `@stacks/stacking` was updated to match the latest `pox-4` contract.\n\n- Added `StackingClient.signPoxSignature()`\n- Added `Pox4SignatureTopic` enum\n- New stacking arguments for `StackingClient.stack`, `StackingClient.stackExtend`, `StackingClient.stackIncrease`, `StackingClient.stackAggregationCommit`, `StackingClient.stackAggregationCommitIndexed`, and `StackingClient.stackAggregationIncrease`\n\n### Nakamoto network\n\nTo test using the Nakamoto testnet, you can use the `StacksTestnet` network with a custom URL. The Nakamoto testnet is being hosted at https://api.testnet.hiro.so. Use this URL like this:\n\n```tsx\nimport { StacksTestnet } from \"@stacks/network\"\n\nconst network = new StacksTestnet({\n  url: \"https://api.testnet.hiro.so\"\n})\n```\n\n#### Example snippets\n\n**`StackingClient.signPoxSignature`**\n\n```ts\nconst client = StackingClient(MY_ADDRESS, new StacksTestnet())\n```\n\n```ts\nconst signature = client.signPoxSignature({\n  topic: \"stack-stx\",\n  rewardCycle: await client.getPoxInfo().reward_cycle_id,\n  poxAddress: MY_BTC_ADDRESS,\n  period: 2,\n  maxAmount: 10_000_000_000_000,\n  authId: 123n,\n\n  signerPrivateKey: MY_SIGNER_PRIVATE_KEY\n})\n```\n\n**New arguments for e.g. `StackingClient.stack`**\n\n```ts\nconst { txid } = await client.stack({\n  amountMicroStx: 10_000_000_000_000, // this can be at most the signature `maxAmount`\n  poxAddress: MY_BTC_ADDRESS,\n  cycles: 2, // this needs to match signature `period`\n  burnBlockHeight: CURRENT_BURN_BLOCK_HEIGHT,\n\n  // NEW ARGS\n  signerKey: MY_SIGNER_PUBLIC_KEY,\n  signerSignature: signature,\n  maxAmount: 10_000_000_000_000,\n  authId: 123n,\n\n  privateKey: MY_STX_PRIVATE_KEY\n})\n```\n"
  },
  {
    "title": "Unit testing",
    "description": "Learn how to write and run unit tests for your Clarity smart contracts using the Clarinet JS SDK and Vitest.",
    "slug": "/stacks/unit-testing",
    "content": "\nimport { Accordions, Accordion } from 'fumadocs-ui/components/accordion';\n\nUnit testing is the process of testing individual components or functions of smart contracts to ensure they work as expected. The Clarinet JS SDK provides a testing framework that allows you to write these tests using the Vitest testing framework, helping you catch bugs and errors early in the development process.\n\nIn this guide, you will:\n\n1. [Set up a new Clarinet project with a `defi` contract](#set-up-a-new-clarinet-project).\n2. [Write a unit test covering the `deposit` function](#test-the-deposit-function).\n3. [Run tests and generate coverage reports](#run-tests-and-generate-coverage-reports).\n\n---\n\n## Set up a new Clarinet project\n\nStart by creating a new project with the Clarinet CLI. The command below will create a project structure inside of `defi` with the necessary files and folders, including the Clarinet JS SDK already set up for testing.\n\n```terminal\n$ clarinet new stx-defi\n$ cd stx-defi\n```\n\nAfter changing into your project directory, run `npm install` to install the package dependencies for testing.\n\n```terminal\n$ npm install\n```\n\nSince the smart contract code is out of scope for this guide, we are going to use a pre-existing contract. First, generate a new file using the `clarinet contract new` command in order to set up your project with the necessary configuration and test files.\n\n```terminal\n$ clarinet contract new defi\n```\n\nNow, inside your `defi.clar` file, copy and paste the following contract code:\n\n```clarity\n;; Holds the total amount of deposits in the contract, initialized to 0.\n(define-data-var total-deposits uint u0)\n\n;; Maps a user's principal address to their deposited amount.\n(define-map deposits { owner: principal } { amount: uint })\n\n;; Public function for users to deposit STX into the contract.\n;; Updates their balance and the total deposits in the contract.\n(define-public (deposit (amount uint))\n  (let\n    (\n      ;; Fetch the current balance or default to 0 if none exists.\n      (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))\n    )\n    ;; Transfer the STX from sender = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\" to recipient = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.defi (ie: contract identifier on the chain!)\".\n    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))\n    ;; Update the user's deposit amount in the map.\n    (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })\n    ;; Update the total deposits variable.\n    (var-set total-deposits (+ (var-get total-deposits) amount))\n    ;; Return success.\n    (ok true)\n  )\n)\n\n;; Read-only function to get the total balance by tx-sender\n(define-read-only (get-balance-by-sender)\n  (ok (map-get? deposits { owner: tx-sender }))\n)\n```\n\nRun `clarinet check` to ensure that your smart contract is valid and ready for testing.\n\n<Callout>\nYou can find the full code for this project in [this repo](https://github.com/hirosystems/clarity-examples/tree/main/examples/stx-defi).\n</Callout>\n\n## Test the deposit function\n\nThis `deposit` function allows users to deposit STX into the contract, updating their balance inside a `deposits` map and adding to the total deposits stored in a `total-deposits` variable. The key tests we want to cover are that the deposit is successful and that the user's balance, as well as the contract's total deposits, are updated correctly.\n\nInside of your `defi.test.ts` file, replace the boilerplate code and add the following:\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { Cl } from '@stacks/transactions';\n\nconst accounts = simnet.getAccounts();\nconst wallet1 = accounts.get('wallet_1')!;\n```\n\nThese imports provide the testing framework and utilities we need. We also get the `wallet_1` account, which will act as our test user.\n\nNext, define the test suite and the specific test case:\n\n```typescript\ndescribe('stx-defi', () => {\n  it('allows users to deposit STX', () => {\n    // Test code will go here\n  });\n});\n```\n\nThis structure comes from our Vitest integration, and it organizes our tests and describes what we're testing. The `describe` block groups multiple test cases together, while the `it` block represents a single test case.\n\nNow, let's simulate a deposit. Inside of the `it` block, define the amount to deposit and call the `deposit` function:\n\n```typescript\nconst amount = 1000;\nconst deposit = simnet.callPublicFn('defi', 'deposit', [Cl.uint(amount)], wallet1);\n```\n\nThis code simulates a deposit by calling the `deposit` function, using the `callPublicFn` method from the Clarinet JS SDK, in our contract with a specified amount, just as a user would in the real world.\n\nAfter making the deposit, create an assertion to verify that the call itself was successful and returns an `ok` response type with the value `true`:\n\n```typescript\nexpect(deposit.result).toBeOk(Cl.bool(true));\n```\n\nRun `npm run test` to confirm that this test passes.\n\nLet's go over some of the code in this assertion:\n\n- `expect` is a function from Vitest that makes an assertion about the value we expect to get back from the `deposit` function.\n\nBut how do we test against Clarity types and values? This is where the `Cl` and `toBeOk` helpers come in.\n\n- `toBeOk` is a custom matcher function built into Vitest that checks if the result of the deposit call is an `Ok` response, which is a Clarity type. This is important because it confirms that the deposit transaction was processed successfully.\n- `Cl` helper is from the `@stacks/transactions` package and is used to create Clarity values in JavaScript. In this case, it's used to create a Clarity boolean with the value of `true`.\n\n<Callout>\nTo see more custom matcher examples, check out the [reference page](/stacks/clarinet-js-sdk/references/custom-matchers).\n</Callout>\n\nOnce we can confirm that the deposit was successful, write a test to verify that the contract's total deposits have been updated correctly.\n\n```typescript\nconst totalDeposits = simnet.getDataVar('defi', 'total-deposits');\nexpect(totalDeposits).toBeUint(amount);\n```\n\nRun `npm run test` again to confirm that this test also passes.\n\nThis check ensures that the contract accepted our deposit without any issues.\n\nLastly, verify that the user's balance has been updated correctly:\n\n```typescript\nconst balance = simnet.callReadOnlyFn('defi', 'get-balance-by-sender', [], wallet1);\nexpect(balance.result).toBeOk(\n  Cl.some(\n    Cl.tuple({\n      amount: Cl.uint(amount),\n    })\n  )\n);\n```\n\nWe call the `get-balance-by-sender` function and check if it matches the amount we just deposited.\n\nBy following these steps, our test comprehensively verifies that the `deposit` function works as intended, updating individual balances and total deposits accurately.\n\n<Accordions>\n  <Accordion title=\"Full code snippet\">\n```typescript\n  import { describe, it, expect } from 'vitest';\n  import { Cl } from '@stacks/transactions';\n\n  const accounts = simnet.getAccounts();\n  const wallet1 = accounts.get('wallet_1')!;\n\n  describe('stx-defi', () => {\n    it('allows users to deposit STX', () => {\n      const amount = 1000;\n      const deposit = simnet.callPublicFn('defi', 'deposit', [Cl.uint(amount)], wallet1);\n      expect(deposit.result).toBeOk(Cl.bool(true));\n\n      const totalDeposits = simnet.getDataVar('defi', 'total-deposits');\n      expect(totalDeposits).toBeUint(amount);\n\n      const balance = simnet.callReadOnlyFn('defi', 'get-balance-by-sender', [], wallet1);\n      expect(balance.result).toBeOk(\n        Cl.some(\n          Cl.tuple({\n            amount: Cl.uint(amount),\n          })\n        )\n      );\n    });\n  });\n```\n  </Accordion>\n</Accordions>\n\n## Run tests and generate coverage reports\n\nTo run your tests, use:\n\n```terminal\n$ npm run test\n```\n\nTo generate a coverage report, use:\n\n```terminal\n$ npm run coverage\n```\n\nThis will run your tests and produce a detailed coverage report, helping you identify any untested parts of your contract.\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/simnet\"\n    title=\"API reference\"\n    description=\"Dive deeper into the properties and methods available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/custom-matchers\"\n    title=\"Custom matchers\"\n    description=\"Learn about the custom matchers that are available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/methods\"\n    title=\"SDK methods\"\n    description=\"Learn about the methods available in the Clarinet JS SDK.\"\n  />\n</Cards>"
  },
  {
    "title": "Smart contract development",
    "description": "Build your smart contracts on Stacks.",
    "slug": "/stacks/smart-contract-development",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nLFG!\n\n## Related tools\n\n- **[Clarinet](/stacks/clarinet)**: Build your app in a local environment on Stacks.\n- **[Stacks.js](/stacks/stacks.js)**: Don’t reinvent the wheel and build faster with a JS library that handles basic blockchain functionality.\n- **[Stacks Blockchain API](/stacks/api)**: Fetch data and broadcast transactions with the Stacks Blockchain API.\n\n<br />\n\n<Callout title=\"Need help building with Clarinet JS SDK?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#clarinet</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>"
  },
  {
    "title": "@stacks/transactions",
    "description": "Construct, decode transactions and work with Clarity smart contracts on the Stacks blockchain.",
    "slug": "/stacks/stacks.js/v6/transactions",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\n\nThe Stacks authentication process enables secure user sign-in for web apps by generating and handling encrypted authentication requests. It involves setting up an app domain, configuring permissions, and creating a UserSession to manage user data.\n\n## Installation\n\n```package-install\n@stacks/transactions\n```\n\n{/* <Root>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`AppConfig`</h2>\n\nConfiguration data for the current app.\n\nOn browser platforms, creating an instance of this class without any arguments will use `window.location.origin` as the app domain. On non-browser platforms, you need to specify an app domain as the second argument.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"scopes\"} type={\"string[]\"}>\n\nAn array of strings representing permissions requested by the app.\n\n<span>Default: `['store_write']`</span>\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"appDomain\"} type={\"string\"}>\n\nStacks apps are uniquely identified by their app domain.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"redirectPath\"} type={\"string\"}>\n\nPath on app domain to redirect users to after authentication. The authentication response token will be postpended in a query.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"manifestPath\"} type={\"string\"}>\n\nPath relative to app domain of app's manifest file.\n\n<span>Default: `\"/manifest.json\"`</span>\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"coreNode\"} type={\"string\"}>\n\nThe URL of Stacks core node to use for this app. If this is not specified, the default core node will be used.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"authenticatorURL\"} type={\"string\"}>\n\nThe URL of a web-based authenticator to use in the event the user doesn't have Stacks installed on their machine. If this is not specified, the current default in this library will be used.\n\n</Property>\n\n</div>\n\n<APIExample>\n\n<Tabs defaultValue=\"config\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"config\" className='tab group'>\n      <Badge className='badge transition-colors'>Setting basic app permissions</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"options\" className='tab group'>\n      <Badge className='badge transition-colors'>With advanced scopes</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"config\">\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:AppConfig]\n    import { AppConfig } from '@stacks/auth';\n\n    const appDomain = 'https://www.myapp.com';\n    const appConfig = new AppConfig(\n      ['store_write'],\n      appDomain\n    );\n    ```\n\n    <Accordions>\n\n    <Accordion title={\"Full Code Sample\"}>\n      ```tsx twoslash\n      import {\n        UserSession,\n        makeAuthRequest,\n        AppConfig\n      } from '@stacks/auth';\n\n      const appDomain = 'https://www.myapp.com';\n\n      const appConfig = new AppConfig(['store_write'], appDomain);\n      const userSession = new UserSession({ appConfig });\n\n      // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n      const transitKey = userSession.generateAndStoreTransitKey();\n      \n      // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n      const redirectUri = 'https://www.myapp.com/auth';\n\n      // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n      const manifestUri = 'https://www.myapp.com/manifest.json';\n\n      // Generate the authentication request payload\n      const authRequest = userSession.makeAuthRequest(\n        transitKey,\n        redirectUri,\n        manifestUri\n      );\n      \n      ```\n    </Accordion>\n\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"options\">\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:publish_data]\n    // [!code word:email]\n    import { AppConfig } from '@stacks/auth';\n\n    const appDomain = 'https://www.myapp.com';\n    const appConfig = new AppConfig(\n      ['store_write', 'publish_data', 'email'],\n      appDomain\n    );\n    ```\n    <Accordions>\n\n    <Accordion title={\"Full Code Sample\"}>\n      ```tsx twoslash\n      import {\n        UserSession,\n        makeAuthRequest,\n        AppConfig\n      } from '@stacks/auth';\n\n      const appDomain = 'https://www.myapp.com';\n\n      const appConfig = new AppConfig(['store_write'], appDomain);\n      const userSession = new UserSession({ appConfig });\n\n      // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n      const transitKey = userSession.generateAndStoreTransitKey();\n      \n      // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n      const redirectUri = 'https://www.myapp.com/auth';\n\n      // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n      const manifestUri = 'https://www.myapp.com/manifest.json';\n\n      // Generate the authentication request payload\n      const authRequest = userSession.makeAuthRequest(\n        transitKey,\n        redirectUri,\n        manifestUri\n      );\n      \n      ```\n    </Accordion>\n\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`UserSession`</h2>\n\nRepresents an instance of a signed in user for a particular app.\n\n## Functions\n\n<Property required={false} deprecated={false} name={\"isSignInPending\"} type={\"function\"}>\n\nDetermines if there is an incoming authentication response.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"handlePendingSignIn\"} type={\"function\"}>\n\nProcesses the response and provides a `userData` object containing the user's identity, BNS username and profile information.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"isUserSignedIn\"} type={\"function\"}>\n\nChecks if the user is already authenticated.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"loadUserData\"} type={\"function\"}>\n\nRetrieves the user's profile data if the user is already authenticated.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"encryptContent\"} type={\"function\"}>\n\nEncrypts user data for secure storage.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"decryptContent\"} type={\"function\"}>\n\nDecrypts user data for secure storage.\n\n</Property>\n\n</div>\n\n<APIExample>\n<Tabs defaultValue=\"pending\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"pending\" className='tab group'>\n      <Badge className='badge transition-colors'>Handling pending auth</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"status\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking if user is signed in</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"user-data\" className='tab group'>\n      <Badge className='badge transition-colors'>Loading data for signed in user</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"sign-out\" className='tab group'>\n      <Badge className='badge transition-colors'>Signing out a user</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"encrypt\" className='tab group'>\n      <Badge className='badge transition-colors'>Encrypting user data</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"decrypt\" className='tab group'>\n      <Badge className='badge transition-colors'>Decrypting user data</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"pending\">\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:isSignInPending]\n    // [!code word:handlePendingSignIn]\n    const isPending = userSession.isSignInPending();\n\n    if (isPending) {\n      userSession.handlePendingSignIn().then(userData => {\n        // Do something with userData\n      });\n    }\n    ```\n  </TabsContent>\n  <TabsContent value='status'>\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:isUserSignedIn]\n    const isSignedIn = userSession.isUserSignedIn();\n    ```\n  </TabsContent>\n  <TabsContent value='user-data'>\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:loadUserData]\n    const isSignedIn = userSession.isUserSignedIn();\n\n    if (isSignedIn) {\n      // Do something with the signed in user\n      const userData = userSession.loadUserData();\n    }\n    ```\n  </TabsContent>\n  <TabsContent value='sign-out'>\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:signUserOut]\n    userSession.signUserOut();\n    ```\n  </TabsContent>\n  <TabsContent value='encrypt'>\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:encryptContent]\n    const message = 'My secret message';\n\n    const cipherText = await userSession.encryptContent(message);\n    ```\n  </TabsContent>\n  <TabsContent value='decrypt'>\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:decryptContent]\n    const message = 'My secret message';\n\n    const cipherText = await userSession.encryptContent(message);\n    const plainText = await userSession.decryptContent(cipherText);\n    ```\n  </TabsContent>\n</Tabs>\n\n<Accordions>\n\n<Accordion title={\"Notes\"}>\n  Note that encryption here uses the user's private key associated with your app only. If you need to share this data with another app or other users, you should use the equivalent methods from `@stacks/encryption` and provide a custom private key.\n</Accordion>\n\n</Accordions>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`makeAuthRequest`</h2>\n\nThe Stacks authentication process enables secure user sign-in for web apps by generating and handling encrypted authentication requests. It involves setting up an app domain, configuring permissions, and creating a UserSession to manage user data.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"transitKey\"} type={\"string\"}>\n\nThe authentication payloads are encrypted during transit, the encryption key generated below provides this\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"redirectURI\"} type={\"string\"}>\n\nA URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"manifestUri\"} type={\"string\"}>\n\nSet the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"scopes\"} type={\"string[]\"}>\n\nAdditional permissions the app is requesting\n\n</Property>\n\n</div>\n\n<APIExample>\n\n<Tabs defaultValue=\"auth-request\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"auth-request\" className='tab group'>\n      <Badge className='badge transition-colors'>Generate an authentication request</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"auth-request\">\n    ```tsx twoslash\n    // @noErrors\n    import {\n      UserSession,\n      makeAuthRequest,\n      AppConfig\n    } from '@stacks/auth';\n\n    const appDomain = 'https://www.myapp.com';\n\n    const appConfig = new AppConfig(['store_write'], appDomain);\n    const userSession = new UserSession({ appConfig });\n\n    // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n    const transitKey = userSession.generateAndStoreTransitKey();\n    \n    // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n    const redirectUri = 'https://www.myapp.com/auth';\n\n    // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n    const manifestUri = 'https://www.myapp.com/manifest.json';\n\n    // ---cut---\n    const authRequest = userSession.makeAuthRequest(\n      //                            ^^^^^^^^^^^^^^^\n      transitKey,\n      redirectUri,\n      manifestUri\n    );\n    ```\n\n    <Accordions>\n\n    <Accordion title={\"Full Code Sample\"}>\n      ```tsx twoslash\n      import {\n        UserSession,\n        makeAuthRequest,\n        AppConfig\n      } from '@stacks/auth';\n\n      const appDomain = 'https://www.myapp.com';\n\n      const appConfig = new AppConfig(['store_write'], appDomain);\n      const userSession = new UserSession({ appConfig });\n\n      // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n      const transitKey = userSession.generateAndStoreTransitKey();\n      \n      // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n      const redirectUri = 'https://www.myapp.com/auth';\n\n      // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n      const manifestUri = 'https://www.myapp.com/manifest.json';\n\n      // Generate the authentication request payload\n      const authRequest = userSession.makeAuthRequest(\n        transitKey,\n        redirectUri,\n        manifestUri\n      );\n      \n      ```\n    </Accordion>\n\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`lookupProfile`</h2>\n\nLook up a user's profile information by their BNS username.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"username\"} type={\"string\"}>\n\nThe BNS username of the user.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"network\"} type={\"'mainnet' | 'testnet' | 'devnet' | 'mocknet' | StacksNetwork\"}>\n\nDefines the network to connect to. Default is 'mainnet'.\n\n</Property>\n\n\n<Property required={false} deprecated={false} name={\"zoneFileLookupURL\"} type={\"string\"}>\n\nURL to fetch the zone file for the username. This is only needed if the zone file does not reside at the default location on the BNS network.\n\n</Property>\n\n</div>\n\n<APIExample>\n\n<Tabs defaultValue=\"lookup\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"lookup\" className='tab group'>\n      <Badge className='badge transition-colors'>Generate an authentication request</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"lookup\">\n    ```tsx twoslash\n    // @noErrors\n    import {\n      UserSession,\n      makeAuthRequest,\n      AppConfig\n    } from '@stacks/auth';\n\n    const appDomain = 'https://www.myapp.com';\n\n    const appConfig = new AppConfig(['store_write'], appDomain);\n    const userSession = new UserSession({ appConfig });\n\n    // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n    const transitKey = userSession.generateAndStoreTransitKey();\n    \n    // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n    const redirectUri = 'https://www.myapp.com/auth';\n\n    // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n    const manifestUri = 'https://www.myapp.com/manifest.json';\n\n    // ---cut---\n    const authRequest = userSession.makeAuthRequest(\n      //                            ^^^^^^^^^^^^^^^\n      transitKey,\n      redirectUri,\n      manifestUri\n    );\n    ```\n\n    <Accordions>\n\n    <Accordion title={\"Full Code Sample\"}>\n      ```tsx twoslash\n      import {\n        UserSession,\n        makeAuthRequest,\n        AppConfig\n      } from '@stacks/auth';\n\n      const appDomain = 'https://www.myapp.com';\n\n      const appConfig = new AppConfig(['store_write'], appDomain);\n      const userSession = new UserSession({ appConfig });\n\n      // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n      const transitKey = userSession.generateAndStoreTransitKey();\n      \n      // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n      const redirectUri = 'https://www.myapp.com/auth';\n\n      // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n      const manifestUri = 'https://www.myapp.com/manifest.json';\n\n      // Generate the authentication request payload\n      const authRequest = userSession.makeAuthRequest(\n        transitKey,\n        redirectUri,\n        manifestUri\n      );\n      \n      ```\n    </Accordion>\n\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n</Root> */}\n\nThis library supports the creation of the following Stacks transaction types:\n\n1. STX token transfer\n2. Smart contract deploy\n3. Smart contract function call\n\n## Key Generation\n\n```typescript\nimport { createStacksPrivateKey, makeRandomPrivKey, getPublicKey } from '@stacks/transactions';\n\n// Random key\nconst privateKey = makeRandomPrivKey();\n// Get public key from private\nconst publicKey = getPublicKey(privateKey);\n\n// Private key from hex string\nconst key = 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01';\nconst privateKey = createStacksPrivateKey(key);\n```\n\n## STX Token Transfer Transaction\n\n```typescript\nimport { makeSTXTokenTransfer, broadcastTransaction, AnchorMode } from '@stacks/transactions';\n\nconst txOptions = {\n  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',\n  amount: 12345n,\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  network: 'testnet', // for mainnet, use 'mainnet'\n  memo: 'test memo',\n  nonce: 0n, // set a nonce manually if you don't want builder to fetch from a Stacks node\n  fee: 200n, // set a tx fee if you don't want the builder to estimate\n  anchorMode: AnchorMode.Any,\n};\n\nconst transaction = await makeSTXTokenTransfer(txOptions);\n\n// to see the raw serialized tx\nconst serializedTx = transaction.serialize(); // Uint8Array\nconst serializedTxHex = bytesToHex(serializedTx); // hex string\n\n// broadcasting transaction to the specified network\nconst broadcastResponse = await broadcastTransaction(transaction);\nconst txId = broadcastResponse.txid;\n```\n\n## Smart Contract Deploy Transaction\n\n```typescript\nimport { makeContractDeploy, broadcastTransaction, AnchorMode } from '@stacks/transactions';\nimport { StacksTestnet, StacksMainnet } from '@stacks/network';\nimport { readFileSync } from 'fs';\n\n// for mainnet, use `StacksMainnet()`\nconst network = new StacksTestnet();\n\nconst txOptions = {\n  contractName: 'contract_name',\n  codeBody: readFileSync('/path/to/contract.clar').toString(),\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  network,\n  anchorMode: AnchorMode.Any,\n};\n\nconst transaction = await makeContractDeploy(txOptions);\n\nconst broadcastResponse = await broadcastTransaction(transaction, network);\nconst txId = broadcastResponse.txid;\n```\n\n## Smart Contract Function Call\n\n```typescript\nimport {\n  makeContractCall,\n  broadcastTransaction,\n  AnchorMode,\n  FungibleConditionCode,\n  makeStandardSTXPostCondition,\n  bufferCVFromString,\n} from '@stacks/transactions';\nimport { StacksTestnet, StacksMainnet } from '@stacks/network';\n\n// for mainnet, use `StacksMainnet()`\nconst network = new StacksTestnet();\n\n// Add an optional post condition\n// See below for details on constructing post conditions\nconst postConditionAddress = 'SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE';\nconst postConditionCode = FungibleConditionCode.GreaterEqual;\nconst postConditionAmount = 1000000n;\nconst postConditions = [\n  makeStandardSTXPostCondition(postConditionAddress, postConditionCode, postConditionAmount),\n];\n\nconst txOptions = {\n  contractAddress: 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X',\n  contractName: 'contract_name',\n  functionName: 'contract_function',\n  functionArgs: [bufferCVFromString('foo')],\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  validateWithAbi: true,\n  network,\n  postConditions,\n  anchorMode: AnchorMode.Any,\n};\n\nconst transaction = await makeContractCall(txOptions);\n\nconst broadcastResponse = await broadcastTransaction(transaction, network);\nconst txId = broadcastResponse.txid;\n```\n\nIn this example we construct a `contract-call` transaction with a post condition. We have set the `validateWithAbi` option to `true`, so the `makeContractCall` builder will attempt to fetch this contracts ABI from the specified Stacks network, and validate that the provided functionArgs match what is described in the ABI. This should help you avoid constructing invalid contract-call transactions. If you would prefer to provide your own ABI instead of fetching it from the network, the `validateWithABI` option also accepts [ClarityABI](https://github.com/blockstack/stacks-transactions-js/blob/master/src/contract-abi.ts#L231) objects, which can be constructed from ABI files like so:\n\n```typescript\nimport { ClarityAbi } from '@stacks/transactions';\nimport { readFileSync } from 'fs';\n\nconst abi: ClarityAbi = JSON.parse(readFileSync('abi.json').toString());\n// For sample abi json see: stacks.js/packages/transactions/tests/abi/test-abi.json\n```\n\n## Sponsoring Transactions\n\nTo generate a sponsored transaction, first create and sign the transaction as the origin. The `sponsored` property in the options object must be set to true.\n\n```typescript\nimport { bytesToHex } from '@stacks/common';\nimport { makeContractCall, BufferCV, AnchorMode, bufferCVFromString } from '@stacks/transactions';\n\nconst txOptions = {\n  contractAddress: 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X',\n  contractName: 'contract_name',\n  functionName: 'contract_function',\n  functionArgs: [bufferCVFromString('foo')],\n  fee: 0,\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  validateWithAbi: true,\n  sponsored: true,\n  anchorMode: AnchorMode.Any,\n};\n\nconst transaction = await makeContractCall(txOptions);\nconst serializedTx = bytesToHex(transaction.serialize());\n```\n\nThe serialized transaction can now be passed to the sponsoring party which will sign the sponsor portion of the transaction and set the fee.\n\n```typescript\nimport {\n  sponsorTransaction,\n  BytesReader,\n  deserializeTransaction,\n  broadcastTransaction,\n} from '@stacks/transactions';\nimport { StacksTestnet, StacksMainnet } from '@stacks/network';\n\nconst bytesReader = new BytesReader(Buffer.from(serializedTx, 'hex'));\nconst deserializedTx = deserializeTransaction(bytesReader);\nconst sponsorKey = '770287b9471081c8acd37d57190c7a70f0da2633311cc120853537362d32e67c01';\nconst fee = 1000n;\n\nconst sponsorOptions = {\n  transaction: deserializedTx,\n  sponsorPrivateKey: sponsorKey,\n  fee,\n  sponsorNonce: 0,\n};\n\nconst sponsoredTx = await sponsorTransaction(sponsorOptions);\n\n// for mainnet, use `StacksMainnet()`\nconst network = new StacksTestnet();\n\nconst broadcastResponse = await broadcastTransaction(sponsoredTx, network);\nconst txId = broadcastResponse.txid;\n```\n\n## Supporting multi-signature transactions\n\nTo generate a multi-sig transaction, first create an unsigned transaction.\nThe `numSignatures` and `publicKeys` properties in the options object must be set:\n\n```typescript\nimport {\n  makeUnsignedSTXTokenTransfer,\n  createStacksPrivateKey,\n  deserializeTransaction,\n  pubKeyfromPrivKey,\n  publicKeyToString,\n  TransactionSigner,\n  standardPrincipalCV,\n  BytesReader,\n  AnchorMode,\n} from '@stacks/transactions';\n\nconst recipient = standardPrincipalCV('SP3FGQ8...');\nconst amount = 2500000n;\nconst fee = 0n;\nconst memo = 'test memo';\n\n// private keys of the participants in the transaction\nconst privKeyStrings = ['6d430bb9...', '2a584d89...', 'd5200dee...'];\n\n// create private key objects from string array\nconst privKeys = privKeyStrings.map(createStacksPrivateKey);\n\n// corresponding public keys\nconst pubKeys = privKeyStrings.map(pubKeyfromPrivKey);\n\n// create public key string array from objects\nconst pubKeyStrings = pubKeys.map(publicKeyToString);\n\nconst transaction = await makeUnsignedSTXTokenTransfer({\n  recipient,\n  amount,\n  fee,\n  memo,\n  numSignatures: 2, // number of signature required\n  publicKeys: pubKeyStrings, // public key string array with >= numSignatures elements\n  anchorMode: AnchorMode.Any,\n});\n\nconst serializedTx = transaction.serialize();\n```\n\nThis transaction payload can be passed along to other participants to sign. In addition to\nmeeting the numSignatures requirement, the public keys of the parties who did not sign the\ntransaction must be appended to the signature.\n\n```typescript\n// deserialize and sign transaction\nconst bytesReader = new BytesReader(serializedTx);\n// Partially signed or unsigned multi-sig tx can be deserialized to add the required signatures\nconst deserializedTx = deserializeTransaction(bytesReader);\n\nconst signer = new TransactionSigner(deserializedTx);\n\n// first signature\nsigner.signOrigin(privKeys[0]);\n\n// second signature\nsigner.signOrigin(privKeys[1]);\n\n// after meeting the numSignatures requirement, the public\n// keys of the participants who did not sign must be appended\nsigner.appendOrigin(pubKeys[2]);\n\n// the serialized multi-sig tx\nconst serializedSignedTx = deserializedTx.serialize();\n```\n\n## Calling Read-only Contract Functions\n\nRead-only contract functions can be called without generating or broadcasting a transaction. Instead it works via a direct API call to a Stacks node.\n\n```typescript\nimport { bufferCVFromString, callReadOnlyFunction } from '@stacks/transactions';\nimport { StacksTestnet } from '@stacks/network';\n\nconst contractAddress = 'ST3KC0MTNW34S1ZXD36JYKFD3JJMWA01M55DSJ4JE';\nconst contractName = 'kv-store';\nconst functionName = 'get-value';\nconst buffer = bufferCVFromString('foo');\nconst network = new StacksTestnet();\nconst senderAddress = 'ST2F4BK4GZH6YFBNHYDDGN4T1RKBA7DA1BJZPJEJJ';\n\nconst options = {\n  contractAddress,\n  contractName,\n  functionName,\n  functionArgs: [buffer],\n  network,\n  senderAddress,\n};\n\nconst result = await callReadOnlyFunction(options);\n```\n\n## Constructing Clarity Values\n\nBuilding transactions that call functions in deployed clarity contracts requires you to construct valid Clarity Values to pass to the function as arguments. The [Clarity type system](https://github.com/stacksgov/sips/blob/master/sip/sip-002-smart-contract-language.md#clarity-type-system) contains the following types:\n\n- `(tuple (key-name-0 key-type-0) (key-name-1 key-type-1) ...)` : a typed tuple with named fields.\n- `(list max-len entry-type)` : a list of maximum length max-len, with entries of type entry-type\n- `(response ok-type err-type)` : object used by public functions to commit their changes or abort. May be returned or used by other functions as well, however, only public functions have the commit/abort behavior.\n- `(optional some-type)` : an option type for objects that can either be (some value) or none\n- `(buff max-len)` : byte buffer or maximum length max-len.\n- `principal` : object representing a principal (whether a contract principal or standard principal).\n- `bool` : boolean value (`true` or `false`)\n- `int` : signed 128-bit integer\n- `uint`: unsigned 128-bit integer\n\nThis library contains Typescript types and classes that map to the Clarity types, in order to make it easy to construct well-typed Clarity values in Javascript. These types all extend the abstract class `ClarityValue`.\n\n```typescript\nimport {\n  trueCV,\n  falseCV,\n  noneCV,\n  someCV,\n  intCV,\n  uintCV,\n  standardPrincipalCV,\n  contractPrincipalCV,\n  responseErrorCV,\n  responseOkCV,\n  listCV,\n  tupleCV,\n  bufferCV,\n} from '@stacks/transactions';\nimport { utf8ToBytes } from '@stacks/common';\n\n// construct boolean clarity values\nconst t = trueCV();\nconst f = falseCV();\n\n// construct optional clarity values\nconst nothing = noneCV();\nconst something = someCV(t);\n\n// construct a buffer clarity value from an existing byte array\nconst bytes = utf8ToBytes('foo'); // Uint8Array(3) [ 102, 111, 111 ]\nconst bufCV = bufferCV(bytes);\n\n// construct signed and unsigned integer clarity values\nconst i = intCV(-10);\nconst u = uintCV(10);\n\n// construct principal clarity values\nconst address = 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B';\nconst contractName = 'contract-name';\nconst spCV = standardPrincipalCV(address);\nconst cpCV = contractPrincipalCV(address, contractName);\n\n// construct response clarity values\nconst errCV = responseErrorCV(trueCV());\nconst okCV = responseOkCV(falseCV());\n\n// construct tuple clarity values\nconst tupCV = tupleCV({\n  a: intCV(1),\n  b: trueCV(),\n  c: falseCV(),\n});\n\n// construct list clarity values\nconst l = listCV([trueCV(), falseCV()]);\n```\n\nIf you develop in Typescript, the type checker can help prevent you from creating wrongly-typed Clarity values. For example, the following code won't compile since in Clarity lists are homogeneous, meaning they can only contain values of a single type. It is important to include the type variable `BooleanCV` in this example, otherwise the typescript type checker won't know which type the list is of and won't enforce homogeneity.\n\n```typescript\nconst l = listCV<BooleanCV>([trueCV(), intCV(1)]);\n```\n\n## Post Conditions\n\nThree types of post conditions can be added to transactions:\n\n1. STX post condition\n2. Fungible token post condition\n3. Non-Fungible token post condition\n\nFor details see: https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-post-conditions\n\n## STX post condition\n\n```typescript\nimport {\n  FungibleConditionCode,\n  makeStandardSTXPostCondition,\n  makeContractSTXPostCondition,\n} from '@stacks/transactions';\n\n// With a standard principal\nconst postConditionAddress = 'SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE';\nconst postConditionCode = FungibleConditionCode.GreaterEqual;\nconst postConditionAmount = 12345n;\n\nconst standardSTXPostCondition = makeStandardSTXPostCondition(\n  postConditionAddress,\n  postConditionCode,\n  postConditionAmount\n);\n\n// With a contract principal\nconst contractAddress = 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X';\nconst contractName = 'test-contract';\n\nconst contractSTXPostCondition = makeContractSTXPostCondition(\n  contractAddress,\n  contractName,\n  postConditionCode,\n  postConditionAmount\n);\n```\n\n## Fungible token post condition\n\n```typescript\nimport {\n  FungibleConditionCode,\n  createAssetInfo,\n  makeStandardFungiblePostCondition,\n} from '@stacks/transactions';\n\n// With a standard principal\nconst postConditionAddress = 'SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE';\nconst postConditionCode = FungibleConditionCode.GreaterEqual;\nconst postConditionAmount = 12345n;\nconst assetAddress = 'SP62M8MEFH32WGSB7XSF9WJZD7TQB48VQB5ANWSJ';\nconst assetContractName = 'test-asset-contract';\nconst assetName = 'test-token';\nconst fungibleAssetInfo = createAssetInfo(assetAddress, assetContractName, assetName);\n\nconst standardFungiblePostCondition = makeStandardFungiblePostCondition(\n  postConditionAddress,\n  postConditionCode,\n  postConditionAmount,\n  fungibleAssetInfo\n);\n\n// With a contract principal\nconst contractAddress = 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X';\nconst contractName = 'test-contract';\nconst assetAddress = 'SP62M8MEFH32WGSB7XSF9WJZD7TQB48VQB5ANWSJ';\nconst assetContractName = 'test-asset-contract';\nconst assetName = 'test-token';\nconst fungibleAssetInfo = createAssetInfo(assetAddress, assetContractName, assetName);\n\nconst contractFungiblePostCondition = makeContractFungiblePostCondition(\n  contractAddress,\n  contractName,\n  postConditionCode,\n  postConditionAmount,\n  fungibleAssetInfo\n);\n```\n\n## Non-fungible token post condition\n\n> **Warning**\n> The Stacks blockchain's post-condition processor can NOT check ownership.\n> It checks whether or not a principal **will send** or **will not send** an NFT.\n> Post-conditions can NOT verify anything about the recipient of an asset.\n> If you want to verify conditions about asset recipients, you will need to use [Clarity](https://docs.stacks.co/docs/write-smart-contracts/).\n\n```typescript\nimport {\n  NonFungibleConditionCode,\n  createAssetInfo,\n  makeStandardNonFungiblePostCondition,\n  makeContractNonFungiblePostCondition,\n  bufferCVFromString,\n} from '@stacks/transactions';\n\n// With a standard principal\nconst postConditionAddress = 'SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE';\nconst postConditionCode = NonFungibleConditionCode.DoesNotSend;\nconst assetAddress = 'SP62M8MEFH32WGSB7XSF9WJZD7TQB48VQB5ANWSJ';\nconst assetContractName = 'test-asset-contract';\nconst assetName = 'test-asset';\nconst assetId = bufferCVFromString('test-token-asset-id');\nconst nonFungibleAssetInfo = createAssetInfo(assetAddress, assetContractName, assetName);\n\nconst standardNonFungiblePostCondition = makeStandardNonFungiblePostCondition(\n  postConditionAddress,\n  postConditionCode,\n  nonFungibleAssetInfo,\n  assetId\n);\n\n// With a contract principal\nconst contractAddress = 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X';\nconst contractName = 'test-contract';\n\nconst contractNonFungiblePostCondition = makeContractNonFungiblePostCondition(\n  contractAddress,\n  contractName,\n  postConditionCode,\n  nonFungibleAssetInfo,\n  assetId\n);\n```\n\n## Conversion of Clarity Values to JSON\n\nClarity Values represent values of Clarity contracts. If a JSON format is required the helper function `cvToJSON` can be used.\n\n```typescript\nimport { cvToJSON, hexToCV } from '@stacks/transactions';\n\ncvToJSON(hexToCV(tx.tx_result.hex));\n```"
  },
  {
    "title": "@stacks/network",
    "description": "Network and API library for working with Stacks blockchain nodes.",
    "slug": "/stacks/stacks.js/v6/network",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\n\nThe Stacks authentication process enables secure user sign-in for web apps by generating and handling encrypted authentication requests. It involves setting up an app domain, configuring permissions, and creating a UserSession to manage user data.\n\n## Installation\n\n```package-install\n@stacks/network\n```\n\n{/* <Root>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`AppConfig`</h2>\n\nConfiguration data for the current app.\n\nOn browser platforms, creating an instance of this class without any arguments will use `window.location.origin` as the app domain. On non-browser platforms, you need to specify an app domain as the second argument.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"scopes\"} type={\"string[]\"}>\n\nAn array of strings representing permissions requested by the app.\n\n<span>Default: `['store_write']`</span>\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"appDomain\"} type={\"string\"}>\n\nStacks apps are uniquely identified by their app domain.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"redirectPath\"} type={\"string\"}>\n\nPath on app domain to redirect users to after authentication. The authentication response token will be postpended in a query.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"manifestPath\"} type={\"string\"}>\n\nPath relative to app domain of app's manifest file.\n\n<span>Default: `\"/manifest.json\"`</span>\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"coreNode\"} type={\"string\"}>\n\nThe URL of Stacks core node to use for this app. If this is not specified, the default core node will be used.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"authenticatorURL\"} type={\"string\"}>\n\nThe URL of a web-based authenticator to use in the event the user doesn't have Stacks installed on their machine. If this is not specified, the current default in this library will be used.\n\n</Property>\n\n</div>\n\n<APIExample>\n\n<Tabs defaultValue=\"config\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"config\" className='tab group'>\n      <Badge className='badge transition-colors'>Setting basic app permissions</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"options\" className='tab group'>\n      <Badge className='badge transition-colors'>With advanced scopes</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"config\">\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:AppConfig]\n    import { AppConfig } from '@stacks/auth';\n\n    const appDomain = 'https://www.myapp.com';\n    const appConfig = new AppConfig(\n      ['store_write'],\n      appDomain\n    );\n    ```\n\n    <Accordions>\n\n    <Accordion title={\"Full Code Sample\"}>\n      ```tsx twoslash\n      import {\n        UserSession,\n        makeAuthRequest,\n        AppConfig\n      } from '@stacks/auth';\n\n      const appDomain = 'https://www.myapp.com';\n\n      const appConfig = new AppConfig(['store_write'], appDomain);\n      const userSession = new UserSession({ appConfig });\n\n      // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n      const transitKey = userSession.generateAndStoreTransitKey();\n\n      // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n      const redirectUri = 'https://www.myapp.com/auth';\n\n      // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n      const manifestUri = 'https://www.myapp.com/manifest.json';\n\n      // Generate the authentication request payload\n      const authRequest = userSession.makeAuthRequest(\n        transitKey,\n        redirectUri,\n        manifestUri\n      );\n\n      ```\n    </Accordion>\n\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"options\">\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:publish_data]\n    // [!code word:email]\n    import { AppConfig } from '@stacks/auth';\n\n    const appDomain = 'https://www.myapp.com';\n    const appConfig = new AppConfig(\n      ['store_write', 'publish_data', 'email'],\n      appDomain\n    );\n    ```\n    <Accordions>\n\n    <Accordion title={\"Full Code Sample\"}>\n      ```tsx twoslash\n      import {\n        UserSession,\n        makeAuthRequest,\n        AppConfig\n      } from '@stacks/auth';\n\n      const appDomain = 'https://www.myapp.com';\n\n      const appConfig = new AppConfig(['store_write'], appDomain);\n      const userSession = new UserSession({ appConfig });\n\n      // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n      const transitKey = userSession.generateAndStoreTransitKey();\n\n      // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n      const redirectUri = 'https://www.myapp.com/auth';\n\n      // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n      const manifestUri = 'https://www.myapp.com/manifest.json';\n\n      // Generate the authentication request payload\n      const authRequest = userSession.makeAuthRequest(\n        transitKey,\n        redirectUri,\n        manifestUri\n      );\n\n      ```\n    </Accordion>\n\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`UserSession`</h2>\n\nRepresents an instance of a signed in user for a particular app.\n\n## Functions\n\n<Property required={false} deprecated={false} name={\"isSignInPending\"} type={\"function\"}>\n\nDetermines if there is an incoming authentication response.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"handlePendingSignIn\"} type={\"function\"}>\n\nProcesses the response and provides a `userData` object containing the user's identity, BNS username and profile information.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"isUserSignedIn\"} type={\"function\"}>\n\nChecks if the user is already authenticated.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"loadUserData\"} type={\"function\"}>\n\nRetrieves the user's profile data if the user is already authenticated.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"encryptContent\"} type={\"function\"}>\n\nEncrypts user data for secure storage.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"decryptContent\"} type={\"function\"}>\n\nDecrypts user data for secure storage.\n\n</Property>\n\n</div>\n\n<APIExample>\n<Tabs defaultValue=\"pending\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"pending\" className='tab group'>\n      <Badge className='badge transition-colors'>Handling pending auth</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"status\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking if user is signed in</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"user-data\" className='tab group'>\n      <Badge className='badge transition-colors'>Loading data for signed in user</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"sign-out\" className='tab group'>\n      <Badge className='badge transition-colors'>Signing out a user</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"encrypt\" className='tab group'>\n      <Badge className='badge transition-colors'>Encrypting user data</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"decrypt\" className='tab group'>\n      <Badge className='badge transition-colors'>Decrypting user data</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"pending\">\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:isSignInPending]\n    // [!code word:handlePendingSignIn]\n    const isPending = userSession.isSignInPending();\n\n    if (isPending) {\n      userSession.handlePendingSignIn().then(userData => {\n        // Do something with userData\n      });\n    }\n    ```\n  </TabsContent>\n  <TabsContent value='status'>\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:isUserSignedIn]\n    const isSignedIn = userSession.isUserSignedIn();\n    ```\n  </TabsContent>\n  <TabsContent value='user-data'>\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:loadUserData]\n    const isSignedIn = userSession.isUserSignedIn();\n\n    if (isSignedIn) {\n      // Do something with the signed in user\n      const userData = userSession.loadUserData();\n    }\n    ```\n  </TabsContent>\n  <TabsContent value='sign-out'>\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:signUserOut]\n    userSession.signUserOut();\n    ```\n  </TabsContent>\n  <TabsContent value='encrypt'>\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:encryptContent]\n    const message = 'My secret message';\n\n    const cipherText = await userSession.encryptContent(message);\n    ```\n  </TabsContent>\n  <TabsContent value='decrypt'>\n    ```tsx twoslash\n    // @noErrors\n    // [!code word:decryptContent]\n    const message = 'My secret message';\n\n    const cipherText = await userSession.encryptContent(message);\n    const plainText = await userSession.decryptContent(cipherText);\n    ```\n  </TabsContent>\n</Tabs>\n\n<Accordions>\n\n<Accordion title={\"Notes\"}>\n  Note that encryption here uses the user's private key associated with your app only. If you need to share this data with another app or other users, you should use the equivalent methods from `@stacks/encryption` and provide a custom private key.\n</Accordion>\n\n</Accordions>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`makeAuthRequest`</h2>\n\nThe Stacks authentication process enables secure user sign-in for web apps by generating and handling encrypted authentication requests. It involves setting up an app domain, configuring permissions, and creating a UserSession to manage user data.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"transitKey\"} type={\"string\"}>\n\nThe authentication payloads are encrypted during transit, the encryption key generated below provides this.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"redirectURI\"} type={\"string\"}>\n\nA URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"manifestUri\"} type={\"string\"}>\n\nSet the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"scopes\"} type={\"string[]\"}>\n\nAdditional permissions the app is requesting.\n\n</Property>\n\n</div>\n\n<APIExample>\n\n<Tabs defaultValue=\"auth-request\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"auth-request\" className='tab group'>\n      <Badge className='badge transition-colors'>Generate an authentication request</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"auth-request\">\n    ```tsx twoslash\n    // @noErrors\n    import {\n      UserSession,\n      makeAuthRequest,\n      AppConfig\n    } from '@stacks/auth';\n\n    const appDomain = 'https://www.myapp.com';\n\n    const appConfig = new AppConfig(['store_write'], appDomain);\n    const userSession = new UserSession({ appConfig });\n\n    // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n    const transitKey = userSession.generateAndStoreTransitKey();\n\n    // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n    const redirectUri = 'https://www.myapp.com/auth';\n\n    // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n    const manifestUri = 'https://www.myapp.com/manifest.json';\n\n    // ---cut---\n    const authRequest = userSession.makeAuthRequest(\n      //                            ^^^^^^^^^^^^^^^\n      transitKey,\n      redirectUri,\n      manifestUri\n    );\n    ```\n\n    <Accordions>\n\n    <Accordion title={\"Full Code Sample\"}>\n      ```tsx twoslash\n      import {\n        UserSession,\n        makeAuthRequest,\n        AppConfig\n      } from '@stacks/auth';\n\n      const appDomain = 'https://www.myapp.com';\n\n      const appConfig = new AppConfig(['store_write'], appDomain);\n      const userSession = new UserSession({ appConfig });\n\n      // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n      const transitKey = userSession.generateAndStoreTransitKey();\n\n      // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n      const redirectUri = 'https://www.myapp.com/auth';\n\n      // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n      const manifestUri = 'https://www.myapp.com/manifest.json';\n\n      // Generate the authentication request payload\n      const authRequest = userSession.makeAuthRequest(\n        transitKey,\n        redirectUri,\n        manifestUri\n      );\n\n      ```\n    </Accordion>\n\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`lookupProfile`</h2>\n\nLook up a user's profile information by their BNS username.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"username\"} type={\"string\"}>\n\nThe BNS username of the user.\n\n</Property>\n\n<Property required={false} deprecated={false} name={\"network\"} type={\"'mainnet' | 'testnet' | 'devnet' | 'mocknet' | StacksNetwork\"}>\n\nDefines the network to connect to. Default is 'mainnet'.\n\n</Property>\n\n\n<Property required={false} deprecated={false} name={\"zoneFileLookupURL\"} type={\"string\"}>\n\nURL to fetch the zone file for the username. This is only needed if the zone file does not reside at the default location on the BNS network.\n\n</Property>\n\n</div>\n\n<APIExample>\n\n<Tabs defaultValue=\"lookup\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"lookup\" className='tab group'>\n      <Badge className='badge transition-colors'>Generate an authentication request</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"lookup\">\n    ```tsx twoslash\n    // @noErrors\n    import {\n      UserSession,\n      makeAuthRequest,\n      AppConfig\n    } from '@stacks/auth';\n\n    const appDomain = 'https://www.myapp.com';\n\n    const appConfig = new AppConfig(['store_write'], appDomain);\n    const userSession = new UserSession({ appConfig });\n\n    // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n    const transitKey = userSession.generateAndStoreTransitKey();\n\n    // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n    const redirectUri = 'https://www.myapp.com/auth';\n\n    // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n    const manifestUri = 'https://www.myapp.com/manifest.json';\n\n    // ---cut---\n    const authRequest = userSession.makeAuthRequest(\n      //                            ^^^^^^^^^^^^^^^\n      transitKey,\n      redirectUri,\n      manifestUri\n    );\n    ```\n\n    <Accordions>\n\n    <Accordion title={\"Full Code Sample\"}>\n      ```tsx twoslash\n      import {\n        UserSession,\n        makeAuthRequest,\n        AppConfig\n      } from '@stacks/auth';\n\n      const appDomain = 'https://www.myapp.com';\n\n      const appConfig = new AppConfig(['store_write'], appDomain);\n      const userSession = new UserSession({ appConfig });\n\n      // The authentication payloads are encrypted during transit, the encryption key generated below provides this\n      const transitKey = userSession.generateAndStoreTransitKey();\n\n      // The Stacks auth process will open a compatible Stacks authenticator or browser extension to perform the authentication. So you will need to provide a redirect URL which the authenticator or extension can redirect to with the authentication payload. This page should process the authentication payload.\n      const redirectUri = 'https://www.myapp.com/auth';\n\n      // Set the location of your app manifest file. This file contains information about your app that is shown to the user during authentication.\n      const manifestUri = 'https://www.myapp.com/manifest.json';\n\n      // Generate the authentication request payload\n      const authRequest = userSession.makeAuthRequest(\n        transitKey,\n        redirectUri,\n        manifestUri\n      );\n\n      ```\n    </Accordion>\n\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n</Root> */}\n\n\n## Usage\n\n## Create a Stacks mainnet, testnet or mocknet network\n\n```typescript\nimport { StacksMainnet, StacksTestnet, StacksMocknet } from '@stacks/network';\n\nconst network = new StacksMainnet();\n\nconst testnet = new StacksTestnet();\n\nconst mocknet = new StacksMocknet();\n```\n\n## Set a custom node URL\n\n```typescript\nconst network = new StacksMainnet({ url: 'https://www.mystacksnode.com/' });\n```\n\n## Check if network is mainnet\n\n```typescript\nconst isMainnet = network.isMainnet();\n```\n\n## Network usage in transaction building\n\n```typescript\nimport { makeSTXTokenTransfer } from '@stacks/transactions';\n\nconst txOptions = {\n  network,\n  recipient: 'SP2BS6HD7TN34V8Z5BNF8Q2AW3K8K2DPV4264CF26',\n  amount: new BigNum(12345),\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n};\n\nconst transaction = await makeSTXTokenTransfer(txOptions);\n```\n\n## Use the built-in API key middleware\n\nSome Stacks APIs make use API keys to provide less rate-limited plans.\n\n```typescript\nimport { createApiKeyMiddleware, createFetchFn, StacksMainnet } from '@stacks/network';\nimport { broadcastTransaction, getNonce, makeSTXTokenTransfer } from '@stacks/transactions';\n\nconst myApiMiddleware = createApiKeyMiddleware('example_e8e044a3_41d8b0fe_3dd3988ef302');\nconst myFetchFn = createFetchFn(myApiMiddleware); // middlewares can be used to create a new fetch function\nconst myMainnet = new StacksMainnet({ fetchFn: myFetchFn }); // the fetchFn options can be passed to a StacksNetwork to override the default fetch function\n\nconst txOptions = {\n  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',\n  amount: 12345n,\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  memo: 'some memo',\n  anchorMode: AnchorMode.Any,\n  network: myMainnet, // make sure to pass in the custom network object\n};\nconst transaction = await makeSTXTokenTransfer(txOptions); // fee-estimation will use the custom fetchFn\n\nconst response = await broadcastTransaction(transaction, myMainnet); // make sure to broadcast via the custom network object\n\n// stacks.js functions, which take a StacksNetwork object will use the custom fetchFn\nconst nonce = await getNonce('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159', myMainnet);\n```\n\n## Use custom middleware\n\nMiddleware can be used to hook into network calls before sending a request or after receiving a response.\n\n```typescript\nimport { createFetchFn, RequestContext, ResponseContext, StacksTestnet } from '@stacks/network';\nimport { broadcastTransaction, getNonce, makeSTXTokenTransfer } from '@stacks/transactions';\n\nconst preMiddleware = (ctx: RequestContext) => {\n  ctx.init.headers = new Headers();\n  ctx.init.headers.set('x-foo', 'bar'); // override headers and set new `x-foo` header\n};\nconst postMiddleware = (ctx: ResponseContext) => {\n  console.log(await ctx.response.json()); // log response body as json\n};\n\nconst fetchFn = createFetchFn({ pre: preMiddleware, post: preMiddleware }); // a middleware can contain `pre`, `post`, or both\nconst network = new StacksTestnet({ fetchFn });\n\n// stacks.js functions, which take a StacksNetwork object will use the custom fetchFn\nconst nonce = await getNonce('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159', network);\n```\n\n## Get various API URLs\n\n```typescript\nconst txBroadcastUrl = network.getBroadcastApiUrl();\n\nconst feeEstimateUrl = network.getTransferFeeEstimateApiUrl();\n\nconst address = 'SP2BS6HD7TN34V8Z5BNF8Q2AW3K8K2DPV4264CF26';\nconst accountInfoUrl = network.getAccountApiUrl(address);\n\nconst contractName = 'hello_world';\nconst abiUrl = network.getAbiApiUrl(address, contractName);\n\nconst functionName = 'hello';\nconst readOnlyFunctionCallUrl = network.getReadOnlyFunctionCallApiUrl(\n  address,\n  contractName,\n  functionName\n);\n\nconst nodeInfoUrl = network.getInfoUrl();\n\nconst blockTimeUrl = network.getBlockTimeInfoUrl();\n\nconst poxInfoUrl = network.getPoxInfoUrl();\n```\n"
  },
  {
    "title": "Overview",
    "description": "A collection of JavaScript libraries to build web applications on Stacks.",
    "slug": "/stacks/stacks.js/index",
    "content": "\nimport { Globe } from 'lucide-react';\nimport { Card, SecondaryCard } from '@/components/card';\n\nStacks.js is a JavaScript/TypeScript SDK for building on the Stacks blockchain. It's a collection of various JavaScript libraries that allow you to broadcast a transaction with the Stacks blockchain, construct post-conditions, and more. Some of the most important building blocks, all in one place.\n\nStacks.js is separated into many smaller packages, which can be installed individually. Most packages are published to npm under the `@stacks` scope.\n\nFor more details, check out out our [installation guide](./stacks.js/installation).\n\n<SecondaryCard\n  icon={<Globe/>}\n  href=\"/stacks/connect\"\n  title=\"Build a Stacks web app\"\n  description=\"Integrate Stacks.js into your web apps with Stacks Connect.\"\n  tag=\"Stacks Connect\"\n/>\n\n## Guides\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/stacks.js/guides/broadcast-transactions\"\n    title=\"Broadcast transactions\"\n    description=\"Create and broadcast transactions using Stacks.js builder and helper functions.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/stacks.js/guides/post-conditions\"\n    title=\"Constructing post-conditions\"\n    description=\"Build post-conditions into your smart contracts and safe-guard your users.\"\n  />\n</Cards>\n\n## Related tools\n\n- **[Clarinet](/stacks/clarinet)**: Build your app in a local environment on Stacks.\n- **[Stacks Connect](/stacks/connect)**: Interact with the Stacks blockchain with your wallet extension.\n- **[Hiro Platform](/stacks/platform)**: A developer platform for building, deploying and scaling Bitcoin apps.\n- **[Stacks Blockchain API](/stacks/api)**: Fetch data and broadcast transactions with the Stacks Blockchain API.\n\n<br />\n\n<Callout title=\"Need help building with Stacks.js?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#stacks-js</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>\n"
  },
  {
    "title": "Announcing Stacks.js v7",
    "description": "Discover the future of Stacks.js.",
    "slug": "/stacks/stacks.js/roadmap",
    "content": "\nRead about what's new in the latest version of Stacks.js.\nThis version comes with a lot of improvements and new features, but it also adds some breaking changes.\n\nWant to use these latest features? Install packages using the `latest` tag:\n\n```package-install\n@stacks/{common,network,transactions}@latest\n```\n\n### Strings\n_aka, reducing wrapper types and magic numbers_\n\n<img src=\"/string-meme.png\" className=\"max-w-[300px] mx-auto\" alt=\"String Meme\" />\n\n#### Problem\n\nMany Stacks.js representations we're not debuggable for developers.\nLogging Clarity values resulted in unintelligible `type` and `value` numbers, confusing even experienced Stacks developers.\nPrivate keys were also included unnecessary `type` properties with raw byte arrays.\n\"Magic\" numbers are all accross the codebase (as they are needed for serialization), but these shouldn't be part of the \"public\" interfaces.\n\n#### Solution\n\nWe switched to a system where most values will be represented as strings.\nThis makes them easier to inspect and diff.\n\nClarity example, [Read more](#clarity-representation)\n```ts\n// !diff -\n{ type: 1, value: 12n }\n// !diff +\n{ type: \"uint\", value: \"12\" }\n```\n\nPrivate key example, [Read more](/stacks/stacks.js/concepts/private-keys)\n```ts\nsignMessageHashRsv({\n  // !diff -\n  privateKey: createStacksPrivateKey(\"f5a3...2801\"), // { compressed: true, data: [245,163,...] }\n  // !diff +\n  privateKey: \"f5a3...2801\"\n})\n```\n\nThis breaks the signatures of many functions:\n\n- `signMessageHashRsv`, `signWithKey` now return the message signature as a `string` directly.\n- `nextSignature`, `nextVerification`, `publicKeyFromSignatureVrs`, `publicKeyFromSignatureRsv` now take in the message signature as a `string`.\n\n### Stacks Network\n\nFor a long time, Stacks.js \"network\" instances were used for \"networking\" and \"network\" definitions.\nThis caused confusion, as most users use `mainnet` or `testnet` for most of their interactions.\nThe \"networking\" (aka fetching) logic is now more clearly customizable.\n\nFrom now on \"network\" objects are static (aka constants) and don't require instantiation.\n\nThese changes should make it more obvious when functions are using network object properties vs when they are doing actual networking.\n\nIn most cases, developers shouldn't need the `@stacks/network` package anymore.\nThe `network` parameter can be used with string literals: `'mainnet'`, `'testnet'`, `'devnet'`, `'mocknet'`.\n\n```ts\nimport { StacksTestnet } from '@stacks/network';\n\nmakeSTXTokenTransfer({\n  // !diff -\n  network: new StacksTestnet(),\n  // !diff +\n  network: 'testnet'\n  // ...\n});\n```\n\n\n#### Stacks Network `client`\n\nIn case a function also takes a `client` parameter, it will be doing actual networking.\nThis way you can use string literal networks with a custom node.\nYou can also still use network objects with the `client` parameter as part of the network object.\nThe `client` parameter can be any object-like structure containing a `baseUrl` and `fetch` property.\n\n- The `baseUrl` property should be a string containing the base URL of the Stacks node you want to use.\n- The `fetch` property can be any (fetch)[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API] compatible function.\n\nThe following diffs show examples of how to migrate to the new pattern.\n\n```ts\nconst transaction = await makeSTXTokenTransfer({\n// !diff -  \nnetwork: new StacksTestnet({ url: \"mynode-optional.com\", fetchFn: myFetch }),\n// !diff +\nnetwork: 'testnet', // optional, defaults to 'mainnet'\n// !diff +\nclient: { baseUrl: \"mynode-optional.com\", fetch: myFetchOptional } // optional, defaults inferred from network\n});\n```\n\nThe `client` property is also part of the network object.\nYou can still keep ONE single network object for your whole application.\n\n```ts\n// !diff -\nimport { StacksTestnet } from '@stacks/network';\n// !diff +\nimport { STACKS_TESTNET } from '@stacks/network';\n\n// !diff -\nconst network = new StacksTestnet({ url: \"https://mynode.com\", fetchFn: myFetch });\n// !diff +\nconst network = {\n  // !diff +\n  ...STACKS_TESTNET, // extending a static object\n  // !diff +\n  client: { baseUrl: \"https://mynode.com\", fetch: myFetch }\n  // !diff +\n};\n```\n\n### A To B Helpers\n\nWhere possible, Stacks.js now offers function to translate between different representations and concepts.\nThe naming is consistent across the board and uses `A To B` naming.\nFor example, if we have a private key and want to get the address, we can use the `privateKeyToAddress` function.\n\n```ts\nimport { privateKeyToAddress } from \"@stacks/transactions\";\n\nconst privateKey = \"f5a3...2801\";\nconst address = privateKeyToAddress(privateKey); // SP1MXSZF4NFC8JQ1TTYGEC2WADMC7Y3GHVZYRX6RF\n```\n\n### Fetch Methods\n\nTo make it easier to discover all fetching functions, they now all start with `fetch`.\n\nThe following methods were renamed:\n\n- `estimateFee` → `fetchFeeEstimate`\n- `estimateTransfer` → `fetchFeeEstimateTransfer`\n- `estimateTransaction` → `fetchFeeEstimateTransaction`\n- `getAbi` → `fetchAbi`\n- `getNonce` → `fetchNonce`\n- `getContractMapEntry` → `fetchContractMapEntry`\n- `callReadOnlyFunction` → `fetchCallReadOnlyFunction`\n\n`broadcastTransaction` wasn't renamed to highlight the uniqueness of the method.\nNamely, the node/API it is sent to will \"broadcast\" the transaction to the mempool and is more of an irreversible action.\n\n### Clarity Representation\n\nThe `ClarityType` enum was replaced by a more readable version.\nThe previous (wire format compatible) enum is still available as `ClarityWireType`.\nThese types are considered somewhat internal and shouldn't cause breaking changes for most use-cases.\n\nThe property holding the value of the data type is now called `value` in all cases.\nPreviously, there was a mix of `value`, `list`, `buffer` etc.\nFor `bigint` values, the type of the `value` property is a now `string`, for better serialization compatibility.\n\n```ts\n{\n  // !diff -\n  type: 1,\n  // !diff +\n  type: \"uint\",\n  // !diff -\n  value: 12n,\n  // !diff +\n  value: \"12\",\n}\n```\n\n```ts\n{\n  // !diff -\n  type: 11,\n  // !diff +\n  type: \"list\",\n  // !diff -\n  list: [ ... ],\n  // !diff +\n  value: [ ... ],\n}\n```\n\n### Post-conditions\n\nThe old `PostCondition` type was renamed to `PostConditionWire`.\nA new human-readable `PostCondition` type was introduced in its place.\n\nBelow is an example of the new `PostCondition` types.\n\n```ts\n// STX post-condition\nconst stxPostCondition: StxPostCondition = {\n  type: 'stx-postcondition',\n  address: 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B',\n  condition: 'gte',\n  amount: '100',\n};\n\n// Fungible token post-condition\nconst ftPostCondition: FungiblePostCondition = {\n  type: 'ft-postcondition',\n  address: 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B',\n  condition: 'eq',\n  amount: '100',\n  asset: 'SP3D6PV2ACBPEKYJTCMH7HEN02KP87QSP8KTEH335.my-ft-token::my-token',\n};\n\n// Non-fungible token post-condition\nconst nftPostCondition: NonFungiblePostCondition = {\n  type: 'nft-postcondition',\n  address: 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B',\n  condition: 'sent',\n  asset: 'SP3D6PV2ACBPEKYJTCMH7HEN02KP87QSP8KTEH335.my-nft::my-asset',\n  assetId: Cl.uint(602),\n};\n```\n\n### Advanced\n\n#### serialize methods\n\nExisting methods now take or return **hex-encoded strings** _instead_ of `Uint8Array`s.\n\n> If you were already converting returned bytes to hex-strings in your code, you can now skip the conversion step — hex-strings are the new default.\n\nFor easier migrating, renaming the following methods is possible to keep the previous behavior:\n\n- `StacksTransaction.serialize` → `StacksTransaction.serializeBytes`\n- `serializeCV` → `serializeCVBytes`\n- `serializeAddress` → `serializeAddressBytes`\n- `deserializeAddress` → `deserializeAddressBytes`\n- `serializeLPList` → `serializeLPListBytes`\n- `deserializeLPList` → `deserializeLPListBytes`\n- `serializeLPString` → `serializeLPStringBytes`\n- `deserializeLPString` → `deserializeLPStringBytes`\n- `serializePayload` → `serializePayloadBytes`\n- `deserializePayload` → `deserializePayloadBytes`\n- `serializePublicKey` → `serializePublicKeyBytes`\n- `deserializePublicKey` → `deserializePublicKeyBytes`\n- `serializeStacksMessage` → `serializeStacksMessageBytes`\n- `deserializeStacksMessage` → `deserializeStacksMessageBytes`\n- `serializeMemoString` → `serializeMemoStringBytes`\n- `deserializeMemoString` → `deserializeMemoStringBytes`\n- `serializeTransactionAuthField` → `serializeTransactionAuthFieldBytes`\n- `deserializeTransactionAuthField` → `deserializeTransactionAuthFieldBytes`\n- `serializeMessageSignature` → `serializeMessageSignatureBytes`\n- `deserializeMessageSignature` → `deserializeMessageSignatureBytes`\n- `serializePostCondition` → `serializePostConditionBytes`\n- `deserializePostCondition` → `deserializePostConditionBytes`\n- `serializeStacksMessage` → `serializeStacksWireBytes`\n- `deserializeStacksMessage` → `deserializeStacksWireBytes`\n\n#### Asset Helper Methods\n\nThe following interfaces and methods were renamed:\n\n- `AssetInfo` → `Asset`\n- `StacksWireType.AssetInfo` → `StacksWireType.Asset`\n- `createAssetInfo` → `createAsset`\n- `parseAssetInfoString` → `parseAssetString`\n\n#### CLI\n\n- Removed the `authenticator` method for legacy Blockstack authentication.\n\n#### Triplesec\n\nSupport for encrypting/decrypting mnemonics with `triplesec` was removed.\nThis impacts the methods: `decrypt`, `decryptMnemonic`, and `decryptLegacy`.\nMake sure to update your code to if mnemonics are stored somewhere encrypted using the legacy method.\n\n#### WireType\n\nRenamed internals to avoid confusion between \"message\" and wire-format for serialization.\nThis is only used for advanced serialization use-cases internally and should not be needed for most users.\n\n- `StacksMessage` → `StacksWire`\n- `StacksMessageType` → `StacksWireType`\n- `serializeStacksMessage` → `serializeStacksWireBytes`\n- `deserializeStacksMessage` → `deserializeStacksWireBytes`\n\nMore types were renamed to indicate use for serialization to _wire-format_:\n\n- `MessageSignature` → `MessageSignatureWire`\n- `StacksPublicKey` → `PublicKeyWire`\n- `TransactionAuthField` → `TransactionAuthFieldWire`\n- `Asset` → `AssetWire`\n- `Address` → `AddressWire`\n- `PostCondition` → `PostConditionWire`\n- `PostConditionPrincipal` → `PostConditionPrincipalWire`\n- `STXPostCondition` → `STXPostConditionWire`\n- `FungiblePostCondition` → `FungiblePostConditionWire`\n- `NonFungiblePostCondition` → `NonFungiblePostConditionWire`\n- `LengthPrefixedString` → `LengthPrefixedStringWire`\n- `CoinbasePayload` → `CoinbasePayloadWire`\n- `PoisonPayload` → `PoisonPayloadWire`\n- `SmartContractPayload` → `SmartContractPayloadWire`\n- `TokenTransferPayload` → `TokenTransferPayloadWire`\n- `VersionedSmartContractPayload` → `VersionedSmartContractPayloadWire`\n- `NakamotoCoinbasePayload` → `NakamotoCoinbasePayloadWire`\n- `TenureChangePayload` → `TenureChangePayloadWire`\n- `StandardPrincipal` → `StandardPrincipalWire`\n- `ContractPrincipal` → `ContractPrincipalWire`\n\n#### Signed BigInt\n\nThe `intToBigInt` method no longer supports two's complement signed integers and removed the `signed` boolean parameter.\nThis likely was a misunderstood and unused feature.\n\n#### Refactorings\n\n- `AddressHashMode`: The `Serialize` prefixes were removed for brevity.\n- `makeRandomPrivKey` was renamed to `randomPrivateKey` and now returns a compressed private key.\n- `generateSecretKey` was renamed to `randomSeedPhrase`.\n\n<Callout>\n**Have an idea?** Please let us know on [Discord #stacks-js](https://stacks.chat) or open an issue on [Github](https://github.com/hirosystems/stacks.js/issues/new/choose).\n</Callout>\n"
  },
  {
    "title": "Broadcast transactions",
    "description": "Create and broadcast transactions to the Stacks blockchain network using Stacks.js.",
    "slug": "/stacks/stacks.js/examples/broadcast-transactions",
    "content": "\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { ChevronRight, Code, Terminal } from 'lucide-react';\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\n\nThe process of broadcasting transactions is fundamental for interacting with blockchains, whether you're transferring tokens, deploying contracts, or executing contract functions.\n\nIn this guide, you will learn how to:\n\n1. [Install the necessary packages for building and broadcasting transactions](#setup-and-installation)\n2. [Build different types of transactions](#create-a-transaction)\n3. [Sign and broadcast those transactions to the Stacks blockchain](#broadcasting-the-transaction)\n4. [Process and handle the results](#handle-the-results)\n\n{/* <Callout title=\"Example Repo\">To see this guide in action, check out a full example [here](https://github.com/hiro-so/stacks-connect-example).</Callout> */}\n\n---\n\n## Setup and installation\n\nInstall the required packages to start building and broadcasting transactions.\n\n```package-install\n@stacks/network @stacks/transactions @stacks/connect\n```\n\n- **`@stacks/network`**: Used to interact with the Stacks blockchain network.\n- **`@stacks/transactions`**: Used to build the transactions.\n- **`@stacks/connect`**: Used to authenticate users and broadcast the transactions.\n\n## Create a transaction\n\nThere are three types of transactions:\n\n- STX transfer\n- Contract deployment\n- Contract execution\n\n<Tabs defaultValue=\"transfer\">\n  <TabsList className='flex flex-wrap md:w-max'>\n    <TabsTrigger value=\"transfer\" className='tab group'>\n      <Badge variant='outline' className='badge transition-colors hover:text-neutral-90 dark:group-hover:text-white'>STX transfer</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"deploy\" className='tab group'>\n      <Badge variant='outline' className='badge transition-colors hover:text-neutral-90 dark:group-hover:text-white'>Contract deployment</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"execute\" className='tab group'>\n      <Badge variant='outline' className='badge transition-colors hover:text-neutral-90 dark:group-hover:text-white'>Contract execution</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"transfer\">\n    To transfer STX, use the `makeSTXTokenTransfer` function provided by the `@stacks/transactions` package:\n\n    ```ts stx-transfer.ts -cn\n    import { broadcastTransaction, makeSTXTokenTransfer } from \"@stacks/transactions\";\n\n    const transaction = await makeSTXTokenTransfer({\n      recipient: \"SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159\",\n      amount: 12345n,\n      senderKey:\n        \"753b7cc01a1a2e86221266a154af739463fce51219d97e4f856cd7200c3bd2a601\",\n      network: \"devnet\",\n    });\n    ```\n\n    This builds a STX token transfer transaction. The `makeSTXTokenTransfer` function takes parameters like the `recipient` address, `amount` to transfer, and the sender's private key, ie `senderKey`.\n\n    Several parameters are available for calling `makeSTXTokenTransfer`. To learn more, check out our [transactions reference page](/stacks/stacks.js/packages/transactions).\n\n  </TabsContent>\n  <TabsContent value=\"deploy\">\n    To deploy a contract, use the `makeContractDeploy` function provided by the `@stacks/transactions` package:\n\n    ```ts contract-deploy.ts -cn\n    import { broadcastTransaction, makeContractDeploy } from '@stacks/transactions';\n\n    const transaction = await makeContractDeploy({\n      contractName: 'hello-world',\n      codeBody: `(define-public (hello)\n      (ok \"Hello, world!\"))`,\n      senderKey: '753b7cc01a1a2e86221266a154af739463fce51219d97e4f856cd7200c3bd2a601',\n      network: \"testnet\",\n    });\n    ```\n\n    This builds a contract deployment transaction. The `makeContractDeploy` function takes parameters like the `contractName`, `codeBody`, and the sender's private key, ie `senderKey`.\n\n    Several parameters are available for calling `makeContractDeploy`. To learn more, check out our [transactions reference page](/stacks/stacks.js/packages/transactions).\n\n  </TabsContent>\n  <TabsContent value=\"execute\">\n    To execute a contract function, use the `makeContractCall` function provided by the `@stacks/transactions` package:\n\n    ```ts function-call.ts -cn\n    import {\n      broadcastTransaction,\n      bufferCVFromString,\n      Cl,\n      makeContractCall,\n      Pc,\n    } from \"@stacks/transactions\";\n\n    const postCondition = Pc.principal(\"SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE\")\n      .willSendEq(1000000n)\n      .ustx();\n\n    const transaction = await makeContractCall({\n      contractAddress: \"SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X\",\n      contractName: \"contract_name\",\n      functionName: \"contract_function\",\n      functionArgs: [Cl.bufferFromAscii(\"foo\")],\n      senderKey:\n        \"b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01\",\n      validateWithAbi: true,\n      network: \"testnet\",\n      postConditions: [postCondition],\n    });\n    ```\n\n    This builds a contract function call transaction. The `makeContractCall` function takes parameters like the `contractAddress`, `contractName`, `functionName`, `functionArgs`, `senderKey`, `validateWithAbi`, `network`, `postConditions`, and `anchorMode`.\n\n    Several parameters are available for calling `makeContractCall`. To learn more, check out our [transactions reference page](/stacks/stacks.js/packages/transactions).\n\n  </TabsContent>\n</Tabs>\n\n## Broadcasting the transaction\n\nAfter building the transaction, broadcast it to the Stacks blockchain network using the `broadcastTransaction` function from the `@stacks/transactions` package.\n\n1. Pass in the transaction object you created in the previous step to the `broadcastTransaction` function.\n2. Handle the response by logging the response object.\n\n```ts -cn\nimport { broadcastTransaction } from '@stacks/transactions';\n\nconst broadcastResponse = await broadcastTransaction({ transaction });\n```\n\nThis code sends the signed transaction to the Stacks blockchain. The `broadcastTransaction` function returns a response containing the transaction ID, which can be used to track the transaction on the blockchain.\n\n## Handle the results\n\nHandle the transaction results by checking the transaction status and responding accordingly.\n\n```ts -cn\nif (broadcastResponse.success) {\n  console.log('Transaction successful with ID:', broadcastResponse.txid);\n} else {\n  console.error('Transaction failed with error:', broadcastResponse.error);\n}\n```\n\nThis checks if the transaction was successful and logs the `txid`.\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/stacks.js/guides/post-conditions\"\n    title=\"Deep dive into post-conditions\"\n    description=\"Learn how to use post-conditions to secure your smart contracts.\"\n  />\n  <Card\n    href=\"/stacks/stacks.js/packages/transactions\"\n    title=\"API References\"\n    description=\"Dive into the API references for Stacks.js.\"\n  />\n</Cards>"
  },
  {
    "title": "Deep dive into post-conditions",
    "description": "This guide explains how to use post-conditions to secure your smart contracts.",
    "slug": "/stacks/stacks.js/examples/post-conditions",
    "content": "\nimport { Badge } from '@/components/ui/badge';\n\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { ChevronRight, Code, Terminal } from 'lucide-react';\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\n\nPost-conditions in Stacks transactions provide an additional layer of security. They ensure that transactions execute as expected without requiring the user to know the underlying smart contract code.\n\nIn this guide, you will learn how to:\n\n1. [Construct post-conditions](#constructing-post-conditions).\n2. [Use post-conditions](#using-post-conditions).\n3. [Set the post-condition mode](#setting-the-post-condition-mode).\n4. [Usage examples](#usage-examples).\n\n---\n\n## Constructing post-conditions\n\nIn Stacks.js, post-conditions can be constructed using the Pc helpers. These are inspired by Behavior Driven Development (BDD).\n\nStart with the `Pc.principal` initializer to specify the address of the principal that will be verified in the post-condition. Then auto-complete the rest of the post-condition.\n\n## Using post-conditions\n\nPost-conditions can be added to contract calls and FT/NFT transfers to ensure assets are transferred as specified.\n\nFor instance, the following post-condition ensures that the principal initiating the transaction must send exactly 1000 uSTX, or else the transaction will abort.\n\n```ts -cn\nimport { Pc } from '@stacks/transactions';\n\nconst postCondition = Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')\n  .willSendEq(1000)\n  .ustx();\n```\n\n<Accordions>\n  <Accordion title=\"All transfer methods\">\n    STX/FT\n\n    `.willSendEq(amount: number)` ensures that the amount to be sent is **exactly** the specified value.\n    \n    `.willSendGte(amount: number)` ensures that the amount to be sent is **greater than or equal** to the specified value.\n    \n    `.willSendGt(amount: number)` ensures that the amount to be sent is **greater than** the specified value.\n    \n    `.willSendLte(amount: number)` ensures that the amount to be sent is **less than or equal** to the specified value.\n    \n    `.willSendLt(amount: number)` ensures that the amount to be sent is **less than** the specified value.\n\n    `.ustx()` to specify uSTX as the FT asset _(ends the builder)_\n\n    `.ft(contract: string, tokenName: string)` to specify a specific FT asset _(ends the builder)_\n\n    ---\n    \n    NFT\n\n    `.willSendAsset()` ensures that an asset should **be sent**.\n    \n    `.willNotSendAsset()` to specify an asset should **not be sent**\n  </Accordion>\n</Accordions>\n\n## Setting the post-condition mode\n\nWhen creating a transaction, the mode of the transaction can be set to `Allow` or `Deny` to specify whether unspecified asset transfers are permitted.\n\n```ts -n\nimport { PostConditionMode } from '@stacks/transactions';\n\nconst tx = await makeContractCall({\n  // ...\n  postConditionMode: PostConditionMode.Allow,\n  // OR\n  postConditionMode: PostConditionMode.Deny,\n  // ...\n});\n```\n\nEssentially, the `postConditionMode` is what tells the Stacks node whether to require (`Deny`) or ignore (`Allow`) the post-conditions when evaluating the transaction.\n\n## Usage examples\n\n### Amount uSTX sent\n\nConstruct a post-condition for a certain amount of uSTX to be sent.\n\n```ts -cn\nimport { Pc } from '@stacks/transactions';\n\nconst postCondition = Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')\n  .willSendEq(1000)\n  .ustx();\n```\n\n### Amount FT sent\n\nConstruct a post-condition for a certain amount of a specific FT to be sent.\n\n```ts -cn\nimport { Pc } from '@stacks/transactions';\n\nconst postCondition = Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.token-ft')\n  .willSendGte(500)\n  .ft('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.token-ft', 'token');\n```\n\n### Amount NFT sent / not sent\n\nConstruct a post-condition for sending / not-sending a specific NFT.\n\n```ts -cn\nimport { Pc } from '@stacks/transactions';\n\nconst postCondition = Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')\n  .willNotSendAsset()\n  .nft('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6.token-nft::token', Cl.uint(12));\n```\n\n### Amount SFT sent / not sent\n\nConstruct a post-condition for sending / not-sending a specific SFT (Semi-fungible token).\n\n```ts -cn\nimport { Cl, Pc } from '@stacks/transactions';\n\nconst postConditionForNFT = Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')\n.willSendAsset()\n.nft(\n  \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.semi-fungible-token::semi-fungible-token-id\",\n  Cl.tuple({ \"token-id\": Cl.uint(1), owner: Cl.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6') })\n);\n\nconst postConditionForFT = Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6')\n.willSendEq(500)\n.ft(\"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.semi-fungible-token\", \"semi-fungible-token\");\n```\n\n<Callout title=\"Note\">\nThe previous builders (`makeStandardSTXPostCondition`, `makeStandardFungiblePostCondition`, etc) were removed in `v7.0.0`.\n</Callout>\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/stacks.js/guides/broadcast-transactions\"\n    title=\"Broadcast transactions\"\n    description=\"Learn how to broadcast transactions with Stacks.js.\"\n  />\n  <Card\n    href=\"/stacks/stacks.js/packages/transactions\"\n    title=\"API References\"\n    description=\"Dive deeper into the API references for the Stacks.js transactions package.\"\n  />\n</Cards>"
  },
  {
    "title": "Using Stacks.js with React Native",
    "description": "Learn how to use Stacks.js with React Native.",
    "slug": "/stacks/stacks.js/examples/use-with-react-native",
    "content": "\nimport { Badge } from '@/components/ui/badge';\n\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { ChevronRight, Code, Terminal } from 'lucide-react';\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\n\nUsing Stacks.js with React Native allows you to integrate Stacks blockchain functionalities into mobile applications.\n\nIn this guide, you will learn how to:\n\n1. [Set up the Expo project](#set-up-the-expo-project).\n2. [Install necessary dependencies](#install-necessary-dependencies).\n3. [Add NodeJS polyfills](#add-nodejs-polyfills).\n4. [Add global polyfills](#add-global-polyfills).\n5. [Use Stacks.js in the project](#use-stacksjs-in-the-project).\n\n{/* <Callout>To see this guide in action, check out a full example [here](https://github.com/hirosystems/stacks.js-react-native-expo-51).</Callout> */}\n\n---\n\n## Set up the Expo project\n\nStart by creating a new Expo project using `create-expo-app`.\n\n```terminal\n$ npx create-expo-app@latest\n```\n\nThis will generate a boilerplate Expo project. You can run the project with `npm start` and connect a mobile device for previewing via the shown QR code.\n\n## Install necessary dependencies\n\nInstall Stacks.js libraries along with other dependencies needed for polyfilling browser-specific and NodeJS-specific APIs.\n\n```terminal\n$ npm install @stacks/transactions @stacks/wallet-sdk\n$ npm install --save-dev buffer process react-native-get-random-values text-encoding readable-stream crypto-browserify @peculiar/webcrypto\n```\n\n## Add NodeJS polyfills\n\nModify the project's Metro configuration to include polyfills for missing NodeJS modules.\n\n```terminal\n$ npx expo customize metro.config.js\n```\n\n```js metro.config.js -cn\nconst { getDefaultConfig } = require(\"expo/metro-config\");\n\nconst config = getDefaultConfig(__dirname);\n\nconfig.resolver.extraNodeModules = {\n  stream: require.resolve(\"readable-stream\"),\n  crypto: require.resolve(\"crypto-browserify\"),\n};\n\nmodule.exports = config;\n```\n\n## Add global polyfills\n\nUpdate the Expo entry point to include polyfills.\n\n1. Create `polyfill.js` file\n2. Create `index.js` file\n3. Update the `package.json`\n\n```js polyfill.js -cn\nimport { Buffer } from \"buffer/\";\nimport process from \"process\";\nimport \"react-native-get-random-values\";\nimport { TextDecoder, TextEncoder } from \"text-encoding\";\n\nglobal.process = process;\nglobal.Buffer = Buffer;\nglobal.TextEncoder = TextEncoder;\nglobal.TextDecoder = TextDecoder;\n```\n\n```js index.js -cn\nimport \"./polyfill\";\nimport { Crypto } from \"@peculiar/webcrypto\";\n\nObject.assign(global.crypto, new Crypto());\n\nimport \"expo-router/entry\";\n```\n\n```json package.json\n\"main\": \"index.js\",\n```\n\n<Callout>\nEnsure that the polyfills live in their own file as specified to avoid any runtime issues.\n</Callout>\n\n## Use Stacks.js in the project\n\nEdit the `app/(tabs)/index.tsx` file to integrate Stacks.js functionalities, starting with the imports.\n\n```tsx app/(tabs)/index.tsx -cn\nimport {\n  TransactionVersion,\n  getAddressFromPrivateKey,\n  makeSTXTokenTransfer,\n} from \"@stacks/transactions\";\nimport { Wallet, generateSecretKey, generateWallet } from \"@stacks/wallet-sdk\";\nimport { useState } from \"react\";\n```\n\nNow you can start to manage the state as follows:\n\n```tsx app/(tabs)/index.tsx -cn\nexport default function HomeScreen() {\n  const [mnemonic, setMnemonic] = useState(\"...\");\n  const [wallet, setWallet] = useState<Wallet | null>(null);\n  const [log, setLog] = useState(\"\");\n}\n```\n\nNext, to generate a wallet and sign a transaction:\n\n```tsx app/(tabs)/index.tsx -cn\nconst generate = async () => {\n  const mnemonic = generateSecretKey();\n  setMnemonic(mnemonic);\n\n  const wallet = await generateWallet({\n    secretKey: mnemonic,\n    password: \"\",\n  });\n  setWallet(wallet);\n\n  await makeSTXTokenTransfer({\n    amount: 1000,\n    anchorMode: \"any\",\n    recipient: \"SP3W993D3BRDYB284CY3SBFDEGTC5XEDJPDEA21CN\",\n    senderKey: wallet.accounts[0].stxPrivateKey,\n    fee: 10,\n    network: \"mainnet\",\n    nonce: 0,\n  });\n  setLog(\"Transaction signed successfully ☑\");\n};\n```\n\nAnd lastly, to integrate the UI:\n\n```tsx app/(tabs)/index.tsx -cn\n<ThemedView>\n  <ThemedText type=\"subtitle\">Seed Phrase</ThemedText>\n  <ThemedText>{mnemonic}</ThemedText>\n  <Button title=\"Generate Seed Phrase\" onPress={generate} />\n  {wallet && (\n    <>\n      <ThemedText type=\"subtitle\">Address</ThemedText>\n      <ThemedText>\n        {getAddressFromPrivateKey(\n          wallet.accounts[0].stxPrivateKey,\n          TransactionVersion.Mainnet\n        )}\n      </ThemedText>\n    </>\n  )}\n  {log && <ThemedText>{log}</ThemedText>}\n</ThemedView>\n```\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/stacks.js/packages/transactions\"\n    title=\"API References\"\n    description=\"Dive into the API references for Stacks.js.\"\n  />\n</Cards>"
  },
  {
    "title": "sbtc",
    "description": "A JS/TS helper package for interacting with sBTC.",
    "slug": "/stacks/stacks.js/packages/sbtc",
    "content": "\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\nimport { Callout } from \"@/components/callout\";\n\n\n## Installation\n\n```package-install\nsbtc\n```\n\n## Architecture\n\nThe sBTC protocol operates across multiple layers:\n\n- **Bitcoin**: The original funds are sourced from Bitcoin. A depositor sends these funds to a group of signers, which manage a (rotating) multisignature address formatted for sBTC transactions.\n\n- **sBTC API (Emily)**: This API is responsible for tracking deposits and notifying the signers about pending deposits.\n\n- **Stacks**: The network where sBTC is minted. Once the deposit is confirmed, the signers mint the corresponding amount of sBTC to the depositor's specified address on the Stacks network.\n\n## Deposit Flow\n\n- **Create Deposit (Bitcoin) Transaction**:\n  - Structure a Bitcoin transaction to send funds to the group of signers.\n  - Use a specialized format that includes:\n    - Deposit Script: Identifies which Stacks address the sBTC will be minted to and what the maximum fee (in satoshis) the signers may take in exchange for minting.\n    - Reclaim Script: Allows the sender to reclaim their funds if the transaction is not processed by the signers.\n\n- **Sign and Broadcast the Transaction**:\n  - Sign the transaction with the sender's private key.\n  - Broadcast the transaction to the Bitcoin network (Bitcoin Regtest for Stacks Testnet).\n\n- **Notify the sBTC API (Emily)**:\n  - Inform the API about the transaction by submitting its details. This step ensures that the signers are aware of the deposit and can track it.\n\n- **Processing by Signers**: (no action required)\n  - The signers retrieve and verify the deposit transaction from the Bitcoin blockchain.\n  - Once verified, the signers mint the equivalent amount of sBTC on the Stacks network.\n\n- **Receive sBTC (Stacks)**: (no action required)\n  - The minted sBTC is sent to the depositor's designated Stacks address, completing the deposit process.\n  - sBTC is SIP-010 compatible and will show up in Stacks wallets and explorers.\n\n## Withdrawal Flow\n_Coming soon_\n\n## sBTC Package Functions\n\nThe sBTC package exports high-level functions for building addresses and transactions for deposits.\n\n### Examples\n\n  \n#### buildSbtcDepositAddress\nBuild a deposit address and metadata using `buildSbtcDepositAddress` with a wallet provider using `sendTransfer`.\n\n```ts\nimport { buildSbtcDepositAddress, SbtcApiClientTestnet } from 'sbtc';\n\nconst client = new SbtcApiClientTestnet();\n\n// 1. BUILD THE DEPOSIT ADDRESS AND METADATA\nconst deposit = buildSbtcDepositAddress({\n  stacksAddress: TARGET_STX_ADDRESS,\n  signersPublicKey: await client.fetchSignersPublicKey(),\n\n  // OPTIONAL DEFAULTS\n  // maxSignerFee: 80_000, // optional: fee to pay for the deposit transaction (taken from the signers from the sats)\n  // reclaimLockTime: 6_000, // optional: lock time for the reclaim script\n  // network: REGTEST, // optional: which bitcoin network to use\n});\n\n// `deposit.address` is the deposit address (send funds here, aka the deposit address as an output)\n\n// 2. DEPOSIT USING YOUR FAVORITE WALLET (TYPICALLY ALSO BROADCASTED BY THE WALLET)\nconst txid = await WalletProvider.sendTransfer({\n  recipient: deposit.address,\n  amount: 100_000, // the amount to deposit; <=maxSignerFee is taken from this amount\n});\n\n// 3. NOTIFY THE SIGNERS\nawait client.notifySbtc({ txid, ...deposit });\n```\n\n#### buildSbtcDepositTx\nThe `buildSbtcDepositTx` function is similar to `buildSbtcDepositAddress`, but instead of returning just a deposit address, it constructs a complete Bitcoin transaction for depositing sBTC.\n\n```ts\nimport { buildSbtcDepositTx } from 'sbtc';\n\n// 1. BUILD THE DEPOSIT TRANSACTION AND METADATA\nconst deposit = buildSbtcDepositTx({\n  amountSats: DEPOSIT_AMOUNT, // the amount in sats/sBTC to deposit; <=maxSignerFee is taken from this amount\n\n  // same options as `buildSbtcDepositAddress`\n  network,\n  stacksAddress,\n  signersPublicKey,\n  maxSignerFee,\n  reclaimLockTime,\n});\n\n// `deposit.transaction` has one output, which is the combined taproot of the deposit and reclaim scripts\n\n// 2. SIGN THE TRANSACTION\ndeposit.transaction.sign(YOUR_BTC_PRIVATE_KEY);\ndeposit.transaction.finalize();\n\n// 2. OR SIGN VIA EXTERNAL WALLET\nconst psbtBytes = deposit.transaction.toPSBT();\n\n// 3. BROADCAST THE TRANSACTION\nconst txid = await client.broadcastTx(deposit.transaction);\n\n// 4. NOTIFY THE SIGNERS\nawait client.notifySbtc(deposit);\n```\n\n\n#### sbtcDepositHelper\nCreate a fully-formed deposit transaction (assuming an address with spendable bitcoin UTXOs)\n\n<Callout>Use this helper function if you are not using a wallet provider</Callout>\n\n```ts\nimport { sbtcDepositHelper, SbtcApiClientTestnet } from 'sbtc';\n\nconst client = new SbtcApiClientTestnet();\n\n// 1. BUILD THE DEPOSIT TRANSACTION AND METADATA (GIVEN UTXOS FOR AN ADDRESS)\nconst deposit = await sbtcDepositHelper({\n  stacksAddress: TARGET_STX_ADDRESS, // where to send/mint the sBTC\n  amountSats: 5_000_000, // (maximum) amount of sBTC to deposit\n\n  signersPublicKey: pub, // the aggregated public key of the signers\n\n  feeRate: await client.fetchFeeRate('medium'),\n  utxos: await client.fetchUtxos(YOUR_BTC_ADDRESS),\n\n  bitcoinChangeAddress: YOUR_BTC_ADDRESS,\n});\n\n// 2. SIGN THE TRANSACTION\ndeposit.transaction.sign(YOUR_BTC_PRIVATE_KEY);\ndeposit.transaction.finalize();\n\n// 2. OR SIGN VIA EXTERNAL WALLET\nconst psbtBytes = deposit.transaction.toPSBT();\n\n// 3. BROADCAST TRANSACTION\nconst txid = await client.broadcastTx(deposit.transaction);\nconsole.log('txid', txid);\n\n// 4. NOTIFY THE SIGNERS\nconst res = await client.notifySbtc(deposit);\nconsole.log('res', res.status, res.statusMessage);\n```\n\n\n## HTTP Clients\n\nAdditionally, there are two API helpers, which make it easier to get all the data needed to create the above transactions:\n\n- **SbtcApiClientMainnet** — a client for communicating with the different pieces of the sBTC deployment\n- **SbtcApiClientTestnet** — a client for communicating with the different pieces of the sBTC deployment on Testnet\n- **SbtcApiClientDevenv** — a client for developing against a local deployment of sBTC\n\nWhile the final adjustments are still being made in the pre-release phase, this package may change default URLs and contract addresses on every minor release.\n\n| Version | Purpose | Functionality |\n| --- | --- | --- |\n| 0.1.x | Developer release (hackathon) | |\n| 0.2.x | Regtest/Testnet release | Deposit only |\n| 0.3.x | Mainnet pre-release | Deposit only |\n\n### Examples\n\n```ts\nimport { SbtcApiClientMainnet, SbtcApiClientTestnet, SbtcApiClientDevenv } from 'sbtc';\n\nconst client = new SbtcApiClientMainnet();\n// const client = new SbtcApiClientTestnet();\n// const client = new SbtcApiClientDevenv();\n\nconst pub = await client.fetchSignersPublicKey(); // fetches the aggregated public key of the signers\nconst address = await client.fetchSignersAddress(); // fetches the p2tr address of the aggregated public key of the signers\n\nconst feeRate = await client.fetchFeeRate('low'); // or 'medium', 'high'\nconst unspents = await client.fetchUtxos(BTC_ADDRESS);\nconst hex = await client.fetchTxHex(TXID);\n\nawait client.broadcastTx(DEPOSIT_BTC_TX); // broadcast a deposit BTC transaction\nawait client.notifySbtc(DEPOSIT_BTC_TX); // notify the sBTC API about the deposit (otherwise it won't be processed)\n\nconst sbtcBalance = await client.fetchSbtcBalance(STX_ADDRESS); // fetch the sBTC balance of an Stacks address\n```\n\n## API Reference\n\n### sbtcDepositHelper\n\n| Parameter | Description | Type | Default |\n| --- | --- | --- | --- |\n| signersPublicKey | Signers public key (aggregated schnorr) | string 32 byte hex | — |\n| amountSats | Bitcoin amount denominated in sats (* 10^8) | number, bigint | — |\n| stacksAddress | The deposit recipient Stacks address | string | — |\n| bitcoinChangeAddress | Bitcoin change address | string | — |\n| feeRate | Fee rate in sat/vbyte | number | — |\n| utxos | UTXOs to \"fund\" the transaction | UtxoWithTx[] | — |\n| reclaimPublicKey | Public key (schnorr, x-only) for reclaiming failed deposits | string | — |\n| reclaimLockTime | Optional reclaim lock time | number | 144 |\n| maxSignerFee | Optional maximum fee to pay to signers for the sBTC mint | number | 80_000 |\n| network | Optional Bitcoin network | BitcoinNetwork | MAINNET |\n| utxoToSpendable | Optional function to convert p2wpk and p2sh utxos to spendable inputs | Function | Best effort default implementation to make utxos spendable |\n| paymentPublicKey | Optional payment public key (currently only used for default utxoToSpendable.sh implementation) | string hex | — |\n\n### SbtcApiClient Configuration\n\n| Parameter | Description | Type |\n| --- | --- | --- |\n| sbtcContract | The multisig address of the initial sBTC contract | string |\n| sbtcApiUrl | The base URL of the sBTC API (Emily) | string |\n| btcApiUrl | The base URL of the Bitcoin mempool/electrs API | string |\n| stxApiUrl | The base URL of the Stacks API | string |\n"
  },
  {
    "title": "@stacks/transactions",
    "description": "Construct, decode transactions and work with Clarity smart contracts on the Stacks blockchain.",
    "slug": "/stacks/stacks.js/packages/transactions",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\n\n<Callout type=\"info\">\nThis reference refers to the `7.x.x` release of Stacks.js—it's the recommended version to use, but not needed for the Stacks Nakamoto release.\nRead the [migration guide](https://github.com/hirosystems/stacks.js/blob/main/.github/MIGRATION.md#stacksjs-5xx--7xx) to learn how to update to the latest version.\n</Callout>\n\n## Installation\n\n```package-install\n@stacks/transactions\n```\n\nThis library supports the creation of the following Stacks transaction types:\n\n1. STX token transfer\n2. Smart contract deploy\n3. Smart contract function call\n\n## Key Generation\n\n```typescript -n\nimport { randomPrivateKey, privateKeyToPublicKey } from '@stacks/transactions';\n\n// Random key\nconst privateKey = randomPrivateKey();\nconst publicKey = privateKeyToPublicKey(privateKey);\n\n// Private key from hex string\nconst privateKey = 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01';\n```\n\n## STX Token Transfer Transaction\n\nUse the [`makeSTXTokenTransfer`](https://stacks.js.org/functions/_stacks_transactions.makeSTXTokenTransfer) (with a sender private key), or the \"unsigned\" version [`makeUnsignedSTXTokenTransfer`](https://stacks.js.org/functions/_stacks_transactions.makeUnsignedSTXTokenTransfer) (with a sender public key, without yet signing) to create a STX token transfer transaction.\n\n```ts -n\nimport { makeSTXTokenTransfer, broadcastTransaction } from '@stacks/transactions';\n\nconst txOptions = {\n  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',\n  amount: 12345n,\n  memo: 'test memo',\n\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  network: 'testnet', // for mainnet, use 'mainnet'\n};\n\nconst transaction = await makeSTXTokenTransfer(txOptions);\n\n// to see the raw serialized tx\nconst serializedTx = transaction.serialize(); // hex string\n\n// broadcast to the network\nconst response = await broadcastTransaction({ transaction, network: 'testnet' });\nconsole.log(response.txid);\n```\n\n## Smart Contract Deploy Transaction\n\nUse the [`makeContractDeploy`](https://stacks.js.org/functions/_stacks_transactions.makeContractDeploy), or the \"unsigned\" version [`makeUnsignedContractDeploy`](https://stacks.js.org/functions/_stacks_transactions.makeUnsignedContractDeploy) to create a smart contract deploy transaction.\n\n```ts -n\nimport { makeContractDeploy, broadcastTransaction } from '@stacks/transactions';\nimport { readFileSync } from 'fs';\n\nconst clarityCode = readFileSync('/path/to/contract.clar').toString();\n\nconst txOptions = {\n  contractName: 'contract_name',\n  codeBody: clarityCode,\n  clarityVersion: 3, // optional, defaults to latest deployed version\n\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  network: 'testnet', // for mainnet, use 'mainnet'\n};\n\nconst transaction = await makeContractDeploy(txOptions);\n\n// broadcast to the network\nconst response = await broadcastTransaction({ transaction, network: 'testnet' });\nconsole.log(response.txid);\n```\n\n## Smart Contract Function Call (On-chain)\n\nIf you want to call a readonly function, use [`fetchCallReadOnlyFunction`](https://stacks.js.org/functions/_stacks_transactions.fetchCallReadOnlyFunction) instead.\n\nUse the [`makeContractCall`](https://stacks.js.org/functions/_stacks_transactions.makeContractCall) or the \"unsigned\" version [`makeUnsignedContractCall`](https://stacks.js.org/functions/_stacks_transactions.makeUnsignedContractCall) to create a smart contract function call transaction.\n\n```ts -n\nimport { makeContractCall, broadcastTransaction, Cl, Pc } from '@stacks/transactions';\n\n// Add an optional post condition\nconst condition01 = Pc.principal('SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE')\n  .willSendGte(1000000n)\n  .ustx();\n\nconst txOptions = {\n  contractAddress: 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X',\n  contractName: 'contract_name',\n  functionName: 'contract_function',\n  functionArgs: [Cl.bufferFromUtf8('foo string')],\n  postConditions: [condition01],\n\n  validateWithAbi: true, // check if the arguments given are compatible with the function\n\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  network: 'testnet', // for mainnet, use 'mainnet'\n};\n\nconst transaction = await makeContractCall(txOptions);\n\n// broadcast to the network\nconst response = await broadcastTransaction({ transaction, network: 'testnet' });\nconsole.log(response.txid);\n```\n\nIn this example we construct a `contract-call` transaction with a post condition. We have set the `validateWithAbi` option to `true`, so the `makeContractCall` builder will attempt to fetch this contracts ABI from the specified Stacks network, and validate that the provided functionArgs match what is described in the ABI. This should help you avoid constructing invalid contract-call transactions. If you would prefer to provide your own ABI instead of fetching it from the network, the `validateWithAbi` option also accepts [ClarityABI](https://stacks.js.org/interfaces/_stacks_transactions.ClarityAbi) objects.\n\n## Sponsoring Transactions\n\nTo generate a sponsored transaction, first create and sign the transaction as the origin. The `sponsored` property in the options object must be set to true.\n\n```ts -n\nimport { makeContractCall, Cl } from '@stacks/transactions';\n\nconst txOptions = {\n  contractAddress: 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X',\n  contractName: 'contract_name',\n  functionName: 'contract_function',\n  functionArgs: [Cl.bufferFromUtf8('foo string')],\n  validateWithAbi: true,\n\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  network: 'testnet', // for mainnet, use 'mainnet'\n  sponsored: true,\n};\n\nconst transaction = await makeContractCall(txOptions);\nconst serializedTx = transaction.serialize();\n\n// can't broadcast sponsored transactions before they are sponsored\n```\n\nThe serialized transaction can now be passed to the sponsoring party which will sign the sponsor portion of the transaction and set the fee.\n\n```ts -n\nimport { sponsorTransaction, broadcastTransaction } from '@stacks/transactions';\n\nconst deserializedTx = deserializeTransaction(serializedTx);\nconst sponsorKey = '770287b9471081c8acd37d57190c7a70f0da2633311cc120853537362d32e67c01';\nconst fee = 1000n;\n\nconst sponsorOptions = {\n  transaction: deserializedTx,\n  sponsorPrivateKey: sponsorKey,\n  sponsorNonce: 0,\n  fee,\n};\n\nconst sponsoredTx = await sponsorTransaction(sponsorOptions);\n\n// broadcast to the network\nconst response = await broadcastTransaction({ transaction: sponsoredTx, network: 'testnet' });\nconsole.log(response.txid);\n```\n\n## Supporting multi-signature transactions\n\nTo generate a multi-sig transaction, first create an unsigned transaction.\nThe `numSignatures` and `publicKeys` properties in the options object must be set:\n\n```ts -n\nimport {\n  makeUnsignedSTXTokenTransfer,\n  createStacksPrivateKey,\n  deserializeTransaction,\n  pubKeyfromPrivKey,\n  publicKeyToString,\n  TransactionSigner,\n  standardPrincipalCV,\n  BytesReader,\n  AnchorMode,\n} from '@stacks/transactions';\n\nconst recipient = standardPrincipalCV('SP3FGQ8...');\nconst amount = 2500000n;\nconst fee = 0n;\nconst memo = 'test memo';\n\n// private keys of the participants in the transaction\nconst privKeyStrings = ['6d430bb9...', '2a584d89...', 'd5200dee...'];\n\n// create private key objects from string array\nconst privKeys = privKeyStrings.map(createStacksPrivateKey);\n\n// corresponding public keys\nconst pubKeys = privKeyStrings.map(pubKeyfromPrivKey);\n\n// create public key string array from objects\nconst pubKeyStrings = pubKeys.map(publicKeyToString);\n\nconst transaction = await makeUnsignedSTXTokenTransfer({\n  recipient,\n  amount,\n  fee,\n  memo,\n  numSignatures: 2, // number of signature required\n  publicKeys: pubKeyStrings, // public key string array with >= numSignatures elements\n  anchorMode: AnchorMode.Any,\n});\n\nconst serializedTx = transaction.serialize();\n```\n\nThis transaction payload can be passed along to other participants to sign. In addition to\nmeeting the numSignatures requirement, the public keys of the parties who did not sign the\ntransaction must be appended to the signature.\n\n```ts -n\n// deserialize and sign transaction\nconst bytesReader = new BytesReader(serializedTx);\n// Partially signed or unsigned multi-sig tx can be deserialized to add the required signatures\nconst deserializedTx = deserializeTransaction(bytesReader);\n\nconst signer = new TransactionSigner(deserializedTx);\n\n// first signature\nsigner.signOrigin(privKeys[0]);\n\n// second signature\nsigner.signOrigin(privKeys[1]);\n\n// after meeting the numSignatures requirement, the public\n// keys of the participants who did not sign must be appended\nsigner.appendOrigin(pubKeys[2]);\n\n// the serialized multi-sig tx\nconst serializedSignedTx = deserializedTx.serialize();\n```\n\n## Calling Read-only Contract Functions\n\nRead-only contract functions can be called without generating or broadcasting a transaction. Instead it works via a direct API call to a Stacks node.\n\n```ts -n\nimport { bufferCVFromString, callReadOnlyFunction } from '@stacks/transactions';\nimport { StacksTestnet } from '@stacks/network';\n\nconst contractAddress = 'ST3KC0MTNW34S1ZXD36JYKFD3JJMWA01M55DSJ4JE';\nconst contractName = 'kv-store';\nconst functionName = 'get-value';\nconst buffer = bufferCVFromString('foo');\nconst network = new StacksTestnet();\nconst senderAddress = 'ST2F4BK4GZH6YFBNHYDDGN4T1RKBA7DA1BJZPJEJJ';\n\nconst options = {\n  contractAddress,\n  contractName,\n  functionName,\n  functionArgs: [buffer],\n  network,\n  senderAddress,\n};\n\nconst result = await callReadOnlyFunction(options);\n```\n\n## Constructing Clarity Values\n\nBuilding transactions that call functions in deployed clarity contracts requires you to construct valid Clarity Values to pass to the function as arguments. The [Clarity type system](https://github.com/stacksgov/sips/blob/master/sip/sip-002-smart-contract-language.md#clarity-type-system) contains the following types:\n\n- `(tuple (key-name-0 key-type-0) (key-name-1 key-type-1) ...)` : a typed tuple with named fields.\n- `(list max-len entry-type)` : a list of maximum length max-len, with entries of type entry-type\n- `(response ok-type err-type)` : object used by public functions to commit their changes or abort. May be returned or used by other functions as well, however, only public functions have the commit/abort behavior.\n- `(optional some-type)` : an option type for objects that can either be (some value) or none\n- `(buff max-len)` : byte buffer or maximum length max-len.\n- `principal` : object representing a principal (whether a contract principal or standard principal).\n- `bool` : boolean value (`true` or `false`)\n- `int` : signed 128-bit integer\n- `uint`: unsigned 128-bit integer\n\nThis library contains Typescript types and classes that map to the Clarity types, in order to make it easy to construct well-typed Clarity values in Javascript. These types all extend the abstract class `ClarityValue`.\n\n```ts -n\nimport {\n  trueCV,\n  falseCV,\n  noneCV,\n  someCV,\n  intCV,\n  uintCV,\n  standardPrincipalCV,\n  contractPrincipalCV,\n  responseErrorCV,\n  responseOkCV,\n  listCV,\n  tupleCV,\n  bufferCV,\n} from '@stacks/transactions';\nimport { utf8ToBytes } from '@stacks/common';\n\n// construct boolean clarity values\nconst t = trueCV();\nconst f = falseCV();\n\n// construct optional clarity values\nconst nothing = noneCV();\nconst something = someCV(t);\n\n// construct a buffer clarity value from an existing byte array\nconst bytes = utf8ToBytes('foo'); // Uint8Array(3) [ 102, 111, 111 ]\nconst bufCV = bufferCV(bytes);\n\n// construct signed and unsigned integer clarity values\nconst i = intCV(-10);\nconst u = uintCV(10);\n\n// construct principal clarity values\nconst address = 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B';\nconst contractName = 'contract-name';\nconst spCV = standardPrincipalCV(address);\nconst cpCV = contractPrincipalCV(address, contractName);\n\n// construct response clarity values\nconst errCV = responseErrorCV(trueCV());\nconst okCV = responseOkCV(falseCV());\n\n// construct tuple clarity values\nconst tupCV = tupleCV({\n  a: intCV(1),\n  b: trueCV(),\n  c: falseCV(),\n});\n\n// construct list clarity values\nconst l = listCV([trueCV(), falseCV()]);\n```\n\nIf you develop in Typescript, the type checker can help prevent you from creating wrongly-typed Clarity values. For example, the following code won't compile since in Clarity lists are homogeneous, meaning they can only contain values of a single type. It is important to include the type variable `BooleanCV` in this example, otherwise the typescript type checker won't know which type the list is of and won't enforce homogeneity.\n\n```ts -n\nconst l = listCV<BooleanCV>([trueCV(), intCV(1)]);\n```\n\n## Post Conditions\n\nThree types of post conditions can be added to transactions:\n\n1. STX post condition\n2. Fungible token post condition\n3. Non-Fungible token post condition\n\nFor details see: https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-post-conditions\n\n## STX post condition\n\n```ts -n\nimport {\n  FungibleConditionCode,\n  makeStandardSTXPostCondition,\n  makeContractSTXPostCondition,\n} from '@stacks/transactions';\n\n// With a standard principal\nconst postConditionAddress = 'SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE';\nconst postConditionCode = FungibleConditionCode.GreaterEqual;\nconst postConditionAmount = 12345n;\n\nconst standardSTXPostCondition = makeStandardSTXPostCondition(\n  postConditionAddress,\n  postConditionCode,\n  postConditionAmount\n);\n\n// With a contract principal\nconst contractAddress = 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X';\nconst contractName = 'test-contract';\n\nconst contractSTXPostCondition = makeContractSTXPostCondition(\n  contractAddress,\n  contractName,\n  postConditionCode,\n  postConditionAmount\n);\n```\n\n## Fungible token post condition\n\n```ts -n\nimport {\n  FungibleConditionCode,\n  createAssetInfo,\n  makeStandardFungiblePostCondition,\n} from '@stacks/transactions';\n\n// With a standard principal\nconst postConditionAddress = 'SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE';\nconst postConditionCode = FungibleConditionCode.GreaterEqual;\nconst postConditionAmount = 12345n;\nconst assetAddress = 'SP62M8MEFH32WGSB7XSF9WJZD7TQB48VQB5ANWSJ';\nconst assetContractName = 'test-asset-contract';\nconst assetName = 'test-token';\nconst fungibleAssetInfo = createAssetInfo(assetAddress, assetContractName, assetName);\n\nconst standardFungiblePostCondition = makeStandardFungiblePostCondition(\n  postConditionAddress,\n  postConditionCode,\n  postConditionAmount,\n  fungibleAssetInfo\n);\n\n// With a contract principal\nconst contractAddress = 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X';\nconst contractName = 'test-contract';\nconst assetAddress = 'SP62M8MEFH32WGSB7XSF9WJZD7TQB48VQB5ANWSJ';\nconst assetContractName = 'test-asset-contract';\nconst assetName = 'test-token';\nconst fungibleAssetInfo = createAssetInfo(assetAddress, assetContractName, assetName);\n\nconst contractFungiblePostCondition = makeContractFungiblePostCondition(\n  contractAddress,\n  contractName,\n  postConditionCode,\n  postConditionAmount,\n  fungibleAssetInfo\n);\n```\n\n## Non-fungible token post condition\n\n> **Warning**\n> The Stacks blockchain's post-condition processor can NOT check ownership.\n> It checks whether or not a principal **will send** or **will not send** an NFT.\n> Post-conditions can NOT verify anything about the recipient of an asset.\n> If you want to verify conditions about asset recipients, you will need to use [Clarity](https://docs.stacks.co/docs/write-smart-contracts/).\n\n```ts -n\nimport {\n  NonFungibleConditionCode,\n  createAssetInfo,\n  makeStandardNonFungiblePostCondition,\n  makeContractNonFungiblePostCondition,\n  bufferCVFromString,\n} from '@stacks/transactions';\n\n// With a standard principal\nconst postConditionAddress = 'SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE';\nconst postConditionCode = NonFungibleConditionCode.DoesNotSend;\nconst assetAddress = 'SP62M8MEFH32WGSB7XSF9WJZD7TQB48VQB5ANWSJ';\nconst assetContractName = 'test-asset-contract';\nconst assetName = 'test-asset';\nconst assetId = bufferCVFromString('test-token-asset-id');\nconst nonFungibleAssetInfo = createAssetInfo(assetAddress, assetContractName, assetName);\n\nconst standardNonFungiblePostCondition = makeStandardNonFungiblePostCondition(\n  postConditionAddress,\n  postConditionCode,\n  nonFungibleAssetInfo,\n  assetId\n);\n\n// With a contract principal\nconst contractAddress = 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X';\nconst contractName = 'test-contract';\n\nconst contractNonFungiblePostCondition = makeContractNonFungiblePostCondition(\n  contractAddress,\n  contractName,\n  postConditionCode,\n  nonFungibleAssetInfo,\n  assetId\n);\n```\n\n## Conversion of Clarity Values to JSON\n\nClarity Values represent values of Clarity contracts. If a JSON format is required the helper function `cvToJSON` can be used.\n\n```ts -n\nimport { cvToJSON, hexToCV } from '@stacks/transactions';\n\ncvToJSON(hexToCV(tx.tx_result.hex));\n```\n"
  },
  {
    "title": "@stacks/network",
    "description": "Network and API library for working with Stacks blockchain nodes.",
    "slug": "/stacks/stacks.js/packages/network",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\nimport { Callout } from \"@/components/callout\";\n\n<Callout type=\"info\">\nThis reference refers to the `7.x.x` release of Stacks.js—it's the recommended version to use, but not needed for the Stacks Nakamoto release.\nRead the [migration guide](https://github.com/hirosystems/stacks.js/blob/main/.github/MIGRATION.md#stacksjs-5xx--7xx) to learn how to update to the latest version.\n</Callout>\n\nThe `@stacks/network` package contains default network configurations for Stacks.\n\n## Installation\n\n<Callout type=\"tip\">\nBefore you install: most of the time you don't need to use or even install this library directly.\nFor example, instead of `STACKS_MAINNET`, simply use the string `\"mainnet\"` as the network parameter.\n</Callout>\n\n```package-install\n@stacks/network@latest\n```\n\n## Usage\n\n## The network object\n\nA network in Stacks.js is an object defining several properties.\n\n```ts\nimport { STACKS_MAINNET, STACKS_TESTNET, STACKS_DEVNET } from '@stacks/network';\n\nconsole.log(STACKS_MAINNET);\n// {\n//   chainId: 1,\n//   transactionVersion: 0,\n//   peerNetworkId: 385875968,\n//   magicBytes: 'X2',\n//   bootAddress: 'SP000000000000000000002Q6VF78',\n//   addressVersion: { singleSig: 22, multiSig: 20 }\n// }\n```\n\n## Network usage in transaction building\n\n```ts\nimport { STACKS_MAINNET } from '@stacks/network';\nimport { makeSTXTokenTransfer } from '@stacks/transactions';\n\nconst txOptions = {\n  recipient: 'SP2BS6HD7TN34V8Z5BNF8Q2AW3K8K2DPV4264CF26',\n  amount: 100,\n  // ...\n  network: 'mainnet', // 'mainnet', 'testnet', or 'devnet', (defaults to mainnet)\n  // OR\n  network: STACKS_MAINNET, // any compatible network object\n};\n\nconst transaction = await makeSTXTokenTransfer(txOptions);\n```\n"
  },
  {
    "title": "@stacks/common",
    "description": "Common utilities for working with Stacks.",
    "slug": "/stacks/stacks.js/packages/common",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\nimport { Callout } from \"@/components/callout\";\n\n<Callout type=\"info\">\nThis reference refers to the `7.x.x` release of Stacks.js—it's the recommended version to use, but not needed for the Stacks Nakamoto release.\nRead the [migration guide](https://github.com/hirosystems/stacks.js/blob/main/.github/MIGRATION.md#stacksjs-5xx--7xx) to learn how to update to the latest version.\n</Callout>\n\nThe `@stacks/common` package contains common utilities for working with Stacks.\nThis includes fetch helpers, middleware, and various other functions.\n\n## Installation\n\n```package-install\n@stacks/common@latest\n```\n\n\n## Use the built-in API key middleware\n\nSome Stacks APIs make use API keys to provide less rate-limited plans.\n\n```typescript\nimport { createApiKeyMiddleware, createFetchFn, StacksMainnet } from '@stacks/network';\nimport { broadcastTransaction, getNonce, makeSTXTokenTransfer } from '@stacks/transactions';\n\nconst myApiMiddleware = createApiKeyMiddleware('example_e8e044a3_41d8b0fe_3dd3988ef302');\nconst myFetchFn = createFetchFn(myApiMiddleware); // middlewares can be used to create a new fetch function\n\nconst txOptions = {\n  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',\n  amount: 12345n,\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  memo: 'some memo',\n  anchorMode: AnchorMode.Any,\n  client: {\n    fetch: myFetchFn,\n  }\n};\nconst transaction = await makeSTXTokenTransfer(txOptions); // fee-estimation will use the custom fetchFn\n\nconst response = await broadcastTransaction(transaction, myMainnet); // make sure to broadcast via the custom network object\n\n// stacks.js functions, which take a StacksNetwork object will use the custom fetchFn\nconst nonce = await getNonce('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159', myMainnet);\n```\n\n## Use custom middleware\n\nMiddleware can be used to hook into network calls before sending a request or after receiving a response.\n\n```typescript\nimport { createFetchFn, RequestContext, ResponseContext } from '@stacks/common';\n\nconst preMiddleware = (ctx: RequestContext) => {\n  ctx.init.headers = new Headers();\n  ctx.init.headers.set('x-foo', 'bar'); // override headers and set new `x-foo` header\n};\nconst postMiddleware = (ctx: ResponseContext) => {\n  console.log(await ctx.response.json()); // log response body as json\n};\n\nconst fetchFn = createFetchFn({ pre: preMiddleware, post: preMiddleware }); // a middleware can contain `pre`, `post`, or both\nconst network = new StacksTestnet({ fetchFn });\n\n// stacks.js functions, which take a StacksNetwork object will use the custom fetchFn\nconst nonce = await getNonce('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159', network);\n```\n\n## Get various API URLs\n\n```typescript\nconst txBroadcastUrl = network.getBroadcastApiUrl();\n\nconst feeEstimateUrl = network.getTransferFeeEstimateApiUrl();\n\nconst address = 'SP2BS6HD7TN34V8Z5BNF8Q2AW3K8K2DPV4264CF26';\nconst accountInfoUrl = network.getAccountApiUrl(address);\n\nconst contractName = 'hello_world';\nconst abiUrl = network.getAbiApiUrl(address, contractName);\n\nconst functionName = 'hello';\nconst readOnlyFunctionCallUrl = network.getReadOnlyFunctionCallApiUrl(\n  address,\n  contractName,\n  functionName\n);\n\nconst nodeInfoUrl = network.getInfoUrl();\n\nconst blockTimeUrl = network.getBlockTimeInfoUrl();\n\nconst poxInfoUrl = network.getPoxInfoUrl();\n```\n"
  },
  {
    "title": "Transactions",
    "description": "Learn how to create and broadcast transactions with Stacks.js.",
    "slug": "/stacks/stacks.js/concepts/transactions",
    "content": "\nThe following shows how to create a simple transaction (STX transfer) using Stacks.js in different environments.\n\n## Creating a transaction\n\n### Using Stacks Connect\n\n```ts -n\nimport { openSTXTransfer } from '@stacks/connect';\n\nopenSTXTransfer({\n  network: 'testnet',\n\n  recipient: 'ST39MJ145BR6S8C315AG2BD61SJ16E208P1FDK3AK', // which address you are sending to\n  amount: 10000, // tokens, denominated in micro-STX\n\n  onFinish: response => console.log(response.txid),\n  onCancel: () => console.log('User canceled'),\n});\n```\n\n### Using a private key\n\nFor full manual transaction signing, you need to provide the sender's private key.\nTreat the private key as a secret and *never* expose it to the public.\n\n```ts -n\nimport { makeSTXTokenTransfer } from '@stacks/transactions';\n\nconst privateKey = randomPrivateKey(); // see \"Private Keys & Wallets\" page\n\nconst tx = await makeSTXTokenTransfer({\n  recipient: 'ST39MJ145BR6S8C315AG2BD61SJ16E208P1FDK3AK', // which address you are sending to\n  amount: 10000, // tokens, denominated in micro-STX\n  senderKey: privateKey,\n  network: \"testnet\",\n});\n```\n\n## Different transaction types\n\nIn Stacks.js, we can create transactions for different purposes:\n- STX token transfers\n- Smart contract calls\n- Smart contract deployments\n"
  },
  {
    "title": "Post-Conditions",
    "description": "",
    "slug": "/stacks/stacks.js/concepts/post-conditions",
    "content": "\nIn Stacks, transactions can have *post-conditions*.\n\nThese offer additional security to ensure a transaction was executed as expected.\n\nMore precisely, adding post-conditions to a transaction can ensure that:\n\n- STX tokens were transferred from an address\n- FTs/NFTs were transferred from an address\n\n<Callout title=\"Info\">\nPost-conditions aren't perfect. They can't say anything about the end-state after a transaction. In other words, they can't guarantee the receipt of FTs/NFTs, since they only check for sending.\n</Callout>\n\nHere's an example of a post-condition using the `Pc` helper, where the `principal` must send 1000 uSTX, or else the transaction will abort:\n\n```ts -n\nimport { Pc } from '@stacks/transactions';\n\nconst tx = await makeContractCall({\n  // ...\n  postConditions: [\n    Pc.principal('STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6').willSendEq(1000).ustx(),\n  ],\n});\n```\n\nIf you prefer to write the post-condition manually, you can do so using the following approach:\n\n```ts -n\nimport { StxPostCondition, FungiblePostCondition, NonFungiblePostCondition } from '@stacks/transactions';\n// STX post-condition\nconst stxPostCondition: StxPostCondition = {\n  type: 'stx-postcondition',\n  address: 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B',\n  condition: 'gte', // 'eq' | 'gt' | 'gte' | 'lt' | 'lte'\n  amount: '100',\n};\n\n// Fungible token post-condition\nconst ftPostCondition: FungiblePostCondition = {\n  type: 'ft-postcondition',\n  address: 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B',\n  condition: 'eq', // 'eq' | 'gt' | 'gte' | 'lt' | 'lte'\n  amount: '100',\n  asset: 'SP3D6PV2ACBPEKYJTCMH7HEN02KP87QSP8KTEH335.my-ft-token::my-token',\n};\n\n// Non-fungible token post-condition\nconst nftPostCondition: NonFungiblePostCondition = {\n  type: 'nft-postcondition',\n  address: 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B',\n  condition: 'sent', // 'sent' | 'not-sent'\n  asset: 'SP3D6PV2ACBPEKYJTCMH7HEN02KP87QSP8KTEH335.my-nft::my-asset',\n  assetId: Cl.uint(602),\n};\n```\n\n## Post-condition mode\n\nIn addition to the post-condition itself, we can also specify a `mode` for the transaction to verify asset transfers.\nThe mode can be either `Allow` or `Deny`.\n\n- `Allow` means that the transaction can transfer any asset (assuming no conflicting post-conditions).\n- `Deny` means the transaction will fail if any asset transfers (not specified in the post-conditions) are attempted.\n\n<Callout>\nIn either case, all post-conditions will still be checked.\nBy default, transactions are set to `Deny` mode for additional security.\n</Callout>"
  },
  {
    "title": "Private Keys & Wallets",
    "description": "Learn how to manage secrets with Stacks.js.",
    "slug": "/stacks/stacks.js/concepts/private-keys",
    "content": "\nimport { Card, SmallCard } from '@/components/card';\nimport { Play, FileSignature } from 'lucide-react';\n\n## WITHOUT direct private key access\n\nMost users interact with apps via their favorite Stacks wallet.\nDevelopers can build web apps that prompt the user for an action (e.g. sign a transaction), and then the wallet will handle the rest.\n\n<SmallCard\n  icon={<Play className='transition-colors duration-500 ease-in-out group-hover:text-primary' />}\n  href=\"/stacks/connect\"\n  title=\"Build Web Apps\"\n  description=\"You can build Stacks enabled web apps without direct private key access using Stacks Connect.\"\n/>\n\n## WITH private key access\n\nDevelopers can build scripts, backends, and tools intended for full control over private keys.\n\n- Using the Stacks.js CLI directly to send transactions, or perform common tasks\n- Building custom tools using Stacks.js libraries that manage private keys directly\n\n### Generating random private keys\n\nLet's start by generating a random private key.\nNote that this will return a different value each time you run the code.\n\n```ts -n\nimport { randomPrivateKey } from '@stacks/transactions';\n\nconst privateKey = randomPrivateKey();\n// 'f5a31c1268a1e37d4edaa05c7d11183c5fbfdcdc48aae36ea4d8cd5cb709932801'\n```\n\nPrivate keys are typically represented as hex strings in Stacks.js.\nFor more control you can use the `PrivateKey` type, which also accepts raw bytes as `Uint8Array` in JavaScript.\n\n### Using a wallet / seed phrase\n\nTypically, we don't want to generate random private keys, but instead use a deterministic wallet based on a seed phrase.\n\n#### Generate a random seed phrase (24 words):\n\n```ts -n\nimport { randomSeedPhrase } from '@stacks/wallet-sdk';\n\nconst phrase = randomSeedPhrase();\n// \"warrior volume sport ... figure cake since\"\n```\n\n#### Generate a wallet from a seed phrase:\n\n```ts -n\nimport { generateWallet, randomSeedPhrase } from '@stacks/wallet-sdk';\n\nconst seedPhrase = randomSeedPhrase();\n\nlet wallet = await generateWallet({\n  secretKey: seedPhrase,\n  password: \"secret\",\n});\n\nconsole.log(wallet.accounts[0]); // one account is generated by default\n// { \n//   stxPrivateKey: '893fc4936c5350394bbe0053d2c31a4b5a44680f6dceb4be2aacaaa3c12e45ff01',\n//   dataPrivateKey: '676dc36d89ba04cf1789552fc35f3a6279b4b5f13f3d49fb469b0afecea9698f',\n//   appsKey: 'xprvA19evFHUzrZF3wULUSv1UVcQNRP7xJ2vn2MyAKaUHbT8SvjrrkkhANRG2bewMxHAeDSoUVUBRPiztDc8WwGtz9Ero2GXW5rk3vHHXmutb4V',\n//   salt: 'cf8a5c7142d842bb38f30c5ab626f7996dd7494236edf21ba00349bb09b9558d',\n//   index: 0\n// } \n```\n\n#### Generate more accounts:\n\n```ts -n\nimport { generateNewAccount, generateWallet, randomSeedPhrase } from '@stacks/wallet-sdk';\n\nconst seedPhrase = randomSeedPhrase();\n\nlet wallet = await generateWallet({\n  secretKey: seedPhrase,\n  password: \"secret\",\n});\n\nwallet = generateNewAccount(wallet);\nconsole.log(wallet.accounts.length); // 2\n```"
  },
  {
    "title": "Accounts & Addresses",
    "description": "Learn how to get an address from an account.",
    "slug": "/stacks/stacks.js/concepts/accounts-and-addresses",
    "content": "\nStacks uses the concept of an \"account\" to represent a user's identity on the blockchain. An account is identified by a unique address. The address is derived from the account's public key, which is derived from the account's private key.\n\nA normal mainnet address starts with `SP`, and a testnet address starts with `ST`. For example:\n\nMainnet: `SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159`\n\nTestnet: `ST2F4BK4GZH6YFBNHYDDGN4T1RKBA7DA1BJZPJEJJ`\n\n## Getting an address\n\n### Using Stacks Connect\n\n```tsx -n\nimport { showConnect } from '@stacks/connect';\n\nshowConnect({\n  appDetails,\n  userSession,\n  onFinish: () => {\n    const user = userSession.loadUserData();\n    const address = user.profile.stxAddress.mainnet;\n    // 'SP1MXSZF4NFC8JQ1TTYGEC2WADMC7Y3GHVZYRX6RF'\n  },\n});\n```\n\n### Using a seed phrase / mnemonic / private key\n\n```ts -n\nimport { randomSeedPhrase, generateWallet } from \"@stacks/wallet-sdk\";\nimport { privateKeyToAddress } from \"@stacks/transactions\";\n\nconst seed = randomSeedPhrase();\n\nconst wallet = await generateWallet({\n  secretKey: seed,\n  password: 'secret',\n});\n\nconst address = privateKeyToAddress(wallet.accounts[0].stxPrivateKey, 'mainnet');\n// 'SP1MXSZF4NFC8JQ1TTYGEC2WADMC7Y3GHVZYRX6RF'\n```\n\n### Using a public key\n\n```ts -n\nimport { publicKeyToAddress } from '@stacks/transactions';\n\nconst address = publicKeyToAddress(publicKey, 'mainnet');\n// 'SP1MXSZF4NFC8JQ1TTYGEC2WADMC7Y3GHVZYRX6RF'\n```\n\n{/* todo: add accounts code sections, once we have better abstractions */}\n\n{/* todo: multisig */}\n"
  },
  {
    "title": "Networks",
    "description": "Learn how to use different networks.",
    "slug": "/stacks/stacks.js/concepts/networks",
    "content": "\nimport { Star } from 'lucide-react';\n\nTypically, we speak of `mainnet` and `testnet` as the networks of Stacks.\nMost wallets are configured to `mainnet` by default—this is the production environment, the actual blockchain that holds real STX tokens.\n\nAs the name suggests, `testnet` is a public network for testing.\nIt's a separate blockchain state that holds test tokens, which have no value.\n\nFor completeness we also mention `devnet`.\nThis isn't \"one\" network, but how developers refer to ephemeral local networks used for testing.\nIt is the same as `testnet`, but for local development.\n[Learn more](/stacks/clarinet/guides/run-a-local-devnet).\n\n## Setting the network\n\nMost Stacks.js functions accept a `network` parameter or an optional last argument.\n\nThe `network` type is a string, and can be one of:\n- `'mainnet'` (default)\n- `'testnet'`\n- `'devnet'`\n- `'mocknet'` (alias of `devnet`)\n\n### Examples\n\nNetwork in transaction signing:\n```ts\nconst tx = makeSTXTokenTransfer({\n  // ...\n  network: 'testnet',\n});\n```\n\nNetwork in address derivation:\n```ts\nconst address = privateKeyToAddress(privateKey, 'devnet');\n// ST3NBRSFKX28FQ2ZJ1MAKX58HKHSDGNV5N7R21XCP\n```\n\n<Callout type=\"tip\">\n  For more advanced uses, you can pass an object of a network configuration.\n  Read more about the network object in the [`@stacks/network`](/stacks/stacks.js/packages/network) package.\n</Callout>\n"
  },
  {
    "title": "Broadcasting",
    "description": "Learn how to broadcast transactions to the Stacks network.",
    "slug": "/stacks/stacks.js/concepts/broadcasting",
    "content": "\n## Broadcasting Transactions\n\nA finalized transaction can be broadcasted to the network or serialized (to a byte representation) using Stacks.js.\n\n```ts -n\nimport { broadcastTransaction, makeSTXTokenTransfer } from \"@stacks/transactions\";\n\nconst transaction = await makeSTXTokenTransfer({\n  recipient: \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\",\n  amount: 42000000,\n  senderKey:\n    \"753b7cc01a1a2e86221266a154af739463fce51219d97e4f856cd7200c3bd2a601\",\n  network: \"devnet\",\n});\n\nconst tx = await broadcastTransaction({ transaction });\n\n```\n\n<Callout title=\"Info\">For web applications, user wallets can broadcast transactions via [@stacks/connect](/stacks/connect).</Callout>\n"
  },
  {
    "title": "Quickstart",
    "description": "Learn how to transfer STX tokens using Stacks.js.",
    "slug": "/stacks/stacks.js/quickstart",
    "content": "\nimport { Accordion, Accordions } from \"fumadocs-ui/components/accordion\"\nimport { ChevronRight, Code, Terminal, Folder as FolderIcon } from 'lucide-react';\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\nimport { Steps, Step } from 'fumadocs-ui/components/steps';\nimport { SmallCard } from '@/components/card';\n\nIn this quickstart guide, you will learn how to build a transaction to transfer STX tokens using Stacks.js.\n\nCheck out the [reference page](/stacks/stacks.js/packages/transactions) for `@stacks/transactions` to learn more about building different types of transactions.\n\n{/* <Callout>\n  To view the full code for this quickstart, [click here](https://github.com/hiro-so/stacks.js/tree/main/examples/hello-world).\n</Callout> */}\n\n---\n\n<Steps>\n  <Step>\n    ## Install packages\n  \n    Add the `@stacks/transactions` and `@stacks/network` packages to your project using your preferred package manager.\n\n    ```package-install title=\"Terminal\"\n    @stacks/transactions @stacks/network\n    ```\n  </Step>\n  <Step>\n    ## Build the transaction for a STX transfer\n  \n    To set up a STX token transfer transaction, use the `makeSTXTokenTransfer` function.\n\n    This function requires a private key (`senderKey`), a specified `network`, and the details of the transfer.\n\n    ```ts stx-transfer.ts -cn\n    import { makeSTXTokenTransfer } from \"@stacks/transactions\";\n    import { STACKS_TESTNET } from \"@stacks/network\";\n\n    const transaction = await makeSTXTokenTransfer({\n      recipient: \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\",\n      amount: 42000000,\n      senderKey:\n        \"753b7cc01a1a2e86221266a154af739463fce51219d97e4f856cd7200c3bd2a601\",\n      network: STACKS_TESTNET,\n    });\n    ```\n\n    There are a few optional fields for a STX transfer transaction, including `memo`, `nonce`, and `fee`.\n\n    <Accordions>\n      <Accordion title=\"Optional fields example\">\n      ```ts\n      const transaction = await makeSTXTokenTransfer({\n        // ...other fields ommitted\n        memo: \"test memo\",\n        nonce: 0n,\n        fee: 200n,\n      });\n      ```\n      </Accordion>\n    </Accordions>\n\n    <Callout>\n      Use `memo` to add a message as part of the transaction. If you don't want the builder to fetch the `nonce` and `fee` from a Stacks node, you can manually set these fields.\n    </Callout>\n  </Step>\n  <Step>\n    ## Broadcast the transaction\n  \n    Once you've constructed a valid transaction, you can broadcast it to the network using the `broadcastTransaction` function.\n\n    ```ts stx-transfer.ts -cn\n    // !mark[/broadcastTransaction/mg]\n    import { broadcastTransaction,makeSTXTokenTransfer } from \"@stacks/transactions\";\n    import { STACKS_TESTNET } from \"@stacks/network\";\n\n    const transaction = await makeSTXTokenTransfer({\n      recipient: \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\",\n      amount: 42000000,\n      senderKey:\n        \"753b7cc01a1a2e86221266a154af739463fce51219d97e4f856cd7200c3bd2a601\",\n      network: STACKS_TESTNET,\n    });\n\n    const broadcastResponse = await broadcastTransaction({ transaction });\n    const txId = broadcastResponse.txid;\n    ```\n\n    Upon success, this will return a `StacksTransaction` object that contains information about the transaction, including the `txid`.\n  </Step>\n</Steps>\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/connect/guides/authenticate-users\"\n    title=\"Authenticate users\"\n    description=\"Learn how to authenticate users using the Connect package in Stacks.js.\"\n  />\n  <Card\n    href=\"/stacks/connect/guides/broadcast-transactions\"\n    title=\"Broadcast transactions\"\n    description=\"Learn how to sign and broadcast transactions.\"\n  />\n  <Card\n    href=\"/stacks/connect/guides/sign-messages\"\n    title=\"Sign messages\"\n    description=\"Learn how to sign messages using Stacks.js.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Installation",
    "description": "Installing Stacks.js packages.",
    "slug": "/stacks/stacks.js/installation",
    "content": "\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\nStacks.js is separated into many smaller packages, which can be installed individually and are published under the `@stacks` scope.\n\nThe most commonly used packages are:\n\n<Tabs defaultValue=\"connect\">\n  <TabsList className='flex flex-wrap md:w-max'>\n    <TabsTrigger value=\"connect\" className='tab group'>\n      <Badge className='badge transition-colors group-data-[state=active]:bg-contrast group-data-[state=active]:text-background group-hover:bg-accent group-hover:text-muted-foreground'>@stacks/connect</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"common\" className='tab group'>\n      <Badge className='badge transition-colors group-data-[state=active]:bg-contrast group-data-[state=active]:text-background group-hover:bg-accent group-hover:text-muted-foreground'>@stacks/common</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"network\" className='tab group'>\n      <Badge className='badge transition-colors group-data-[state=active]:bg-contrast group-data-[state=active]:text-background group-hover:bg-accent group-hover:text-muted-foreground'>@stacks/network</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"transactions\" className='tab group'>\n      <Badge className='badge transition-colors group-data-[state=active]:bg-contrast group-data-[state=active]:text-background group-hover:bg-accent group-hover:text-muted-foreground'>@stacks/transactions</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"client\" className='tab group'>\n      <Badge className='badge transition-colors group-data-[state=active]:bg-contrast group-data-[state=active]:text-background group-hover:bg-accent group-hover:text-muted-foreground'>@stacks/blockchain-api-client</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"connect\">\n    Build Stacks-ready web apps and connect to user wallets.\n\n    ```package-install\n    @stacks/connect\n    ```\n  </TabsContent>\n  <TabsContent value=\"common\">\n    Common utilities used by Stacks.js packages.\n\n    ```package-install\n    @stacks/common\n    ```\n  </TabsContent>\n  <TabsContent value=\"network\">\n    Network library for working with Stacks network objects.\n\n    ```package-install\n    @stacks/network\n    ```\n  </TabsContent>\n  <TabsContent value=\"transactions\">\n    Construct and decode transactions, and work with Clarity smart contracts on the Stacks blockchain.\n\n    ```package-install\n    @stacks/transactions\n    ```\n  </TabsContent>\n  <TabsContent value=\"client\">\n    API client library for all Stacks Blockchain API endpoints.\n\n    ```package-install\n    @stacks/blockchain-api-client\n    ```\n  </TabsContent>\n</Tabs>\n\n---\n\n<Accordions>\n  <Accordion title=\"All available packages\">\n  [`@stacks/connect`](/stacks/connect/packages/connect) — Build Stacks-ready web applications and connect to user wallets.\n\n  `@stacks/auth` — Construct and decode authentication requests for Stacks apps.\n\n  [`@stacks/transactions`](/stacks/stacks.js/packages/transactions) — Construct and decode transactions, and work with Clarity smart contracts on the Stacks blockchain.\n\n  `@stacks/wallet-sdk` — A library for building wallets, managing accounts, and handling keys for the Stacks blockchain.\n\n  `@stacks/storage` — Store and fetch files with Gaia, the decentralized storage system.\n\n  `@stacks/profile` — Functions for manipulating user profiles.\n\n  `@stacks/encryption` — Encryption functions used by Stacks.js packages.\n\n  [`@stacks/network`](/stacks/stacks.js/packages/network) — A network and API library for working with Stacks blockchain nodes.\n\n  `@stacks/common` — Common utilities used by Stacks.js packages.\n\n  `@stacks/bns` — A library for interacting with the BNS contract.\n\n  `@stacks/stacking` — A library for PoX stacking.\n\n  `@stacks/cli` — A command line interface to interact with auth, storage, and Stacks transactions.\n\n  `@stacks/blockchain-api-client` — API client library for all Stacks Blockchain API endpoints.\n  </Accordion>\n</Accordions>\n"
  },
  {
    "title": "Integration testing",
    "description": "Learn how to write and run integration tests for your Clarity smart contracts using the Clarinet JS SDK and Vitest.",
    "slug": "/stacks/integration-testing",
    "content": "\nIntegration testing is a crucial step in smart contract development that involves testing how different components of your system work together. The Clarinet JS SDK provides powerful tools for writing and running integration tests, allowing you to simulate complex scenarios and interactions between multiple contracts.\n\nBy using integration tests, you can ensure that your smart contracts function correctly as part of a larger system and catch potential issues that might not be apparent in unit tests alone.\n\nIn this guide, you will:\n\n1. [Set up a Clarinet project with a `defi` contract.](#set-up-a-clarinet-project)\n2. [Write an integration test for the smart contract.](#test-the-deposit-and-borrow-functionality)\n3. [Run tests and generate coverage reports.](#run-tests-and-generate-coverage-reports)\n\n---\n\n## Set up a Clarinet project\n\nStart by creating a new Clarinet project. This command will create a new directory named `defi` and set up a basic Clarinet project inside it.\n\n```terminal\n$ clarinet new stx-defi\n$ cd stx-defi\n```\n\nAfter changing into your project directory, run `npm install` to install the package dependencies for testing.\n\n```terminal\n$ npm install\n```\n\nWe are going to use the same `defi` contract that we used in the [unit testing guide](/stacks/clarinet-js-sdk/guides/unit-testing), but with some additional functionality - the ability to `borrow` STX from the contract. If you don't have this project set up already, follow the steps below:\n\n```terminal\n$ clarinet contract new defi\n```\n\nThen, inside your `defi.clar` file, copy and paste the following contract code:\n\n```clarity\n;; Error constants for various failure scenarios.\n(define-constant err-overborrow (err u300))\n\n;; The interest rate for loans, represented as 10% (out of a base of 100).\n(define-data-var loan-interest-rate uint u10) ;; Representing 10% interest rate\n\n\n;; Holds the total amount of deposits in the contract, initialized to 0.\n(define-data-var total-deposits uint u0)\n\n;; Maps a user's principal address to their deposited amount.\n(define-map deposits { owner: principal } { amount: uint })\n\n;; Maps a borrower's principal address to their loan details: amount and the last interaction block.\n(define-map loans principal { amount: uint, last-interaction-block: uint })\n\n;; Public function for users to deposit STX into the contract.\n;; Updates their balance and the total deposits in the contract.\n(define-public (deposit (amount uint))\n  (let\n    (\n      ;; Fetch the current balance or default to 0 if none exists.\n      (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))\n    )\n    ;; Transfer the STX from sender = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\" to recipient = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.defi (ie: contract identifier on the chain!)\".\n    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))\n    ;; Update the user's deposit amount in the map.\n    (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })\n    ;; Update the total deposits variable.\n    (var-set total-deposits (+ (var-get total-deposits) amount))\n    ;; Return success.\n    (ok true)\n  )\n)\n\n;; Public function for users to borrow STX based on their deposits.\n(define-public (borrow (amount uint))\n  (let\n    (\n      ;; Fetch user's deposit or default to 0.\n      (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))\n      ;; Calculate the maximum amount the user is allowed to borrow. (which will be upto HALF of what they deposited)\n      (allowed-borrow (/ user-deposit u2))\n      ;; Fetch current loan details or default to initial values.\n      (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))\n      ;; Calculate accrued interest on the current loan.\n      (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))\n      ;; Calculate the total amount due including interest.\n      (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))\n      ;; Calculate the new loan total after borrowing additional amount.\n      (new-loan (+ amount))\n    )\n    ;; Ensure the requested borrow amount does not exceed the allowed amount.\n    (asserts! (<= new-loan allowed-borrow) err-overborrow)\n    ;; Transfer the borrowed STX to the user.\n    (let\n      (\n        (recipient tx-sender)\n      )\n      (try! (as-contract (stx-transfer? amount tx-sender recipient)))\n    )\n    ;; Update the user's loan details in the map.\n    (map-set loans tx-sender { amount: new-loan, last-interaction-block: block-height })\n    ;; Return success.\n    (ok true)\n  )\n)\n\n;; Read-only function to get the total balance by tx-sender\n(define-read-only (get-balance-by-sender)\n  (ok (map-get? deposits { owner: tx-sender }))\n)\n\n;; Read-only function to get the total amount owed by the user.\n(define-read-only (get-amount-owed)\n  (let\n    (\n      ;; Fetch current loan details or default to initial values.\n      (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))\n      ;; Calculate accrued interest on the current loan.\n      (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))\n      ;; Calculate the total amount due including interest.\n      (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))\n    )\n    ;; Return the total amount due.\n    (ok total-due)\n  )\n)\n\n;; Private function to calculate the accrued interest on a loan.\n(define-private (calculate-accrued-interest (principal uint) (start-block uint))\n  (let\n    (\n      ;; Calculate the number of blocks elapsed since the last interaction.\n      (elapsed-blocks (- block-height start-block))\n      ;; Calculate the interest based on the principal, rate, and elapsed time.\n      (interest (/ (* principal (var-get loan-interest-rate) elapsed-blocks) u10000))\n    )\n    ;; Ensure the loan started in the past (not at block 0).\n    (asserts! (not (is-eq start-block u0)) (ok u0))\n    ;; Return the calculated interest.\n    (ok interest)\n  )\n)\n```\n\nRun `clarinet check` to ensure that your smart contract is valid and ready for testing.\n\n<Callout>\nYou can find the full code for this project in [this repo](https://github.com/hirosystems/clarity-examples/tree/main/examples/stx-defi).\n</Callout>\n\n## Test the deposit and borrow functionality\n\nIn order to `borrow` STX from the contract, users must first `deposit` STX into it. Therefore, we need to write an integration test that simulates the interaction between these two functions.\n\nInside of your `defi.test.ts` file, replace the boilerplate code and add the following:\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { Cl } from '@stacks/transactions';\n\nconst accounts = simnet.getAccounts();\nconst wallet1 = accounts.get('wallet_1')!;\n\ndescribe('stx-defi', () => {\n  it('borrows 10 and verifies the amount owed to be 10', () => {\n    simnet.callPublicFn('defi', 'deposit', [Cl.uint(1000)], wallet1);\n    const totalDeposits = simnet.getDataVar('defi', 'total-deposits');\n    expect(totalDeposits).toBeUint(1000);\n\n    simnet.callPublicFn('defi', 'borrow', [Cl.uint(10)], wallet1);\n    const { result } = simnet.callReadOnlyFn('defi', 'get-amount-owed', [], wallet1);\n    expect(result).toBeOk(Cl.uint(10));\n  });\n});\n```\n\nIn this integration test, we're simulating a scenario where a user deposits STX into the DeFi contract and then borrows against that deposit. Let's walk through the process step by step.\n\nWe start by simulating a deposit of 1000 STX from `wallet1`. To do this, we use the `callPublicFn` method from the Clarinet JS SDK `simnet` object, which allows us to call public functions in our smart contract just as we would on the actual blockchain.\n\nAfter making the deposit, we want to verify that it was successful. We do this by checking the total deposits in the contract using `getDataVar`.\n\nThis handy method lets us peek at the value of data variables defined in your contract.\n\n<Callout>\nTo learn more about available methods for integration testing, check out the [reference page](/stacks/clarinet-js-sdk/references/methods).\n</Callout>\n\nTo ensure the deposit was recorded correctly, we use a custom matcher, `toBeUint`. This matcher is specifically designed to check if a value is a Clarity unsigned integer with the exact value we expect.\n\nWith the deposit confirmed, we simulate `wallet1` borrowing 10 STX. We do this with another call to `callPublicFn`, this time invoking the `borrow` function of our contract.\n\nAfter the borrowing operation, we want to check how much `wallet1` owes. We use `callReadOnlyFn` to call a read-only function named `get-amount-owed` in our contract.\n\nFinally, we verify the amount owed using another custom matcher, `toBeOk(Cl.uint(10))`. This matcher is particularly useful because it checks two things at once:\n\n1. That our contract returned a successful Clarity response type.\n2. That the value returned is a Clarity unsigned integer with the exact value we expect (`10`).\n\nThese custom matchers and simnet methods are powerful tools and allow you to simulate complex interactions with your smart contracts and make detailed assertions about the results.\n\n## Run tests and generate coverage reports\n\nTo run your tests, use:\n\n```terminal\n$ npm run test\n```\n\nTo generate a coverage report, use:\n\n```terminal\n$ npm run coverage\n```\n\nThis will run your tests and produce a detailed coverage report, helping you identify any untested parts of your contract.\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/simnet\"\n    title=\"API reference\"\n    description=\"Dive deeper into the properties and methods available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/custom-matchers\"\n    title=\"Custom matchers\"\n    description=\"Learn about the custom matchers that are available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/methods\"\n    title=\"SDK methods\"\n    description=\"Learn about the methods available in the Clarinet JS SDK.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Migration guide",
    "description": "Learn how to migrate your existing Clarinet projects to the Clarinet SDK.",
    "slug": "/stacks/migration-guide",
    "content": "\nIn this guide, you will learn how to:\n\n1. Migrate your existing Clarinet projects to the Clarinet SDK.\n2. Run your existing tests using the Clarinet SDK.\n\n<Callout title=\"Note\">\nThis guide is for projects that have been created with Clarinet v1 and do not have the v2 boilerplate code auto-generated in their projects.\n</Callout>\n\n---\n\n## Executing the migration script\n\nInside your Clarinet v1 project, run the following command to initialise NPM and Vitest. It will also create a sample test file.\n\n```terminal\n$ npx @hirosystems/clarinet-sdk@latest\n```\n\nFollow the prompts to initialise NPM and Vitest, this can take a few seconds.\n\n<Callout title=\"Info\">\nThe file `tests/counter_test.ts` that was created by `clarinet contract new counter` can be deleted.\n\nYou can also have a look at `tests/contract.test.ts`. It's a sample file showing how to use the SDK with Vitest.\nIt can safely be deleted.\n</Callout>\n\n## Unit test for <code className='text-lg'>counter</code> example\n\n```ts tests/counter.test.ts\nimport { Cl } from '@stacks/transactions';\nimport { describe, expect, it } from 'vitest';\n\nconst accounts = simnet.getAccounts();\nconst address1 = accounts.get('wallet_1')!;\n\ndescribe('test `increment` public function', () => {\n  it('increments the count by the given value', () => {\n    const incrementResponse = simnet.callPublicFn('counter', 'increment', [Cl.uint(1)], address1);\n    console.log(Cl.prettyPrint(incrementResponse.result)); // (ok u2)\n    expect(incrementResponse.result).toBeOk(Cl.uint(2));\n\n    const count1 = simnet.getDataVar('counter', 'count');\n    expect(count1).toBeUint(2);\n\n    simnet.callPublicFn('counter', 'increment', [Cl.uint(40)], address1);\n    const count2 = simnet.getDataVar('counter', 'count');\n    expect(count2).toBeUint(42);\n  });\n\n  it('sends a print event', () => {\n    const incrementResponse = simnet.callPublicFn('counter', 'increment', [Cl.uint(1)], address1);\n\n    expect(incrementResponse.events).toHaveLength(1);\n    const printEvent = incrementResponse.events[0];\n    expect(printEvent.event).toBe('print_event');\n    expect(printEvent.data.value).toBeTuple({\n      object: Cl.stringAscii('count'),\n      action: Cl.stringAscii('incremented'),\n      value: Cl.uint(2),\n    });\n  });\n});\n```\n\nTo run the test, go back to your console and run the `test` command using your preferred package manager. It should display a report telling you that tests succeeded.\n\n```terminal\n$ npm test\n```\n\n<Callout title=\"Note\">\nThe `simnet` object is available globally in the tests, and is automatically initialized before each test. You can have a look at the `vitest.config.js` file at the root of you project for more details.\n</Callout>\n\nGetting back to the tests - the first test checks that the `increment` function returns the new value and saves it to the `count` variable.\nThe second test checks that an `print_event` is emitted when the `increment` function is called.\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/simnet\"\n    title=\"API Reference\"\n    description=\"Dive deeper into the properties and methods available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/custom-matchers\"\n    title=\"Custom matchers\"\n    description=\"Learn about the custom matchers that are available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/guides/migrate-to-the-clarinet-sdk\"\n    title=\"Migrating your tests to Clarinet SDK\"\n    description=\"Learn how to migrate your existing Clarinet projects to the Clarinet JS SDK\"\n  />\n</Cards>"
  },
  {
    "title": "API keys",
    "description": "For developers who need API requests beyond the standard rate limits.",
    "slug": "/stacks/api-keys",
    "content": "\nimport ApiKeysContent from '@/content/_shared/api-keys.mdx';\n\n<ApiKeysContent components={props.components} />\n"
  },
  {
    "title": "Info",
    "description": "Retrieves information about the Token Metadata API, including the server version.",
    "slug": "/stacks/api/token-metadata/info/index",
    "content": ""
  },
  {
    "title": "Get status",
    "description": "Retrieves information about the Token Metadata API, including the server version.",
    "slug": "/stacks/api/token-metadata/info/status",
    "content": "\n<APIPage\n  document=\"./openapi/token-metadata-api.json\"\n  operations={[{ path: '/metadata/v1/', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Tokens",
    "description": "Retrieves information about tokens on the Stacks blockchain.",
    "slug": "/stacks/api/token-metadata/tokens/index",
    "content": "\n"
  },
  {
    "title": "Get fungible token metadata",
    "description": "Retrieves metadata for a SIP-010 fungible token.",
    "slug": "/stacks/api/token-metadata/tokens/fungible-token-metadata",
    "content": "\n<APIPage\n  document=\"./openapi/token-metadata-api.json\"\n  operations={[{ path: '/metadata/v1/ft/{principal}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get semi-fungible token metadata",
    "description": "Retrieves information about semi-fungible tokens.",
    "slug": "/stacks/api/token-metadata/tokens/semi-fungible-token-metadata",
    "content": "\n<APIPage\n  document=\"./openapi/token-metadata-api.json\"\n  operations={[{ path: '/metadata/v1/sft/{principal}/{token_id}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get fungible tokens",
    "description": "Retrieves information about fungible tokens.",
    "slug": "/stacks/api/token-metadata/tokens/fungible-tokens",
    "content": "\n<APIPage\n  document=\"./openapi/token-metadata-api.json\"\n  operations={[{ path: '/metadata/v1/ft', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get non-fungible token metadata",
    "description": "Retrieves metadata for a SIP-009 non-fungible token.",
    "slug": "/stacks/api/token-metadata/tokens/non-fungible-token-metadata",
    "content": "\n<APIPage\n  document=\"./openapi/token-metadata-api.json\"\n  operations={[{ path: '/metadata/v1/nft/{principal}/{token_id}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Pagination",
    "description": "Learn how to paginate through lists.",
    "slug": "/stacks/api/pagination",
    "content": "\nTo make API responses more compact, lists returned by the API are paginated. For lists, the response body includes:\n\n- `limit`: The number of list items return per response\n- `offset`: The number of elements to skip (starting from 0)\n- `total`: The number of all available list items\n- `results`: The array of list items (length of array equals the set limit)\n\nHere is a sample response:\n\n```json\n{\n  \"limit\": 10,\n  \"offset\": 0,\n  \"total\": 101922,\n  \"results\": [\n    {\n      \"tx_id\": \"0x924e0a688664851f5f96b437fabaec19b7542cfcaaf92a97eae43384cacd83d0\",\n      \"nonce\": 308,\n      \"fee_rate\": \"0\",\n      \"sender_address\": \"ST39F7SA0AKH7RB363W3NE2DTHD3P32ZHNX2KE7J9\",\n      \"sponsored\": false,\n      \"post_condition_mode\": \"deny\",\n      \"post_conditions\": [],\n      \"anchor_mode\": \"on_chain_only\",\n      \"block_hash\": \"0x17ceb3da5f36aab351d6b14f5aa77f85bb6b800b954b2f24c564579f80116d99\",\n      \"parent_block_hash\": \"0xe0d1e8d216a77526ae2ce40294fc77038798a179a6532bb8980d3c2183f58de6\",\n      \"block_height\": 14461,\n      \"burn_block_time\": 1622875042,\n      \"burn_block_time_iso\": \"2021-06-05T06:37:22.000Z\",\n      \"canonical\": true,\n      \"tx_index\": 0,\n      \"tx_status\": \"success\",\n      \"tx_result\": {},\n      \"microblock_hash\": \"\",\n      \"microblock_sequence\": 2147483647,\n      \"microblock_canonical\": true,\n      \"event_count\": 0,\n      \"events\": [],\n      \"tx_type\": \"coinbase\",\n      \"coinbase_payload\": {}\n    },\n    {}\n  ]\n}\n```\n\nUsing the `limit` and `offset` properties, you can paginate through the entire list by increasing the offset by the limit until you reach the total.\n"
  },
  {
    "title": "APIs",
    "description": "The following guides cover ways to use Hiro tools to build apps on Stacks.",
    "slug": "/stacks/api/index",
    "content": "\nimport { Database, Ticket } from 'lucide-react';\nimport { Blockchain, BitcoinIcon, Clarinet, Container, DAO, Js, Plant, Shapes, StacksIcon } from '@/components/ui/icon';\nimport { SecondaryCard, SmallCard } from '@/components/card';\n\n<div className='flex flex-col space-y-10'>\n\n<Cards>\n  <SecondaryCard\n    icon={<Database />}\n    href=\"/stacks/chainhook/quickstart\"\n    title=\"Stream custom blockchain events\"\n    description=\"Use Chainhook to filter & stream for contract deployments.\"\n    tag='Chainhook'\n  />\n</Cards>\n\n<div className='flex flex-col'>\n\n<h4 id=\"learn-by-example\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#learn-by-example\" className=\"not-prose group text-sm uppercase\">Learn by example</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<Shapes />}\n    href=\"/guides/build-an-nft-marketplace\"\n    title=\"Build an NFT Marketplace\"\n    description=\"Learn how to create and deploy your own NFT marketplace.\"\n  />\n  {/* <SmallCard\n    icon={<DAO />}\n    href=\"/stacks/clarinet\"\n    title=\"Launch a Decentralized Autonomous Organization (DAO)\"\n    description=\"Discover the steps to creating your own DAO.\"\n  /> */}\n  <SmallCard\n    icon={<Ticket />}\n    href=\"/guides/no-loss-lottery\"\n    title=\"Create a no-loss lottery pool\"\n    description=\"Build a no-loss lottery pool that leverages stacking yield.\"\n  />\n  <SmallCard\n    icon={<Plant />}\n    href=\"/guides/build-a-decentralized-kickstarter\"\n    title=\"Build a decentralized Kickstarter\"\n    description=\"Learn how to create a crowdfunding app, enabling creators to fund their projects without a third party.\"\n  />\n</Cards>\n\n</div>\n\n<div className='flex flex-col'>\n\n<h4 id=\"installation-guides\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#installation-guides\" className=\"not-prose group text-sm uppercase\">Installation guides</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<BitcoinIcon />}\n    href=\"/guides/sync-a-bitcoin-node\"\n    title=\"Sync a Bitcoin node\"\n    description=\"Set up and run a Bitcoin node to run tools like Chainhook as a service.\"\n  />\n  <SmallCard\n    icon={<StacksIcon />}\n    href=\"/guides/sync-a-stacks-node\"\n    title=\"Sync a Stacks node\"\n    description=\"Set up and run a Stacks node to use tools like Chainhook or spin up your own API.\"\n  />\n  <SmallCard\n    icon={<Container />}\n    href=\"/guides/installing-docker\"\n    title=\"Install and run Docker on your machine\"\n    description=\"Essential for running a local development with Clarinet\"\n  />\n</Cards>\n\n</div>\n\n<Callout type=\"tip\">\nFor more, check out our [guides](/guides) section.\n</Callout>\n\n</div>\n"
  },
  {
    "title": "Authentication",
    "description": "Authenticate with the Stacks Blockchain API.",
    "slug": "/stacks/api/authentication",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nThe Stacks Blockchain API expands the intentionally minimal RPC endpoints available in Stacks nodes and indexes, cleans, and enriches on-chain data to put everything you need at your fingertips. Who knew getting reliable blockchain data could be this easy?\n\n## Popular endpoints\n\n<Callout title=\"RPC endpoints\" type=\"info\">\nIf you're looking for direct access to the Stacks node, including the ability to broadcast transactions and interact with smart contracts, check out our [Stacks Node RPC](/stacks/rpc-api) documentation.\n</Callout>\n\n<Callout title=\"Need help building with the Stacks Blockchain API?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#api</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>\n\n\n"
  },
  {
    "title": "Nonce handling",
    "description": "Learn how to handle nonces on Stacks.",
    "slug": "/stacks/api/nonce-handling",
    "content": "\nIn order to prevent \"stuck\" transactions, you must track the next available nonce for principals issuing transactions. The\nStacks Blockchain API provides an endpoint to make nonce handling simpler when using the following command:\n\n```terminal\n$ curl 'https://api.testnet.hiro.so/extended/v1/address/<principal>/nonces'\n```\n\n```json\n{\n  \"last_executed_tx_nonce\": 5893,\n  \"last_mempool_tx_nonce\": null,\n  \"possible_next_nonce\": 5894,\n  \"detected_missing_nonces\": []\n}\n```\n\nThe `possible_next_nonce` property is the nonce suggested for a given principal's next transaction. It is derived as the next integer to the largest nonce found in blocks and mempool. It does not take into account missing nonces.\n\nThe `detected_missing_nonces` property finds any non-contiguous nonces after inspecting transactions from blocks and the mempool. For example, for a given principal, if the latest transaction included in a block has a nonce of 5, and the's only one transaction in the mempool with nonce 7, then it indicates that something likely went wrong with transaction with nonce 6 (either it was not created or broadcasted correctly by a client, or it was dropped for whatever reason). This is a strong indication that the mempool transaction with nonce 7 will never be mined since the previous nonce is missing.\n\nClients that continue to broadcast transactions with the `possible_next_nonce` property of 8, then 9, then 10, will likely result in all of their pending/mempool transactions never going through. For all transactions go through, clients should first use any missing nonces before using the suggested `possible_next_nonce`.\n"
  },
  {
    "title": "Architecture",
    "description": "Understand the architecture of the Stacks Blockchain API.",
    "slug": "/stacks/api/architecture",
    "content": "\nimport { ImageZoom } from 'fumadocs-ui/components/image-zoom';\n\n<ImageZoom\n  width=\"750\"\n  height=\"450\"\n  alt=\"stacks-api-architecture\"\n  src='/images/api/architecture.svg'\n  className=\"mt-0 mb-6 first-line:rounded-xl bg-background\"\n  priority\n/>\n\n## RPC Endpoints\n\nThe `stacks-node` has its own minimal set of http endpoints referred to as `RPC endpoints`.\n\n- The `stacks-blockchain-api` allows clients to access RPC endpoints by proxying requests to a load-balanced pool of `stacks-nodes`.\n- For more details on RPC endpoints, see: [RPC Endpoints Documentation](https://github.com/blockstack/stacks-blockchain/blob/master/docs/rpc-endpoints.md)\n- Common RPC endpoints include:\n  - `POST /v2/transactions` - Broadcast a transaction\n  - `GET /v2/pox` - Retrieve current Proof of Transfer (PoX) relevant information\n  - `POST /v2/contracts/call-read/<contract>/<function>` - Evaluate and return the result of calling a Clarity function\n  - `POST /v2/fees/transaction` - Evaluate a given transaction and provide transaction fee estimation data\n  - `GET /v2/accounts/<address>` - Fetch the current nonce required for creating transactions\n\n## Additional Endpoints\n\nThe Stacks Blockchain API implements additional endpoints that provide data unavailable directly from Stacks nodes due to various constraints.\n\n- The `stacks-node` may not persist certain data or may not serve it efficiently to many clients. For instance, while it can return the current STX balance of an account, it cannot provide a history of account transactions.\n- The API implements the Rosetta specification by Coinbase, an open standard designed to simplify blockchain deployment and interaction. More information can be found at [Rosetta API](https://www.rosetta-api.org/).\n- The API includes support for the Blockchain Naming System (BNS) endpoints. Details are available at [BNS Documentation](https://docs.stacks.co/clarity/example-contracts/bns).\n- For Express.js routes, see the directory `/src/api/routes`.\n\nThe API creates an \"event observer\" http server which listens for events from a stacks-node \"event emitter\".\n\nEvents are HTTP POST requests containing:\n  - Blocks\n  - Transactions\n\nByproducts of executed transactions such as:\n  - Asset transfers\n  - Smart-contract log data\n  - Execution cost data\n\nThe API processes and stores these events as relational data in PostgreSQL. For the \"event observer\" code, see `/src/event-stream`.\n\n## OpenAPI and JSON Schema\n\nAll http endpoints and responses are defined in OpenAPI and JSON Schema.\n\n- See `/docs/openapi.yaml`\n- These are used to auto-generate the docs at https://hirosystems.github.io/stacks-blockchain-api/\n- JSON Schemas are converted into TypeScript interfaces, which are used internally by the db controller module to transform SQL query results into the correct object shapes.\n- OpenAPI and JSON Schemas are also used to generate a standalone `@stacks/blockchain-api-client`.\n\n## Development Setup\n\nThe easiest/quickest way to develop in this repo is using the VS Code debugger. It uses docker-compose to set up a stacks-node and Postgres instance.\n\nAlternatively, you can run `npm run dev:integrated` which does the same thing but without a debugger.\n"
  },
  {
    "title": "Get block",
    "description": "Retrieves a single block.",
    "slug": "/stacks/api/stacks-blockchain/blocks/get-block",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/blocks/{height_or_hash}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get recent blocks",
    "description": "Retrieves a list of recently mined blocks.",
    "slug": "/stacks/api/stacks-blockchain/blocks/recent-blocks",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/block/', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get block by hash",
    "description": "Retrieves block details of a specific block for a given chain height.",
    "slug": "/stacks/api/stacks-blockchain/blocks/block-by-hash",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/block/{hash}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Blocks",
    "description": "Handle the retrieval and management of block data using various identifiers.",
    "slug": "/stacks/api/stacks-blockchain/blocks/index",
    "content": ""
  },
  {
    "title": "Get blocks by burn block",
    "description": "Retrieves a list of blocks confirmed by a specific burn block.",
    "slug": "/stacks/api/stacks-blockchain/blocks/get-blocks-by-burn-block",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/burn-blocks/{height_or_hash}/blocks', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get block by burnchain block height",
    "description": "Retrieves block details of a specific block for a given burnchain block height.",
    "slug": "/stacks/api/stacks-blockchain/blocks/block-by-burn-block-height",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/block/by_burn_block_height/{burn_block_height}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get average block times",
    "description": "Retrieves average block times.",
    "slug": "/stacks/api/stacks-blockchain/blocks/average-times",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/blocks/average-times', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get blocks",
    "description": "Retrieves a list of recently mined blocks.",
    "slug": "/stacks/api/stacks-blockchain/blocks/get-blocks",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/blocks/', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get block by burnchain block hash",
    "description": "Retrieves block details of a specific block for a given burnchain block hash.",
    "slug": "/stacks/api/stacks-blockchain/blocks/block-by-burn-block-hash",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/block/by_burn_block_hash/{burn_block_hash}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get block by height",
    "description": "Retrieves block details of a specific block for a given chain height.",
    "slug": "/stacks/api/stacks-blockchain/blocks/block-by-height",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/block/by_height/{height}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get all names",
    "description": "Retrieves a list of all names known to the node.",
    "slug": "/stacks/api/stacks-blockchain/names/names",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/v1/names/', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get name subdomains",
    "description": "Retrieves the list of subdomains for a specific name.",
    "slug": "/stacks/api/stacks-blockchain/names/name-subdomains",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/v1/names/{name}/subdomains', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get name zone file",
    "description": "Retrieves the zone file for a specific name.",
    "slug": "/stacks/api/stacks-blockchain/names/name-zonefile",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/v1/names/{name}/zonefile', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Names",
    "description": "Manages and retrieve information on blockchain namespaces, names, and related details.",
    "slug": "/stacks/api/stacks-blockchain/names/index",
    "content": ""
  },
  {
    "title": "Get names owned by address",
    "description": "Retrieves the list of names owned by a specific address.",
    "slug": "/stacks/api/stacks-blockchain/names/owned-by-address",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/v1/addresses/{blockchain}/{address}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get namespace names",
    "description": "Retrieves a list of names within a given namespace.",
    "slug": "/stacks/api/stacks-blockchain/names/namespace-names",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/v1/namespaces/{tld}/names', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get all namespaces",
    "description": "Retrieves a list of all namespaces known to the node.",
    "slug": "/stacks/api/stacks-blockchain/names/namespaces",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/v1/namespaces/', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get name details",
    "description": "Retrieves details of a given name including the address, status and last transaction ID.",
    "slug": "/stacks/api/stacks-blockchain/names/name-details",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/v1/names/{name}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get historical zone file",
    "description": "Retrieves the historical zone file for a specific name.",
    "slug": "/stacks/api/stacks-blockchain/names/historical-zonefile",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/v1/names/{name}/zonefile/{zoneFileHash}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get fee rate",
    "description": "Retrieves an estimated fee rate for transactions.",
    "slug": "/stacks/api/stacks-blockchain/fees/fee-rate",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/fee_rate/', method: 'post' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Fees",
    "description": "Provide estimates, rates, and approximate calculations for transaction costs.",
    "slug": "/stacks/api/stacks-blockchain/fees/index",
    "content": ""
  },
  {
    "title": "Get recent burnchain reward recipients",
    "description": "Retrieves a list of recent burnchain (e.g. Bitcoin) reward recipients with the associated amounts and block info.",
    "slug": "/stacks/api/stacks-blockchain/stacking-rewards/recent-burnchain-reward-recipients",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/burnchain/rewards', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Stacking rewards",
    "description": "Provides information on recent rewards, recipients, and total earned amounts.",
    "slug": "/stacks/api/stacks-blockchain/stacking-rewards/index",
    "content": ""
  },
  {
    "title": "Get recent burnchain reward for the given recipient",
    "description": "Retrieves a list of recent burnchain (e.g. Bitcoin) rewards for the given recipient with the associated amounts and block info.",
    "slug": "/stacks/api/stacks-blockchain/stacking-rewards/recent-burnchain-reward-recipient",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/burnchain/rewards/{address}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get recent reward slot holders",
    "description": "Retrieves a list of the Bitcoin addresses that would validly receive Proof-of-Transfer commitments.",
    "slug": "/stacks/api/stacks-blockchain/stacking-rewards/recent-reward-slot-holders",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/burnchain/reward_slot_holders', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get recent reward slot holder entries",
    "description": "Retrieves a list of the Bitcoin addresses that would validly receive Proof-of-Transfer commitments for a given reward slot holder recipient address.",
    "slug": "/stacks/api/stacks-blockchain/stacking-rewards/recent-reward-slot-holder-entries",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/burnchain/reward_slot_holders/{address}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get total burnchain rewards for the given recipient",
    "description": "Retrieves the total burnchain (e.g. Bitcoin) rewards for a given recipient address.",
    "slug": "/stacks/api/stacks-blockchain/stacking-rewards/total-burnchain-rewards-for-recipient",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/burnchain/rewards/{address}/total', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get PoX cycles",
    "description": "Retrieves a list of PoX cycles.",
    "slug": "/stacks/api/stacks-blockchain/proof-of-transfer/cycles",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/pox/cycles', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Proof of Transfer",
    "description": "Retrieve information on PoX cycles, signers, and stackers.",
    "slug": "/stacks/api/stacks-blockchain/proof-of-transfer/index",
    "content": "\n"
  },
  {
    "title": "Get signer in PoX cycle",
    "description": "Retrieves details for a signer in a PoX cycle.",
    "slug": "/stacks/api/stacks-blockchain/proof-of-transfer/signer-in-cycle",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/pox/cycles/{cycle_number}/signers/{signer_key}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get PoX cycle",
    "description": "Retrieves details for a PoX cycle.",
    "slug": "/stacks/api/stacks-blockchain/proof-of-transfer/cycle",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/pox/cycles/{cycle_number}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get signers in PoX cycle",
    "description": "Retrieves a list of signers in a PoX cycle.",
    "slug": "/stacks/api/stacks-blockchain/proof-of-transfer/signers-in-cycle",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/pox/cycles/{cycle_number}/signers', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get stackers for signer in PoX cycle",
    "description": "Retrieves a list of stackers for a signer in a PoX cycle.",
    "slug": "/stacks/api/stacks-blockchain/proof-of-transfer/stackers-for-signer-in-cycle",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/pox/cycles/{cycle_number}/signers/{signer_key}/stackers', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Search by ID",
    "description": "Search blocks, transactions, contracts, or accounts by hash/ID.",
    "slug": "/stacks/api/stacks-blockchain/search/search-by-id",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/search/{id}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Search",
    "description": "Search for a principal by ID.",
    "slug": "/stacks/api/stacks-blockchain/search/index",
    "content": "\n"
  },
  {
    "title": "Get total and unlocked STX supply",
    "description": "Retrieves the total and unlocked STX supply.",
    "slug": "/stacks/api/stacks-blockchain/info/total-and-unlocked-stx-supply",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/stx_supply/', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get a given network's target block time",
    "description": "Retrieves the target block time for a given network.",
    "slug": "/stacks/api/stacks-blockchain/info/network-given-block-time",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/info/network_block_time/{network}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get circulating STX supply in plain text format",
    "description": "Retrieves the circulating STX supply as plain text.",
    "slug": "/stacks/api/stacks-blockchain/info/circulating-stx-supply-in-plain-text",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/stx_supply/circulating/plain', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get the network target block time",
    "description": "Retrieves the target block times for mainnet and testnet.",
    "slug": "/stacks/api/stacks-blockchain/info/network-block-time",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/info/network_block_times', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Info",
    "description": "Retrieves information about the Core API and the Stacks network.",
    "slug": "/stacks/api/stacks-blockchain/info/index",
    "content": ""
  },
  {
    "title": "Get total STX supply in plain text format",
    "description": "Retrieves the total STX supply as plain text.",
    "slug": "/stacks/api/stacks-blockchain/info/total-stx-supply-in-plain-text",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/stx_supply/total/plain', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get API status",
    "description": "Retrieves the running status of the Stacks Blockchain API.",
    "slug": "/stacks/api/stacks-blockchain/info/status",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get total and unlocked STX supply (legacy)",
    "description": "Retrieves the total and unlocked STX supply in legacy format 1.0 API.",
    "slug": "/stacks/api/stacks-blockchain/info/legacy-total-and-unlocked-stx-supply",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/stx_supply/legacy_format', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get address transactions",
    "description": "Retrieves transactions sent or received by a STX address or smart contract ID.",
    "slug": "/stacks/api/stacks-blockchain/transactions/address-transactions",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/addresses/{address}/transactions', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get events for an address transaction",
    "description": "Retrieves events for a specific transaction.",
    "slug": "/stacks/api/stacks-blockchain/transactions/events-for-an-address-transaction",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/addresses/{address}/transactions/{tx_id}/events', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get transaction events",
    "description": "Retrieves events for a specific transaction.",
    "slug": "/stacks/api/stacks-blockchain/transactions/transaction-events",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tx/events', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get statistics for mempool transactions",
    "description": "Retrieves statistics for transactions in the mempool, such as counts, ages, and fees.",
    "slug": "/stacks/api/stacks-blockchain/transactions/statistics-for-mempool-transactions",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tx/mempool/stats', method: 'get' }]}\n  hasHead={false}\n/>\n\n"
  },
  {
    "title": "Transactions",
    "description": "Manage, retrieve, and broadcast transaction data on the blockchain.",
    "slug": "/stacks/api/stacks-blockchain/transactions/index",
    "content": ""
  },
  {
    "title": "Get transactions for address",
    "description": "Retrieves transactions for a specific address.",
    "slug": "/stacks/api/stacks-blockchain/transactions/transactions-for-address",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/address/{address}/mempool', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get dropped mempool transactions",
    "description": "Retrieves all recently-broadcast transactions that have been dropped from the mempool.",
    "slug": "/stacks/api/stacks-blockchain/transactions/dropped-mempool-transactions",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tx/mempool/dropped', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get transaction",
    "description": "Retrieves details for a specific transaction.",
    "slug": "/stacks/api/stacks-blockchain/transactions/get-transaction",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tx/{tx_id}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get details for transactions",
    "description": "Retrieves details for a list of transactions.",
    "slug": "/stacks/api/stacks-blockchain/transactions/details-for-transactions",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tx/multiple', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get recent transactions",
    "description": "Retrieves all recently mined transactions.",
    "slug": "/stacks/api/stacks-blockchain/transactions/recent-transactions",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tx/', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get mempool transactions",
    "description": "Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.",
    "slug": "/stacks/api/stacks-blockchain/transactions/mempool-transactions",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tx/mempool', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get transactions by block",
    "description": "Retrieves transactions confirmed in a single block.",
    "slug": "/stacks/api/stacks-blockchain/transactions/transactions-by-block",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/blocks/{height_or_hash}/transactions', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get raw transaction",
    "description": "Retrieves a hex encoded serialized transaction for a given ID.",
    "slug": "/stacks/api/stacks-blockchain/transactions/get-raw-transaction",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tx/{tx_id}/raw', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get stacking pool members",
    "description": "Retrieves the list of stacking pool members for a given delegator principal.",
    "slug": "/stacks/api/stacks-blockchain/stacking-pool/members",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/pox4/{pool_principal}/delegations/', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Stacking pool",
    "description": "Retrieve the list of stacking pool members for a given delegator principal.",
    "slug": "/stacks/api/stacks-blockchain/stacking-pool/index",
    "content": ""
  },
  {
    "title": "Faucets",
    "description": "Distribute testnet tokens to specified addresses.",
    "slug": "/stacks/api/stacks-blockchain/faucets/index",
    "content": ""
  },
  {
    "title": "STX Testnet tokens",
    "description": "Delivers testnet STX tokens to a specified address.",
    "slug": "/stacks/api/stacks-blockchain/faucets/stx",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/faucets/stx', method: 'post' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get account transactions with transfers",
    "description": "Retrieves transactions for a specific account including STX transfers for each transaction.",
    "slug": "/stacks/api/stacks-blockchain/accounts/transactions-with-transfers",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/address/{principal}/transactions_with_transfers', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get user balances",
    "description": "Retrieves account balance information, including STX, fungible, and non-fungible tokens.",
    "slug": "/stacks/api/stacks-blockchain/accounts/balances",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/address/{principal}/balances', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get account transactions",
    "description": "Retrieves transactions for a specific account.",
    "slug": "/stacks/api/stacks-blockchain/accounts/transactions",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/address/{principal}/transactions', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get nft events",
    "description": "Retrieves a list of all nft events associated with an account or a contract identifier.",
    "slug": "/stacks/api/stacks-blockchain/accounts/nft-events",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/address/{principal}/nft_events', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get account assets",
    "description": "Retrieves a list of all asset events associated with an account or a contract identifier.",
    "slug": "/stacks/api/stacks-blockchain/accounts/assets",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/address/{principal}/assets', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get account transaction with transfers",
    "description": "Retrieves transaction details for a specific transaction including STX transfers for each transaction.",
    "slug": "/stacks/api/stacks-blockchain/accounts/transaction-with-transfers",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/address/{principal}/{tx_id}/with_transfers', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get the latest nonce",
    "description": "Retrieves the latest nonce values used by an account by inspecting the mempool and anchored transactions.",
    "slug": "/stacks/api/stacks-blockchain/accounts/latest-nonce",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/address/{principal}/nonces', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get account STX balance",
    "description": "Retrieves the STX token balance for a specified address or contract identifier.",
    "slug": "/stacks/api/stacks-blockchain/accounts/stx-balances",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/address/{principal}/stx', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get inbound STX transfers",
    "description": "Retrieves a list of STX transfers with memos to the given principal.",
    "slug": "/stacks/api/stacks-blockchain/accounts/inbound-stx-transfers",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/address/{principal}/stx_inbound', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get contract events",
    "description": "Retrieves a list of events that have been triggered by a given smart contract.",
    "slug": "/stacks/api/stacks-blockchain/smart-contracts/events",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/contract/{contract_id}/events', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get contracts by trait",
    "description": "Retrieves a list of contracts based on the following traits listed in JSON format -  functions, variables, maps, fungible tokens and non-fungible tokens.",
    "slug": "/stacks/api/stacks-blockchain/smart-contracts/by-trait",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/contract/by_trait', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Smart contracts",
    "description": "Provide information and facilitate interactions with smart contracts.",
    "slug": "/stacks/api/stacks-blockchain/smart-contracts/index",
    "content": ""
  },
  {
    "title": "Get contract info",
    "description": "Retrieves details for a specific smart contract.",
    "slug": "/stacks/api/stacks-blockchain/smart-contracts/info",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/contract/{contract_id}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get contracts status",
    "description": "Retrieves the deployment status of multiple smart contracts.",
    "slug": "/stacks/api/stacks-blockchain/smart-contracts/status",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/smart-contracts/status', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Mempool",
    "description": "Retrieve information around transaction fees and priorities in the mempool.",
    "slug": "/stacks/api/stacks-blockchain/mempool/index",
    "content": ""
  },
  {
    "title": "Get transaction fee priorities",
    "description": "Retrieves estimated fee priorities (in micro-STX) for all transactions that are currently in the mempool. Also returns priorities separated by transaction type.",
    "slug": "/stacks/api/stacks-blockchain/mempool/transaction-fee-priorities",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/mempool/fees', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get burn block",
    "description": "Retrieves a single burn block.",
    "slug": "/stacks/api/stacks-blockchain/burn-blocks/get-burn-block",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/burn-blocks/{height_or_hash}', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Burn blocks",
    "description": "Retrieve information about specific burned blocks.",
    "slug": "/stacks/api/stacks-blockchain/burn-blocks/index",
    "content": ""
  },
  {
    "title": "Get burn blocks",
    "description": "Retrieves a list of recent burn blocks.",
    "slug": "/stacks/api/stacks-blockchain/burn-blocks/get-burn-blocks",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v2/burn-blocks/', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Tokens",
    "description": "Read-only endpoints to obtain token details.",
    "slug": "/stacks/api/stacks-blockchain/tokens/index",
    "content": ""
  },
  {
    "title": "Get fungible token holders",
    "description": "Retrieves the list of fungible token holders for a given token ID.",
    "slug": "/stacks/api/stacks-blockchain/tokens/holders",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tokens/ft/{token}/holders', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Non-fungible tokens",
    "description": "Read-only endpoints to obtain non-fungible token details.",
    "slug": "/stacks/api/stacks-blockchain/non-fungible-tokens/index",
    "content": ""
  },
  {
    "title": "Get non-fungible token holdings",
    "description": "Retrieves a list of non-fungible tokens owned by the given principal (STX address or smart contract ID).",
    "slug": "/stacks/api/stacks-blockchain/non-fungible-tokens/holdings",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tokens/nft/holdings', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get non-fungible token mints",
    "description": "Retrieves a list of non-fungible token mints for a given asset identifier.",
    "slug": "/stacks/api/stacks-blockchain/non-fungible-tokens/mints",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tokens/nft/mints', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Get non-fungible token history",
    "description": "Retrieves the history of a non-fungible token.",
    "slug": "/stacks/api/stacks-blockchain/non-fungible-tokens/history",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-blockchain-api.json\"\n  operations={[{ path: '/extended/v1/tokens/nft/history', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Getting started",
    "description": "Get started with Hiro APIs.",
    "slug": "/stacks/api/getting-started",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nThe Stacks Blockchain API expands the intentionally minimal RPC endpoints available in Stacks nodes and indexes, cleans, and enriches on-chain data to put everything you need at your fingertips. Who knew getting reliable blockchain data could be this easy?\n\n## Popular endpoints\n\n<Callout title=\"RPC endpoints\" type=\"info\">\nIf you're looking for direct access to the Stacks node, including the ability to broadcast transactions and interact with smart contracts, check out our [Stacks Node RPC](/stacks/rpc-api) documentation.\n</Callout>\n\n<Callout title=\"Need help building with the Stacks Blockchain API?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#api</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>\n\n\n"
  },
  {
    "title": "Requesting proofs",
    "description": "Understand proof requests from API endpoints.",
    "slug": "/stacks/api/requesting-proofs",
    "content": "\nSeveral endpoints will request the [MARF Merkel Proof](https://github.com/stacksgov/sips/blob/main/sips/sip-004/sip-004-materialized-view.md#marf-merkle-proofs) by default.\n\nProvided with the proof, a client can verify the value, cumulative energy spent, and the number of confirmation for the response value provided by the API.\n\nRequesting the proof requires more resources (computation time, response time, and response body size). To avoid the additional resources, in case verification is not required, API endpoints allow setting the request parameter: `proof=0`. The returned response object will not have any proof fields.\n"
  },
  {
    "title": "Developer environment setup",
    "description": "Set up your development environment for Stacks.",
    "slug": "/stacks/setup",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nLFG!\n\n## Related tools\n\n- **[Clarinet](/stacks/clarinet)**: Build your app in a local environment on Stacks.\n- **[Stacks.js](/stacks/stacks.js)**: Don’t reinvent the wheel and build faster with a JS library that handles basic blockchain functionality.\n- **[Stacks Blockchain API](/stacks/api)**: Fetch data and broadcast transactions with the Stacks Blockchain API.\n\n<br />\n\n<Callout title=\"Need help building with Clarinet JS SDK?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#clarinet</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>"
  },
  {
    "title": "Testing environments",
    "description": "Setup and configure testing environments for your Clarity smart contracts.",
    "slug": "/stacks/testing-environments",
    "content": "\nIntegration testing is a crucial step in smart contract development that involves testing how different components of your system work together. The Clarinet JS SDK provides powerful tools for writing and running integration tests, allowing you to simulate complex scenarios and interactions between multiple contracts.\n\nBy using integration tests, you can ensure that your smart contracts function correctly as part of a larger system and catch potential issues that might not be apparent in unit tests alone.\n\nIn this guide, you will:\n\n1. [Set up a Clarinet project with a `defi` contract.](#set-up-a-clarinet-project)\n2. [Write an integration test for the smart contract.](#test-the-deposit-and-borrow-functionality)\n3. [Run tests and generate coverage reports.](#run-tests-and-generate-coverage-reports)\n\n---\n\n## Set up a Clarinet project\n\nStart by creating a new Clarinet project. This command will create a new directory named `defi` and set up a basic Clarinet project inside it.\n\n```terminal\n$ clarinet new stx-defi\n$ cd stx-defi\n```\n\nAfter changing into your project directory, run `npm install` to install the package dependencies for testing.\n\n```terminal\n$ npm install\n```\n\nWe are going to use the same `defi` contract that we used in the [unit testing guide](/stacks/clarinet-js-sdk/guides/unit-testing), but with some additional functionality - the ability to `borrow` STX from the contract. If you don't have this project set up already, follow the steps below:\n\n```terminal\n$ clarinet contract new defi\n```\n\nThen, inside your `defi.clar` file, copy and paste the following contract code:\n\n```clarity\n;; Error constants for various failure scenarios.\n(define-constant err-overborrow (err u300))\n\n;; The interest rate for loans, represented as 10% (out of a base of 100).\n(define-data-var loan-interest-rate uint u10) ;; Representing 10% interest rate\n\n\n;; Holds the total amount of deposits in the contract, initialized to 0.\n(define-data-var total-deposits uint u0)\n\n;; Maps a user's principal address to their deposited amount.\n(define-map deposits { owner: principal } { amount: uint })\n\n;; Maps a borrower's principal address to their loan details: amount and the last interaction block.\n(define-map loans principal { amount: uint, last-interaction-block: uint })\n\n;; Public function for users to deposit STX into the contract.\n;; Updates their balance and the total deposits in the contract.\n(define-public (deposit (amount uint))\n  (let\n    (\n      ;; Fetch the current balance or default to 0 if none exists.\n      (current-balance (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))\n    )\n    ;; Transfer the STX from sender = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\" to recipient = \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.defi (ie: contract identifier on the chain!)\".\n    (try! (stx-transfer? amount tx-sender (as-contract tx-sender)))\n    ;; Update the user's deposit amount in the map.\n    (map-set deposits { owner: tx-sender } { amount: (+ current-balance amount) })\n    ;; Update the total deposits variable.\n    (var-set total-deposits (+ (var-get total-deposits) amount))\n    ;; Return success.\n    (ok true)\n  )\n)\n\n;; Public function for users to borrow STX based on their deposits.\n(define-public (borrow (amount uint))\n  (let\n    (\n      ;; Fetch user's deposit or default to 0.\n      (user-deposit (default-to u0 (get amount (map-get? deposits { owner: tx-sender }))))\n      ;; Calculate the maximum amount the user is allowed to borrow. (which will be upto HALF of what they deposited)\n      (allowed-borrow (/ user-deposit u2))\n      ;; Fetch current loan details or default to initial values.\n      (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))\n      ;; Calculate accrued interest on the current loan.\n      (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))\n      ;; Calculate the total amount due including interest.\n      (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))\n      ;; Calculate the new loan total after borrowing additional amount.\n      (new-loan (+ amount))\n    )\n    ;; Ensure the requested borrow amount does not exceed the allowed amount.\n    (asserts! (<= new-loan allowed-borrow) err-overborrow)\n    ;; Transfer the borrowed STX to the user.\n    (let\n      (\n        (recipient tx-sender)\n      )\n      (try! (as-contract (stx-transfer? amount tx-sender recipient)))\n    )\n    ;; Update the user's loan details in the map.\n    (map-set loans tx-sender { amount: new-loan, last-interaction-block: block-height })\n    ;; Return success.\n    (ok true)\n  )\n)\n\n;; Read-only function to get the total balance by tx-sender\n(define-read-only (get-balance-by-sender)\n  (ok (map-get? deposits { owner: tx-sender }))\n)\n\n;; Read-only function to get the total amount owed by the user.\n(define-read-only (get-amount-owed)\n  (let\n    (\n      ;; Fetch current loan details or default to initial values.\n      (current-loan-details (default-to { amount: u0, last-interaction-block: u0 } (map-get? loans tx-sender )))\n      ;; Calculate accrued interest on the current loan.\n      (accrued-interest (calculate-accrued-interest (get amount current-loan-details) (get last-interaction-block current-loan-details)))\n      ;; Calculate the total amount due including interest.\n      (total-due (+ (get amount current-loan-details) (unwrap-panic accrued-interest)))\n    )\n    ;; Return the total amount due.\n    (ok total-due)\n  )\n)\n\n;; Private function to calculate the accrued interest on a loan.\n(define-private (calculate-accrued-interest (principal uint) (start-block uint))\n  (let\n    (\n      ;; Calculate the number of blocks elapsed since the last interaction.\n      (elapsed-blocks (- block-height start-block))\n      ;; Calculate the interest based on the principal, rate, and elapsed time.\n      (interest (/ (* principal (var-get loan-interest-rate) elapsed-blocks) u10000))\n    )\n    ;; Ensure the loan started in the past (not at block 0).\n    (asserts! (not (is-eq start-block u0)) (ok u0))\n    ;; Return the calculated interest.\n    (ok interest)\n  )\n)\n```\n\nRun `clarinet check` to ensure that your smart contract is valid and ready for testing.\n\n<Callout>\nYou can find the full code for this project in [this repo](https://github.com/hirosystems/clarity-examples/tree/main/examples/stx-defi).\n</Callout>\n\n## Test the deposit and borrow functionality\n\nIn order to `borrow` STX from the contract, users must first `deposit` STX into it. Therefore, we need to write an integration test that simulates the interaction between these two functions.\n\nInside of your `defi.test.ts` file, replace the boilerplate code and add the following:\n\n```typescript\nimport { describe, it, expect } from 'vitest';\nimport { Cl } from '@stacks/transactions';\n\nconst accounts = simnet.getAccounts();\nconst wallet1 = accounts.get('wallet_1')!;\n\ndescribe('stx-defi', () => {\n  it('borrows 10 and verifies the amount owed to be 10', () => {\n    simnet.callPublicFn('defi', 'deposit', [Cl.uint(1000)], wallet1);\n    const totalDeposits = simnet.getDataVar('defi', 'total-deposits');\n    expect(totalDeposits).toBeUint(1000);\n\n    simnet.callPublicFn('defi', 'borrow', [Cl.uint(10)], wallet1);\n    const { result } = simnet.callReadOnlyFn('defi', 'get-amount-owed', [], wallet1);\n    expect(result).toBeOk(Cl.uint(10));\n  });\n});\n```\n\nIn this integration test, we're simulating a scenario where a user deposits STX into the DeFi contract and then borrows against that deposit. Let's walk through the process step by step.\n\nWe start by simulating a deposit of 1000 STX from `wallet1`. To do this, we use the `callPublicFn` method from the Clarinet JS SDK `simnet` object, which allows us to call public functions in our smart contract just as we would on the actual blockchain.\n\nAfter making the deposit, we want to verify that it was successful. We do this by checking the total deposits in the contract using `getDataVar`.\n\nThis handy method lets us peek at the value of data variables defined in your contract.\n\n<Callout>\nTo learn more about available methods for integration testing, check out the [reference page](/stacks/clarinet-js-sdk/references/methods).\n</Callout>\n\nTo ensure the deposit was recorded correctly, we use a custom matcher, `toBeUint`. This matcher is specifically designed to check if a value is a Clarity unsigned integer with the exact value we expect.\n\nWith the deposit confirmed, we simulate `wallet1` borrowing 10 STX. We do this with another call to `callPublicFn`, this time invoking the `borrow` function of our contract.\n\nAfter the borrowing operation, we want to check how much `wallet1` owes. We use `callReadOnlyFn` to call a read-only function named `get-amount-owed` in our contract.\n\nFinally, we verify the amount owed using another custom matcher, `toBeOk(Cl.uint(10))`. This matcher is particularly useful because it checks two things at once:\n\n1. That our contract returned a successful Clarity response type.\n2. That the value returned is a Clarity unsigned integer with the exact value we expect (`10`).\n\nThese custom matchers and simnet methods are powerful tools and allow you to simulate complex interactions with your smart contracts and make detailed assertions about the results.\n\n## Run tests and generate coverage reports\n\nTo run your tests, use:\n\n```terminal\n$ npm run test\n```\n\nTo generate a coverage report, use:\n\n```terminal\n$ npm run coverage\n```\n\nThis will run your tests and produce a detailed coverage report, helping you identify any untested parts of your contract.\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/simnet\"\n    title=\"API reference\"\n    description=\"Dive deeper into the properties and methods available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/custom-matchers\"\n    title=\"Custom matchers\"\n    description=\"Learn about the custom matchers that are available in the Clarinet JS SDK.\"\n  />\n  <Card\n    href=\"/stacks/clarinet-js-sdk/references/methods\"\n    title=\"SDK methods\"\n    description=\"Learn about the methods available in the Clarinet JS SDK.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Blockchain development",
    "description": "Build your blockchain on Stacks.",
    "slug": "/stacks/blockchain-development",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nLFG!\n\n## Related tools\n\n- **[Clarinet](/stacks/clarinet)**: Build your app in a local environment on Stacks.\n- **[Stacks.js](/stacks/stacks.js)**: Don’t reinvent the wheel and build faster with a JS library that handles basic blockchain functionality.\n- **[Stacks Blockchain API](/stacks/api)**: Fetch data and broadcast transactions with the Stacks Blockchain API.\n\n<br />\n\n<Callout title=\"Need help building with Clarinet JS SDK?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#clarinet</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>"
  },
  {
    "title": "Overview",
    "description": "A JavaScript library for authenticating users as well as signing transactions and messages.",
    "slug": "/stacks/connect/index",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nStacks Connect is a JavaScript library that can authenticate the identity of your users and prompt them to sign transactions and messages. In other words, Stacks Connect handles some of the most basic functions you need in a web app, including enabling users to log in to your app as well as broadcasting in-app transactions to the Stacks network.\n\n## Installation\n\n```package-install\n@stacks/connect\n```\n\n## Guides\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/connect/guides/authenticate-users\"\n    title=\"Authenticate users\"\n    description=\"Connect to user wallets and authenticate their on-chain identity.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/connect/guides/broadcast-transactions\"\n    title=\"Broadcast transactions\"\n    description=\"Enable users to interact with smart contracts through your app.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/connect/guides/sign-messages\"\n    title=\"Sign messages\"\n    description=\"Prompt users to sign and verify messages.\"\n  />\n</Cards>\n\n## Related tools\n\n- **[Clarinet](/stacks/clarinet)**: Build your app in the go-to development environment on Stacks.\n- **[Stacks Blockchain API](/stacks/api)**: Fetch data and broadcast transactions with the Stacks Blockchain API.\n- **[Stacks.js](/stacks/stacks.js)**: A collection of JavaScript libraries to build web applications on Stacks.\n\n<br />\n\n<Callout title=\"Need help building with Stacks Connect?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#stacks-js</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>"
  },
  {
    "title": "Wallet Support",
    "description": "Compatibility information for different wallet providers",
    "slug": "/stacks/connect/support",
    "content": "\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow\n} from \"@/components/ui/table\";\n\nThis page provides detailed information about which methods and events are supported by different wallet providers in the Stacks ecosystem.\n\n## Method Compatibility\n\n<Table>\n  <TableHeader>\n    <TableRow>\n      <TableHead>Method</TableHead>\n      <TableHead>Leather</TableHead>\n      <TableHead>Xverse-like</TableHead>\n    </TableRow>\n  </TableHeader>\n  <TableBody>\n    <TableRow>\n      <TableCell><code>getAddresses</code></TableCell>\n      <TableCell>🟡 No support for experimental purposes</TableCell>\n      <TableCell>🟡 Use <code>wallet_connect</code> instead</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>sendTransfer</code></TableCell>\n      <TableCell>🟡 Expects <code>amount</code> as string</TableCell>\n      <TableCell>🟡 Expects <code>amount</code> as number</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>signPsbt</code></TableCell>\n      <TableCell>🟡 Uses signing index array only</TableCell>\n      <TableCell>🟡 Uses <code>signInputs</code> record instead of array</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_getAddresses</code></TableCell>\n      <TableCell>🟢</TableCell>\n      <TableCell>🔴</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_getAccounts</code></TableCell>\n      <TableCell>🔴</TableCell>\n      <TableCell>🟢</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_getNetworks</code></TableCell>\n      <TableCell>🔴</TableCell>\n      <TableCell>🔴</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_transferStx</code></TableCell>\n      <TableCell>🟢</TableCell>\n      <TableCell>🟢</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_transferSip10Ft</code></TableCell>\n      <TableCell>🟢</TableCell>\n      <TableCell>🔴</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_transferSip9Nft</code></TableCell>\n      <TableCell>🟢</TableCell>\n      <TableCell>🔴</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_callContract</code></TableCell>\n      <TableCell>🟡 Hex-encoded Clarity values only</TableCell>\n      <TableCell>🟡 Hex-encoded Clarity values only, no support for <code>postConditions</code></TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_deployContract</code></TableCell>\n      <TableCell>🟡 Hex-encoded Clarity values only</TableCell>\n      <TableCell>🟡 Hex-encoded Clarity values only, no support for <code>postConditions</code></TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_signTransaction</code></TableCell>\n      <TableCell>🟡 Hex-encoded Clarity values only</TableCell>\n      <TableCell>🟡 Hex-encoded Clarity values only</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_signMessage</code></TableCell>\n      <TableCell>🟡 Hex-encoded Clarity values only</TableCell>\n      <TableCell>🟡 Hex-encoded Clarity values only</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_signStructuredMessage</code></TableCell>\n      <TableCell>🟡 Hex-encoded Clarity values only</TableCell>\n      <TableCell>🟡 Hex-encoded Clarity values only</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_updateProfile</code></TableCell>\n      <TableCell>🔴</TableCell>\n      <TableCell>🔴</TableCell>\n    </TableRow>\n  </TableBody>\n</Table>\n\n## Event Compatibility\n\n<Table>\n  <TableHeader>\n    <TableRow>\n      <TableHead>Event</TableHead>\n      <TableHead>Leather</TableHead>\n      <TableHead>Xverse</TableHead>\n    </TableRow>\n  </TableHeader>\n  <TableBody>\n    <TableRow>\n      <TableCell><code>stx_accountChange</code></TableCell>\n      <TableCell>🔴</TableCell>\n      <TableCell>🔴</TableCell>\n    </TableRow>\n    <TableRow>\n      <TableCell><code>stx_networkChange</code></TableCell>\n      <TableCell>🔴</TableCell>\n      <TableCell>🔴</TableCell>\n    </TableRow>\n  </TableBody>\n</Table>\n\n**Legend**\n\n- 🔴 No support (yet)\n- 🟡 Partial support\n- 🟢 Supported\n\n## Compatibility Layer\n\nThe `request` method in `@stacks/connect` adds a layer of auto-compatibility for different wallet providers. This helps unify the interface where wallet providers may implement methods and results differently.\n\n| Method                      | Status | Notes                                                                                                |\n| --------------------------- | ------ | ---------------------------------------------------------------------------------------------------- |\n| `getAddresses`              | 🔵     | Maps to `wallet_connect` for Xverse-like wallets                                                     |\n| `sendTransfer`              | 🔵     | Converts `amount` to number for Xverse, string for Leather                                           |\n| `signPsbt`                  | 🟡     | Transforms PSBT format for Leather (base64 to hex) with lossy restructure of `signInputs`            |\n| `stx_getAddresses`          | 🔵     | Maps to `wallet_connect` for Xverse-like wallets                                                     |\n| `stx_callContract`          | 🔵     | Transforms Clarity values to hex-encoded format for compatibility                                     |\n| `stx_deployContract`        | 🔵     | Transforms Clarity values to hex-encoded format for compatibility                                     |\n| `stx_signTransaction`       | 🔵     | Transforms Clarity values to hex-encoded format for compatibility                                     |\n| `stx_signMessage`           | 🔵     | Transforms Clarity values to hex-encoded format for compatibility                                     |\n| `stx_signStructuredMessage` | 🔵     | Transforms Clarity values to hex-encoded format for compatibility                                     |\n\n- 🟢 No overrides needed for any wallet\n- 🔵 Has compatibility overrides that maintain functionality\n- 🟡 Has breaking overrides that may lose some information\n"
  },
  {
    "title": "Authenticate users",
    "description": "Connect to user wallets and authenticate your users using @stacks/connect.",
    "slug": "/stacks/connect/examples/authenticate-users",
    "content": "\nimport { ConnectWalletButton } from '@/components/code/connect-wallet-button';\nimport { ContentBackground } from '@/components/ui/icon';\n\nAuthentication is a fundamental part of many web applications, ensuring that users are who they claim to be and that their data is secure. With the Stacks blockchain, user authentication involves connecting to users' wallets and managing their sessions securely.\n\nThe `@stacks/connect` package provides the tools needed to integrate this functionality seamlessly into your web app.\n\nIn this guide, you will learn how to:\n\n1. [Install the `@stacks/connect` package](#install-the-stacksconnect-package).\n2. [Connect to a user's wallet](#connect-to-a-users-wallet).\n3. [Manage authentication state](#manage-authentication-state).\n4. [Access user data](#access-user-data).\n\n{/* <Callout>To see this guide in action, check out a full example [here](https://github.com/hiro-so/stacks-connect-example).</Callout> */}\n\n---\n\n## Install the @stacks/connect package\n\n```package-install\n@stacks/connect\n```\n\n## Connect to a user's wallet\n\nAfter installing the `@stacks/connect` package, you can use the `connect` function to initiate a wallet connection. This will trigger a popup that allows users to select and connect their wallet.\n\n```ts\nimport { connect } from '@stacks/connect';\n\nasync function authenticate() {\n  const response = await connect();\n  // response contains the user's addresses\n}\n```\n\n<div className=\"not-prose relative overflow-hidden\">\n  <div className=\"relative bg-card rounded-lg border border-border/50 overflow-auto p-8 h-auto\">\n    <div className=\"absolute inset-x-0 bottom-0\">\n      <ContentBackground />\n    </div>\n    <div className=\"grid place-items-center h-full\">\n      <ConnectWalletButton />\n    </div>\n  </div>\n</div>\n\nThe `connect` function stores the user's addresses in local storage by default, making it easy to persist the user's session across page reloads and browser sessions.\n\n<Callout>You can customize the connection behavior by passing options to the `connect` function, such as forcing wallet selection or specifying default providers. See the [advanced usage](/stacks/connect/packages/connect#advanced-usage) section for more details.</Callout>\n\n## Manage authentication state\n\nYou can manage the user's authentication state using the following functions:\n\n```ts\nimport { connect, disconnect, isConnected } from '@stacks/connect';\n\n// Check if user is connected\nconst authenticated = isConnected();\n\n// Connect to wallet\nawait connect();\n\n// Disconnect user\ndisconnect(); // clears local storage and selected wallet\n```\n\n## Access user data\n\nOnce connected, you can access the user's data using the `getLocalStorage` function or make specific requests using the `request` method:\n\n```ts\nimport { getLocalStorage, request } from '@stacks/connect';\n\n// Get stored user data\nconst userData = getLocalStorage();\n// {\n//   \"addresses\": {\n//     \"stx\": [\n//       { \"address\": \"SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN\" },\n//     ],\n//     \"btc\": [\n//       { \"address\": \"bc1pp3ha248m0mnaevhp0txfxj5xaxmy03h0j7zuj2upg34mt7s7e32q7mdfae\" },\n//     ]\n//   }\n// }\n\n// Get detailed account information\nconst accounts = await request('stx_getAccounts');\n// {\n//   \"addresses\": [\n//     {\n//       \"address\": \"SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN\",\n//       \"publicKey\": \"02d3331cbb9f72fe635e6f87c2cf1a13cd...\",\n//       \"gaiaHubUrl\": \"https://hub.hiro.so\",\n//       \"gaiaAppKey\": \"0488ade4040658015580000000dc81e3a5...\"\n//     }\n//   ]\n// }\n```\n\n<Callout title=\"Note\">For a list of all available methods, see the [reference](/stacks/connect/packages/connect) page.</Callout>\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/connect/guides/broadcast-transactions\"\n    title=\"Broadcast transactions\"\n    description=\"Learn how to sign and broadcast transactions.\"\n  />\n  <Card\n    href=\"/stacks/stacks.js/guides/post-conditions\"\n    title=\"Deep dive into post-conditions\"\n    description=\"Learn how to build post-conditions to secure your smart contracts.\"\n  />\n</Cards>"
  },
  {
    "title": "Broadcast transactions",
    "description": "Prompt users to sign transactions and broadcast them to the Stacks blockchain.",
    "slug": "/stacks/connect/examples/broadcast-transactions",
    "content": "\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { ChevronRight, Code, Terminal } from 'lucide-react';\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\n\nThe process of broadcasting transactions is fundamental for interacting with blockchains, whether you're transferring tokens, deploying contracts, or executing contract functions.\n\nIn this guide, you will learn how to:\n\n1. [Install the necessary packages](#setup-and-installation)\n2. [Connect to a user's wallet](#connect-to-a-users-wallet)\n3. [Sign and broadcast transactions](#sign-and-broadcast-transactions)\n4. [Handle transaction results](#handle-transaction-results)\n\n---\n\n## Setup and installation\n\nInstall the required packages to start building and broadcasting transactions:\n\n```package-install\n@stacks/connect @stacks/transactions\n```\n\n## Connect to a user's wallet\n\nBefore signing transactions, users need to connect their wallet to your application. Use the `connect` function to initiate a wallet connection:\n\n```ts\nimport { connect, isConnected } from '@stacks/connect';\n\nasync function connectWallet() {\n  if (!isConnected()) {\n    const response = await connect();\n    console.log('Connected with addresses:', response);\n  }\n}\n```\n\n<Callout>\n  For more details on wallet connection, see the [authentication guide](/stacks/connect/guides/authenticate-users).\n</Callout>\n\n## Sign and broadcast transactions\n\nThere are three types of transactions you can create: STX transfers, contract deployments, and contract calls.\n\n<Tabs defaultValue=\"transfer\">\n  <TabsList className='flex flex-wrap md:w-max'>\n    <TabsTrigger value=\"transfer\" className='tab group'>\n      <Badge className='badge transition-colors'>STX transfer</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"deploy\" className='tab group'>\n      <Badge className='badge transition-colors'>Contract deployment</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"execute\" className='tab group'>\n      <Badge className='badge transition-colors'>Contract execution</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"transfer\">\n    To transfer STX tokens, use the `request` method with `stx_transferStx`:\n\n    ```ts\n    import { request } from '@stacks/connect';\n\n    async function transferStx() {\n      const response = await request('stx_transferStx', {\n        recipient: 'ST2EB9WEQNR9P0K28D2DC352TM75YG3K0GT7V13CV',\n        amount: '100', // in micro-STX (1 STX = 1,000,000 micro-STX)\n        memo: 'Reimbursement', // optional\n      });\n      \n      console.log('Transaction ID:', response.txId);\n    }\n    ```\n  </TabsContent>\n  <TabsContent value=\"deploy\">\n    To deploy a smart contract, use the `request` method with `stx_deployContract`:\n\n    ```ts\n    import { request } from '@stacks/connect';\n\n    async function deployContract() {\n      const codeBody = '(define-public (say-hi) (ok \"hello world\"))';\n      \n      const response = await request('stx_deployContract', {\n        name: 'my-contract',\n        code: codeBody,\n        clarityVersion: 3, // optional, defaults to latest version\n      });\n      \n      console.log('Transaction ID:', response.txId);\n    }\n    ```\n\n    <Callout>Contracts will deploy to the Stacks address of the connected wallet.</Callout>\n  </TabsContent>\n  <TabsContent value=\"execute\">\n    To call a contract function, use the `request` method with 'stx_callContract'. Here's an example using a simple contract:\n\n    ```clarity\n    (define-public (say-hi)\n      (print \"hi\")\n      (ok u0)\n    )\n    ```\n\n    Here's how to call this function:\n\n    ```ts\n    import { request } from '@stacks/connect';\n    import { Cl } from '@stacks/transactions';\n\n    async function callContract() {\n      const response = await request('stx_callContract', {\n        contractAddress: 'ST22T6ZS7HVWEMZHHFK77H4GTNDTWNPQAX8WZAKHJ',\n        contractName: 'my-contract',\n        functionName: 'say-hi',\n        functionArgs: [], // array of Clarity values\n      });\n      \n      console.log('Transaction ID:', response.txId);\n    }\n    ```\n\n    For functions that take arguments, you can use the `Cl` namespace to construct Clarity values:\n\n    ```ts\n    const functionArgs = [\n      Cl.uint(123),\n      Cl.stringAscii(\"hello\"),\n      Cl.standardPrincipalCV(\"ST1X..\"),\n    ];\n    ```\n  </TabsContent>\n</Tabs>\n\n## Handle transaction results\n\nWhen a transaction is signed and broadcast, the `request` method returns a response object containing information about the transaction:\n\n```ts\ninterface TransactionResponse {\n  txId: string;        // The transaction ID\n  txRaw: string;       // The raw transaction hex\n}\n```\n\nYou can use the transaction ID to create a link to view the transaction in the explorer:\n\n```ts\nasync function handleTransaction() {\n  const response = await request('stx_transferStx', {\n    recipient: 'ST2EB9WEQNR9P0K28D2DC352TM75YG3K0GT7V13CV',\n    amount: '100',\n  });\n  \n  const explorerUrl = `https://explorer.stacks.co/txid/${response.txId}`;\n  console.log('View transaction in explorer:', explorerUrl);\n}\n```\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/connect/guides/sign-messages\"\n    title=\"Sign messages\"\n    description=\"Learn how to sign messages using Stacks.js.\"\n  />\n  <Card\n    href=\"/stacks/stacks.js/guides/post-conditions\"\n    title=\"Deep dive into post-conditions\"\n    description=\"Learn how to use post-conditions to secure your smart contracts.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Sign messages",
    "description": "Prompt users to sign a message to prove they control an address or authorize an in-app action.",
    "slug": "/stacks/connect/examples/sign-messages",
    "content": "\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { ChevronRight, Code, Terminal } from 'lucide-react';\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\n\nWith Stacks Connect, users can sign a cryptographic message to prove ownership of a particular address. This is helpful for a wide range of use cases. For example, you can use message signing to create token-gated features (a user signs a message to prove they control an address holding the corresponding token requirements) or to prove the user agreed to your terms of service.\n\nIn this guide, you will learn how to:\n\n1. [Set up and install necessary packages](#setup-and-installation).\n2. [Connect to a user's wallet](#connect-to-a-users-wallet).\n3. [Sign messages](#sign-messages).\n4. [Verify signatures](#verify-signatures).\n\n---\n\n## Setup and installation\n\nUsing your preferred package manager, install the following packages:\n\n```package-install\n@stacks/connect @stacks/encryption\n```\n\n## Connect to a user's wallet\n\nBefore signing messages, users need to connect their wallet to your application. Use the `connect` function to initiate a wallet connection:\n\n```ts\nimport { connect, isConnected } from '@stacks/connect';\n\nasync function connectWallet() {\n  if (!isConnected()) {\n    const response = await connect();\n    console.log('Connected with addresses:', response);\n  }\n}\n```\n\n<Callout>\n  For more details on wallet connection, see the [authentication guide](/stacks/connect/guides/authenticate-users).\n</Callout>\n\n## Sign messages\n\nTo request a message signature, use the `request` method with `stx_signMessage`:\n\n```ts\nimport { request } from '@stacks/connect';\n\nasync function signMessage() {\n  const message = 'Hello World';\n  \n  const response = await request('stx_signMessage', {\n    message,\n  });\n  \n  console.log('Signature:', response.signature);\n  console.log('Public key:', response.publicKey);\n}\n```\n\nFor structured messages, you can use `stx_signStructuredMessage`:\n\n```ts\nimport { request } from '@stacks/connect';\nimport { Cl } from '@stacks/transactions';\n\nasync function signStructuredMessage() {\n  const message = Cl.tuple({\n    structured: Cl.stringAscii('message'),\n    num: Cl.uint(3)\n  });\n  \n  const domain = Cl.tuple({\n    name: Cl.stringAscii('My App'),\n    version: Cl.stringAscii('1.0.0'),\n    'chain-id': Cl.uint(1)\n  });\n\n  const response = await request('stx_signStructuredMessage', {\n    message,\n    domain\n  });\n  \n  console.log('Signature:', response.signature);\n  console.log('Public key:', response.publicKey);\n}\n```\n\n## Verify signatures\n\nTo verify a signature, use the `verifyMessageSignatureRsv` function from the `@stacks/encryption` package:\n\n```ts\nimport { verifyMessageSignatureRsv } from '@stacks/encryption';\n\nasync function verifySignature() {\n  const message = 'Hello World';\n  \n  const response = await request('stx_signMessage', {\n    message\n  });\n  \n  const { signature, publicKey } = response;\n  \n  const verified = verifyMessageSignatureRsv({\n    message,\n    signature,\n    publicKey\n  });\n  \n  if (verified) {\n    console.log('Signature verified!');\n  }\n}\n```\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/connect/guides/broadcast-transactions\"\n    title=\"Broadcast transactions\"\n    description=\"Learn how to sign and broadcast transactions.\"\n  />\n  <Card\n    href=\"/stacks/stacks.js/guides/post-conditions\"\n    title=\"Deep dive into post-conditions\"\n    description=\"Learn how to use post-conditions to secure your smart contracts.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Migration Guide",
    "description": "How to migrate from v7.x.x to v8.x.x of @stacks/connect",
    "slug": "/stacks/connect/examples/migration",
    "content": "\nimport { Steps, Step } from 'fumadocs-ui/components/steps'\n\n\nFor a while now, the Stacks community has been working on a new standard for wallet-to-dapp communication.\nStacks Connect and related projects now use standards like [WBIPs](https://wbips.netlify.app/) and [SIP-030](https://github.com/janniks/sips/blob/main/sips/sip-030/sip-030-wallet-interface.md) to allow wallets to communicate with dapps in a more simplified and flexible way.\n\n<Callout title=\"Migration Status\">\nPlease be patient during this latest migration.\nThere has been a long-running effort together with wallets to modernize and move forward the Stacks web ecosystem.\nIt is now culminating in [SIP-030](https://github.com/janniks/sips/blob/main/sips/sip-030/sip-030-wallet-interface.md) and the new `request` method in Stacks Connect `8.x.x`.\nBear with us during this migration.\nWallets are still working through some bugs, details, and improvements.\n\n_Feel free to continue using Stacks Connect `7.x.x` while things stabilize._\nThe `7.x.x` version may still be more well supported by some wallets.\n\nFor the legacy version of `@stacks/connect` using JWT tokens, you can use:\n\n```sh\nnpm install @stacks/connect@7.10.1\n```\n\n</Callout>\n\n## Deprecations\n\nThe following classes, methods, and types are deprecated in favor of the new `request` RPC methods:\n\n- `show...` and `open...` methods\n- `authenticate` method\n- `UserSession` class and related functionality\n- `AppConfig` class\n- `SessionOptions` interface\n- `SessionData` interface\n- `UserData` interface\n- `SessionDataStore` class\n- `InstanceDataStore` class\n- `LocalStorageStore` class\n\n<Callout title=\"Backwards Compatibility\">\nTo make migrating easier, the familiar `UserSession` & `AppConfig` class still exists and is semi-backwards compatible for the `8.x.x` release.\nIt will \"cache\" the user's address in local storage and allow access to it via the `loadUserData` method (as previously done).\n</Callout>\n\n## Migration Steps\n\nTo update from `<=7.x.x` to latest/`8.x.x`, follow these steps:\n\n<Steps>\n  <Step title=\"Update your @stacks/connect version\">\n  ```sh\n  npm install @stacks/connect@latest\n  ```\n  </Step>\n\n  <Step title=\"Replace Legacy Methods with request\">\n  Switch from `showXyz`, `openXyz`, `doXyz` methods to the `request` method:\n\n  - `request` follows the pattern `request(method: string, params: object)`, see [Usage](#usage) for more details\n  - `request` is an async function, so replace the `onFinish` and `onCancel` callbacks with `.then().catch()` or `try & await`\n\n  Examples:\n  - `showConnect()`, `authenticate()` → `connect()`\n  - `useConnect().doContractCall({})` → `request(\"stx_callContract\", {})`\n  - `openContractDeploy()` → `request(\"stx_deployContract\", {})`\n  </Step>\n\n  <Step title=\"Use Connect Instead of ShowConnect/Authenticate\">\n  Switch from `showConnect` or `authenticate` to `connect()` methods:\n\n  - `connect()` is an alias for `request({forceWalletSelect: true}, 'getAddresses')`\n  - `connect()` by default caches the user's address in local storage\n  </Step>\n\n  <Step title=\"Update Authentication State Management\">\n  - Switch from `UserSession.isSignedIn()` to `isConnected()`\n  - Switch from `UserSession.signUserOut()` to `disconnect()`\n  </Step>\n\n  <Step title=\"Remove Legacy Code\">\n  - Remove code referencing deprecated methods (`AppConfig`, `UserSession`, etc.)\n  - Remove the `@stacks/connect-react` package\n    - You may need to manually reload a component to see local storage updates\n    - No custom hooks are needed to use Stacks Connect anymore\n    - We are working on a new `@stacks/react` package that will make usage even easier in the future (e.g., tracking transaction status, reloading components when a connection is established, updating the page when the network changes, and more)\n  </Step>\n</Steps>\n\n## Address Access\n\nPreviously, the `UserSession` class was used to access the user's addresses and data, which abstracted away the underlying implementation details.\nNow, the `request` method is used to directly interact with the wallet, giving developers more explicit control and clarity over what's happening under the hood.\nThis manual approach makes the wallet interaction more transparent and customizable.\nDevelopers can manually manage the currently connected user's address in e.g. local storage, jotai, etc. or use the `connect()`/`request()` method to cache the address in local storage.\n\n<Callout title=\"Security Note\">\nFor security reasons, the `8.x.x` release only returns the current network's address (where previously both mainnet and testnet addresses were returned).\n</Callout>\n"
  },
  {
    "title": "@stacks/connect",
    "description": "Connect is a JavaScript library for building web applications connected to Stacks.",
    "slug": "/stacks/connect/packages/connect",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\n\nStacks Connect enables you to authenticate your users and connect your app to their wallet. This reference contains more detailed information on how you can authenticate users, sign and broadcast transactions on their behalf, and enable users to sign messages.\n\n<Callout title=\"Migration Note\">\nPlease be patient during the migration to version 8.x.x. There has been a long-running effort together with wallets to modernize the Stacks web ecosystem, culminating in [SIP-030](https://github.com/janniks/sips/blob/main/sips/sip-030/sip-030-wallet-interface.md) and the new `request` method in Stacks Connect 8.x.x. For the legacy version of `@stacks/connect` using JWT tokens, please use version 7.10.1. See the [Migration Guide](/docs/stacks/connect/guides/migration) for more details.\n</Callout>\n\n### Installation\n\n```package-install\n@stacks/connect\n```\n\n### Connect to a wallet\n\nInitiate a wallet connection and request addresses:\n\n```typescript\nimport { connect } from '@stacks/connect';\n\nconst response = await connect(); // stores users address in local storage by default\n```\n\nGet the local storage data (stored by a connect call):\n\n```typescript\nimport { getLocalStorage } from '@stacks/connect';\n\nconst data = getLocalStorage();\n// {\n//   \"addresses\": {\n//     \"stx\": [\n//       { \"address\": \"SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN\" },\n//     ],\n//     \"btc\": [\n//       { \"address\": \"bc1pp3ha248m0mnaevhp0txfxj5xaxmy03h0j7zuj2upg34mt7s7e32q7mdfae\" },\n//     ]\n//   }\n```\n\nManaging the connection state:\n\n```typescript\nimport { connect, disconnect, isConnected } from '@stacks/connect';\n\nisConnected(); // false\nawait connect(); // similar to the `getAddresses` method\nisConnected(); // true\ndisconnect(); // clears local storage and selected wallet\nisConnected(); // false\n```\n\n### Use request to trigger wallet interactions\n\n```typescript\nimport { request } from '@stacks/connect';\n\n// CONNECT\nconst response = await request({ forceWalletSelect: true }, 'getAddresses');\n```\n\n### Available methods\n\n- [getAddresses](#getaddresses)\n- [sendTransfer](#sendtransfer)\n- [signPsbt](#signpsbt)\n- [stx_getAddresses](#stx_getaddresses)\n- [stx_getAccounts](#stx_getaccounts)\n- [stx_transferStx](#stx_transferstx)\n- [stx_callContract](#stx_callcontract)\n- [stx_deployContract](#stx_deploycontract)\n- [stx_signMessage](#stx_signmessage)\n- [stx_signStructuredMessage](#stx_signstructuredmessage)\n\n#### getAddresses\n\n```typescript\nconst response = await request('getAddresses');\n// {\n//   \"addresses\": [\n//     {\n//       \"address\": \"bc1pp3ha248m0mnaevhp0txfxj5xaxmy03h0j7zuj2upg34mt7s7e32q7mdfae\",\n//       \"publicKey\": \"062bd2c825300d74f4f9feb6b2fec2590beac02b8938f0fc042a34254581ee69\",\n//     },\n//     {\n//       \"address\": \"bc1qtmqe7hg4etkq4t384nzg0mrmwf2sam9fjsz0mr\",\n//       \"publicKey\": \"025b65a0ec0e00699794847f2af1b5d8a53db02a2f48e09417598bef09cfea1114\",\n//     },\n//     {\n//       \"address\": \"SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN\",\n//       \"publicKey\": \"02d3331cbb9f72fe635e6f87c2cf1a13cdea520f08c0cc68584a96e8ac19d8d304\",\n//     }\n//   ]\n// }\n```\n\n#### sendTransfer\n\n```typescript\nconst response = await request('sendTransfer', {\n  recipients: [\n    {\n      address: 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4', // recipient address\n      amount: '1000', // amount in sats\n    },\n    // You can specify multiple recipients\n    {\n      address: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',\n      amount: '2000',\n    },\n  ],\n});\n// {\n//   \"txid\": \"0x1234...\", // The transaction ID\n// }\n```\n\n#### signPsbt\n\n```typescript\nconst response = await request('signPsbt', {\n  psbt: 'cHNidP...', // base64 encoded PSBT string\n  signInputs: [{ index: 0, address }], // indices of inputs to sign (optional)\n  broadcast: false, // whether to broadcast the transaction after signing (optional)\n});\n// {\n//   \"txid\": \"0x1234...\", // The transaction ID (if broadcast is true)\n//   \"psbt\": \"cHNidP...\" // The signed PSBT in base64 format\n// }\n```\n\n#### stx_getAddresses\n\n```typescript\nconst response = await request('stx_getAddresses');\n// {\n//   \"addresses\": [\n//     {\n//       \"address\": \"bc1pp3ha248m0mnaevhp0txfxj5xaxmy03h0j7zuj2upg34mt7s7e32q7mdfae\",\n//       \"publicKey\": \"062bd2c825300d74f4f9feb6b2fec2590beac02b8938f0fc042a34254581ee69\",\n//     },\n//     {\n//       \"address\": \"bc1qtmqe7hg4etkq4t384nzg0mrmwf2sam9fjsz0mr\",\n//       \"publicKey\": \"025b65a0ec0e00699794847f2af1b5d8a53db02a2f48e09417598bef09cfea1114\",\n//     },\n//     {\n//       \"address\": \"SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN\",\n//       \"publicKey\": \"02d3331cbb9f72fe635e6f87c2cf1a13cdea520f08c0cc68584a96e8ac19d8d304\",\n//     }\n//   ]\n// }\n```\n\n#### stx_getAccounts\n\n```typescript\nconst response = await request('stx_getAccounts');\n// {\n//   \"addresses\": [\n//     {\n//       \"address\": \"SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN\",\n//       \"publicKey\": \"02d3331cbb9f72fe635e6f87c2cf1a13cd...\",\n//       \"gaiaHubUrl\": \"https://hub.hiro.so\",\n//       \"gaiaAppKey\": \"0488ade4040658015580000000dc81e3a5...\"\n//     }\n//   ]\n// }\n```\n\n#### stx_transferStx\n\n```typescript\nconst response = await request('stx_transferStx', {\n  amount: '1000', // amount in micro-STX (1 STX = 1,000,000 micro-STX)\n  recipient: 'SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN', // recipient address\n  network: 'mainnet', // optional, defaults to mainnet\n  memo: 'Optional memo', // optional memo field\n});\n// {\n//   \"txid\": \"0x1234...\", // The transaction ID\n// }\n```\n\n#### stx_callContract\n\n```typescript\nconst response = await request('stx_callContract', {\n  contract: 'SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN.counters', // contract in format: address.contract-name\n  functionName: 'count', // name of the function to call\n  functionArgs: [Cl.int(3)], // array of Clarity values as arguments\n  network: 'mainnet', // optional, defaults to mainnet\n});\n// {\n//   \"txid\": \"0x1234...\", // The transaction ID\n// }\n```\n\n#### stx_deployContract\n\n```typescript\nconst response = await request('stx_deployContract', {\n  name: 'counters', // name of the contract\n  clarityCode: `(define-map counters principal int)\n\n(define-public (count (change int))\n  (ok (map-set counters tx-sender (+ (get-count tx-sender) change)))\n)\n\n(define-read-only (get-count (who principal))\n  (default-to 0 (map-get? counters who))\n)`, // Clarity code as string\n  clarityVersion: '2', // optional, defaults to latest version\n  network: 'mainnet', // optional, defaults to mainnet\n});\n// {\n//   \"txid\": \"0x1234...\", // The transaction ID\n// }\n```\n\n#### stx_signMessage\n\n```typescript\nconst response = await request('stx_signMessage', {\n  message: 'Hello, World!', // message to sign\n});\n// {\n//   \"signature\": \"0x1234...\", // The signature of the message\n//   \"publicKey\": \"02d3331cbb9f72fe635e6f87c2cf1a13cdea520f08c0cc68584a96e8ac19d8d304\" // The public key that signed the message\n// }\n```\n\n#### stx_signStructuredMessage\n\n```typescript\nconst clarityMessage = Cl.parse('{ structured: \"message\", num: u3 }');\nconst clarityDomain = Cl.tuple({\n  domain: Cl.stringAscii('example.com'),\n  version: Cl.stringAscii('1.0.0'),\n  'chain-id': Cl.uint(1),\n});\n\nconst response = await request('stx_signStructuredMessage', {\n  message: clarityMessage, // Clarity value representing the structured message\n  domain: clarityDomain, // domain object for SIP-018 style signing\n});\n// {\n//   \"signature\": \"0x1234...\", // The signature of the structured message\n//   \"publicKey\": \"02d3331cbb9f72fe635e6f87c2cf1a13cdea520f08c0cc68584a96e8ac19d8d304\" // The public key that signed the message\n// }\n```\n\n### Error Handling\n\nThe `request` method returns a Promise, allowing you to handle errors using standard Promise-based error handling patterns. You can use either `try/catch` with `async/await` or the `.catch()` method with Promise chains.\n\n#### Using try/catch with async/await\n\n```typescript\nimport { request } from '@stacks/connect';\n\ntry {\n  const response = await request('stx_transferStx', {\n    amount: '1000',\n    recipient: 'SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN',\n  });\n  // SUCCESS\n  console.log('Transaction successful:', response.txid);\n} catch (error) {\n  // ERROR\n  console.error('Wallet returned an error:', error);\n}\n```\n\n### Compatibility\n\nThe `request` method by default adds a layer of auto-compatibility for different wallet providers. This is meant to unify the interface where wallet providers may not implement methods and results the same way.\n\n<Callout title=\"Wallet Support\">\nFor a complete list of wallet compatibility and support status, see the [Wallet Support](/docs/stacks/connect/support) page.\n</Callout>\n\n### Advanced Usage\n\n#### request\n\nThe `request` method is called with an optional options object as the first parameter:\n\n```typescript\nimport { request } from '@stacks/connect';\n\n// WITH options\nconst response = await request(\n  {\n    provider?: StacksProvider;        // Custom provider to use for the request\n\n    forceWalletSelect?: boolean;      // Force user to select a wallet (default: false)\n    persistWalletSelect?: boolean;     // Persist selected wallet (default: true)\n    enableOverrides?: boolean;         // Enable provider compatibility (default: true)\n    enableLocalStorage?: boolean;      // Store address in local storage (default: true)\n\n    defaultProviders?: WbipProvider[]; // Default wallets to display in modal\n    approvedProviderIds?: string[];    // List of approved provider IDs to show in modal\n  },\n  'method',\n  params\n);\n\n// WITHOUT options\nconst response = await request('method', params);\n```\n\n<Callout title=\"Provider Compatibility\">\nThe `enableOverrides` option enables automatic compatibility fixes for different wallet providers. For example, it handles converting numeric types between string and number formats as needed by different wallets, and remaps certain method names to match wallet-specific implementations. This ensures consistent behavior across different wallet providers without requiring manual adjustments.\n</Callout>\n\n<Callout title=\"Approved Providers\">\nThe `approvedProviderIds` option allows you to filter which wallet providers are shown in the connect modal. This is useful when you want to limit the available wallet options to specific providers. For example, you might only want to support Leather wallet:\n\n```typescript\nconnect({ approvedProviderIds: ['LeatherProvider'] });\n```\n\nOr multiple specific wallets:\n\n```typescript\nconnect({ approvedProviderIds: ['LeatherProvider', 'xverse'] });\n```\n</Callout>\n\n#### requestRaw\n\nThe `requestRaw` method provides direct access to wallet providers without the additional features of `request`:\n\n```typescript\nimport { requestRaw } from '@stacks/connect';\n\nconst response = await requestRaw(provider, 'method', params);\n```\n\n<Callout title=\"Raw Request\">\n`requestRaw` bypasses the UI wallet selector, automatic provider compatibility fixes, and other features that come with `request`. Use this when you need more manual control over the wallet interaction process.\n</Callout>\n"
  },
  {
    "title": "Quickstart",
    "description": "Learn how to transfer STX tokens via a web wallet using Stacks Connect.",
    "slug": "/stacks/connect/quickstart",
    "content": "\nimport { ChevronRight, Code, Terminal, Folder as FolderIcon } from 'lucide-react';\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\nimport { Steps, Step } from 'fumadocs-ui/components/steps';\n\nIn this quickstart guide, you will learn how to set up your project, authenticate users with a web wallet, and initiate a STX token transfer.\n\nFor a deeper dive into the authentication process, check out the [authenticate users](/stacks/connect/guides/authenticate-users) guide.\n\n---\n\n<Steps>\n  <Step>\n    ## Install package dependencies\n  \n    Add the necessary packages to your project using your preferred package manager.\n\n    ```package-install\n    @stacks/connect\n    ```\n  </Step>\n  <Step>\n    ## Connect to a wallet\n  \n    The `connect` function stores the user's address in local storage by default, making it easy to persist the user's session across page reloads and browser sessions.\n\n    ```ts connect.ts\n    import { connect } from '@stacks/connect';\n\n    const response = await connect();\n    ```\n\n    To access the user's addresses, you can use the `getLocalStorage` function.\n\n    ```ts storage.ts\n    import { getLocalStorage } from '@stacks/connect';\n\n    const data = getLocalStorage();\n    ```\n\n    You can manage the connection's state using the following:\n\n    ```ts connect.ts\n    import { connect, disconnect, isConnected } from '@stacks/connect';\n\n    isConnected(); // false\n    await connect(); // similar to the `getAddresses` method\n    isConnected(); // true\n    disconnect(); // clears local storage and selected wallet\n    isConnected(); // false\n    ```\n  </Step>\n  <Step>\n    ## Use `request` to trigger a transfer\n  \n    The process of connecting to a wallet gives the web app information about the wallet account, which enables interactions with the Stacks blockchain, like calling smart contracts.\n\n    Using the `request` function, you can trigger wallet interactions using the `stx_transferStx` method.\n\n     ```tsx connect.tsx\n    const response = await request('stx_transferStx', {\n      amount: '1000', // amount in micro-STX (1 STX = 1,000,000 micro-STX)\n      recipient: 'SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN', // recipient address\n      network: 'mainnet', // optional, defaults to mainnet\n      memo: 'Optional memo', // optional memo field\n    });\n    ```\n  </Step>\n</Steps>\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/connect/guides/authenticate-users\"\n    title=\"Authenticate users\"\n    description=\"Learn how to authenticate users using the Connect package in Stacks.js.\"\n  />\n  <Card\n    href=\"/stacks/connect/guides/broadcast-transactions\"\n    title=\"Broadcast transactions\"\n    description=\"Learn how to sign and broadcast transactions.\"\n  />\n  <Card\n    href=\"/stacks/connect/guides/sign-messages\"\n    title=\"Sign messages\"\n    description=\"Learn how to sign messages using Stacks.js.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Simnet",
    "description": "The Simnet class is the main entry point for the Clarinet JS SDK. It provides properties and methods for interacting with the Clarinet network.",
    "slug": "/stacks/reference/clarinet-js-sdk/simnet",
    "content": "\nimport {\n  Accordion,\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"@/components/ui/accordion\"\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\n# `initSimnet`\n\nThe `initSimnet` function initializes a simulated network. It will often be the first function you call when using the SDK.\n\n## Parameters\n\nThe `manifestPath` is the path to the `Clarinet.toml` manifest file.\n\n  <Tabs defaultValue=\"default\">\n    <TabsList className='flex flex-wrap'>\n      <TabsTrigger value=\"default\" className='tab group'>\n        <Badge className='transition-colors'>Creating a new instance of simnet</Badge>\n      </TabsTrigger>\n      <TabsTrigger value=\"custom\" className='tab group'>\n        <Badge className='badge transition-colors'>With a custom config path</Badge>\n      </TabsTrigger>\n    </TabsList>\n    <TabsContent value=\"default\">\n      ```ts\n      import { initSimnet } from '@hirosystems/clarinet-sdk';\n\n      const simnet = await initSimnet();\n      ```\n    </TabsContent>\n    <TabsContent value=\"custom\">\n      ```ts\n      import { initSimnet } from '@hirosystems/clarinet-sdk';\n\n      const simnet = await initSimnet('./config/Clarinet.toml');\n      ```\n    </TabsContent>\n  </Tabs>\n\n  <Accordion type=\"single\" collapsible className=\"w-full\">\n    <AccordionItem value=\"schema\">\n      <AccordionTrigger>Schema</AccordionTrigger>\n      <AccordionContent>\n        ```ts\n        initSimnet(manifestPath?: string): Promise<Simnet>\n        ```\n      </AccordionContent>\n    </AccordionItem>\n  </Accordion>"
  },
  {
    "title": "Properties",
    "description": "The Clarinet JS SDK provides properties that can be used to interact with simnet.",
    "slug": "/stacks/reference/clarinet-js-sdk/properties",
    "content": "\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\n\n\n# `blockHeight`\n\nReturns the current block height of simnet.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the current block height</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const currentBlockHeight = simnet.blockHeight;\n    ```\n  </TabsContent>\n</Tabs>\n\n<Accordions>\n  <Accordion title=\"Response\">\n    ```ts\n    1\n    ```\n  </Accordion>\n</Accordions>\n\n\n# `deployer`\n\nReturns the default deployer address as defined in the project file.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the deployer address</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"set-deployer\" className='tab group'>\n      <Badge className='badge transition-colors'>Setting the deployer to a new address</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const currentDeployerAddress = simnet.deployer;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"set-deployer\">\n    ```ts\n    simnet.deployer = 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5';\n    const newDeployer = simnet.deployer\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `currentEpoch`\n\nReturns the current epoch of simnet.\n\nThis represents the Stacks blockchain's progress through discrete time periods, cycles, or upgrades.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the current epoch of simnet</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const epoch = simnet.currentEpoch;\n    ```\n  </TabsContent>\n</Tabs>\n\n<Accordions>\n  <Accordion title=\"Response\">\n    ```ts\n    2.5\n    ```\n  </Accordion>\n</Accordions>\n\n"
  },
  {
    "title": "Custom Matchers",
    "description": "A set of Vitest matchers that can be used to make assertions on Clarity values with the Clarinet JS SDK.",
    "slug": "/stacks/reference/clarinet-js-sdk/custom-matchers",
    "content": "\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\n\n\n# `toHaveClarityType`\n\nCheck that a value has the right Clarity type, without checking its value.\n\n## Parameters\n\n\nThe Clarity type that the expected value should have.\n\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an ok response</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callPublicFn(\n      'counter',\n      'increment',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toHaveClarityType(ClarityType.ResponseOk);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity counter.clar\n      (define-data-var count uint u0)\n\n      (define-public (increment)\n        (begin\n          (var-set count (+ (var-get count) u1))\n          (ok (var-get count))\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toHaveClarityType(expectedType: ClarityType)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeOk`\n\nCheck that a response is `(ok <ok-type>)` and has the expected value. Any Clarity value can be passed.\n\n## Parameters\n\n\nThe `ClarityValue` that the expected value should have.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an ok response with a specific value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callPublicFn(\n      'counter',\n      'increment',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeOk(Cl.uint(1));\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity counter.clar\n      (define-data-var count uint u0)\n\n      (define-public (increment)\n        (begin\n          (var-set count (+ (var-get count) u1))\n          (ok (var-get count))\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeOk(expected: ClarityValue)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeErr`\n\nCheck that a response is `(err <error-type>)` and has the expected value. Any Clarity value can be passed.\n\n## Parameters\n\n\nThe `ClarityValue` that the expected value should have.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an err response with a specific value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callPublicFn(\n      'counter',\n      'add',\n      [Cl.uint(19)],\n      simnet.deployer\n    );\n\n    expect(result).toBeErr(Cl.uint(500));\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity counter.clar\n      (define-constant TOO_BIG u10)\n      (define-data-var count uint u0)\n\n      (define-public (add (amount uint))\n        (begin\n          (let ((new-count (+ (var-get count) amount)))\n            (if (<= new-count TOO_BIG)\n              (begin\n                (var-set count new-count)\n                (ok (var-get count))\n              )\n              (err u500)\n            )\n          )\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeErr(expected: ClarityValue)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n# `toBeSome`\n\nCheck that a response is `(some <value>)` and has the expected value. Any Clarity value can be passed.\n\n## Parameters\n\n\nThe `ClarityValue` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an optional value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'pool',\n      'get-participant',\n      [Cl.standardPrincipal('ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5')],\n      simnet.deployer\n    );\n\n    expect(result).toBeSome(Cl.bool(true));\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity pool.clar\n      (define-map Participants principal bool)\n      (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n      (define-read-only (get-participant (who principal))\n        (map-get? ParticipantStatus who)\n      )\n\n      (map-set Participants 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 true)\n      (map-set ParticipantStatus 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 { enrollmentBlock: u1, contributionAmount: u19000000 })\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeSome(expected: ClarityValue)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `toBeNone`\n\nCheck that a response is `(none)`.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a none value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'pool',\n      'get-participant',\n      [Cl.standardPrincipal('ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5')],\n      simnet.deployer\n    );\n\n    expect(result).toBeNone();\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity pool.clar\n      (define-map Participants principal bool)\n      (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n      (define-read-only (get-participant (who principal))\n        (map-get? ParticipantStatus who)\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeNone()\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `toBeBool`\n\nAsserts the value of Clarity boolean (`true` or `false`).\n\n## Parameters\n\n\nThe `boolean` that the expected value should have.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a boolean value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'pool',\n      'has-contributed',\n      [Cl.standardPrincipal('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM')],\n      simnet.deployer\n    );\n\n    expect(result).toBeBool(true);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity pool.clar\n      (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n      (define-read-only (has-contributed (who principal))\n        (is-some (get contributionAmount (map-get? ParticipantStatus who)))\n      )\n\n      (map-set ParticipantStatus tx-sender { enrollmentBlock: u1, contributionAmount: u19000000 })\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeBool(expected: boolean)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `toBeInt`\n\nAsserts the value of a Clarity integer.\n\n## Parameters\n\n\nThe `integer` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an integer value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'counter',\n      'increment',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeInt(1); // or `1n`\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity counter.clar\n      (define-data-var count int 0)\n\n      (define-public (increment)\n        (begin\n          (var-set count (+ (var-get count) 1))\n          (ok (var-get count))\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeInt(expected: number | bigint)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeUint`\n\nAsserts the value of a Clarity unsigned integer.\n\n## Parameters\n\n\nThe `unsigned integer` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an unsigned integer value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'counter',\n      'increment',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeUint(1); // or `1n`\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity counter.clar\n      (define-data-var count uint u0)\n\n      (define-public (increment)\n        (begin\n          (var-set count (+ (var-get count) u1))\n          (ok (var-get count))\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeUint(expected: number | bigint)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeAscii`\n\nAsserts the value of a Clarity string-ascii.\n\n## Parameters\n\n\nThe `string` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a string-ascii value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'hello-world',\n      'say-hi',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeAscii('Hello World');\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity hello-world.clar\n      (define-read-only (say-hi)\n        \"Hello World\"\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeAscii(expected: string)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeUtf8`\n\nAsserts the value of a Clarity string-utf8.\n\n## Parameters\n\n\nThe `string` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a string-utf8 value</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'hello-world',\n      'say-hi',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeUtf8('Hello World');\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity hello-world.clar\n      (define-read-only (say-hi)\n        u\"Hello World\"\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeUtf8(expected: string)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBePrincipal`\n\nAsserts the value of a Clarity principal.\n\nThe principal can be a standard or a contract principal.\n\n## Parameters\n\n\nThe `string` that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a standard principal</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"options\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a contract principal</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const deployer = simnet.deployer;\n\n    expect(Cl.standardPrincipal(deployer)).toBePrincipal(deployer);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBePrincipal(expected: string) \n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"options\">\n    ```ts\n    const contract = `${simnet.deployer}.hello-world`;\n\n    expect(Cl.contractPrincipal(contract)).toBePrincipal(contract);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBePrincipal(expected: string)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeBuff`\n\nAsserts the value of a Clarity buffer. It takes an ArrayBuffer as an input.\n\nFor building a buffer, `@stacks/transactions` provides some helper functions:\n\n- `bufferFromAscii`\n- `bufferFromUtf8`\n- `bufferFromHex`\n\n## Parameters\n\n\nThe `Uint8Array` buffer that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a Uint8Array buffer</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"ascii\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for an ASCII string buffer</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"hex\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a hex string buffer</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const { result } = simnet.callReadOnlyFn(\n      'helpers',\n      'get-byte-array',\n      [],\n      simnet.deployer\n    );\n\n    const buffer = Uint8Array.from([1, 2, 3, 4]);\n    expect(result).toBeBuff(buffer);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity helpers.clar\n      (define-constant BUFFER 0x01020304)\n\n      (define-read-only (get-byte-array)\n        BUFFER\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeBuff(expected: Uint8Array)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"ascii\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const { result } = simnet.callReadOnlyFn(\n      'helpers',\n      'get-btc-buffer',\n      [],\n      simnet.deployer\n    );\n\n    const btc = Cl.bufferFromAscii('btc'); // or Cl.bufferFromUtf8('btc')\n\n    expect(result).toBeBuff(btc.buffer);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity helpers.clar\n      (define-constant ASCII_BTC 0x627463)\n\n      (define-read-only (get-btc-buffer)\n        ASCII_BTC\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeBuff(expected: Uint8Array)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"hex\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const { result } = simnet.callReadOnlyFn(\n      \"helpers\",\n      \"get-tx-hash\",\n      [],\n      simnet.deployer\n    );\n\n    const tx = Cl.bufferFromHex(\n      \"73e951acd451060f13bdab7bd947136efd80511309a295e876a682ab8a423a7e\"\n    );\n\n    expect(result).toBeBuff(tx.buffer);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity helpers.clar\n      (define-constant TX_HASH 0x73e951acd451060f13bdab7bd947136efd80511309a295e876a682ab8a423a7e)\n\n      (define-read-only (get-tx-hash)\n        TX_HASH\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeBuff(expected: Uint8Array)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeList`\n\nAsserts the value of a Clarity list containing an array of Clarity values.\n\n## Parameters\n\n\nThe `Uint8Array` buffer that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a list of Clarity values</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const { result } = simnet.callReadOnlyFn(\n      'helpers',\n      'get-addresses',\n      [],\n      simnet.deployer\n    );\n\n    expect(result).toBeList(\n      [\n        Cl.standardPrincipal('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM'),\n        Cl.standardPrincipal('ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5'),\n        Cl.standardPrincipal('ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG')\n      ]\n    );\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity helpers.clar\n      (define-read-only (get-addresses)\n        (list\n          'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\n          'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\n          'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG\n        )\n      )\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeList(expected: ClarityValue[])\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `toBeTuple`\n\nAsserts the value of a Clarity tuple.\n\n## Parameters\n\n\nThe `object` of Clarity values that the expected value should have.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Checking for a tuple</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n    \n    const { result } = simnet.callReadOnlyFn(\n      'pool',\n      'get-participant-data',\n      [Cl.standardPrincipal(simnet.deployer)],\n      simnet.deployer\n    );\n\n    expect(result).toBeTuple({\n      enrollmentBlock: Cl.some(Cl.uint(1)),\n      contributionAmount: Cl.some(Cl.uint(19000000)),\n    });\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n      ```clarity pool.clar\n      (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n      (define-read-only (get-participant (who principal))\n        (map-get? ParticipantStatus who)\n      )\n\n      (define-read-only (get-participant-data (who principal))\n        {\n          enrollmentBlock: (get enrollmentBlock (map-get? ParticipantStatus who)),\n          contributionAmount: (get contributionAmount (map-get? ParticipantStatus who))\n        }\n      )\n\n      (map-set ParticipantStatus tx-sender { enrollmentBlock: u1, contributionAmount: u19000000 })\n      ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        toBeTuple(expected: Record<string, ClarityValue>)\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n"
  },
  {
    "title": "Methods",
    "description": "The Clarinet JS SDK provides several methods that can be used to interact with simnet.",
    "slug": "/stacks/reference/clarinet-js-sdk/methods",
    "content": "\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\n\n\n# `getAccounts`\n\nRetrieve a list of all Stacks addresses configured within the project, including wallets, deployers, and faucets.\n\n\n\n\n<Tabs defaultValue=\"get-accounts\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"get-accounts\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting your accounts</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"get-account\" className='tab group'>\n      <Badge className='badge transition-colors'>Selecting a specific account</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"get-accounts\">\n    ```ts\n    const accounts = simnet.getAccounts();\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        Map(10) {\n          \"wallet_7\": \"ST3PF13W7Z0RRM42A8VZRVFQ75SV1K26RXEP8YGKJ\",\n          \"wallet_1\": \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\",\n          \"wallet_3\": \"ST2JHG361ZXG51QTKY2NQCVBPPRRE2KZB1HR05NNC\",\n          \"wallet_5\": \"ST2REHHS5J3CERCRBEPMGH7921Q6PYKAADT7JP2VB\",\n          \"wallet_8\": \"ST3NBRSFKX28FQ2ZJ1MAKX58HKHSDGNV5N7R21XCP\",\n          \"wallet_4\": \"ST2NEB84ASENDXKYGJPQW86YXQCEFEX2ZQPG87ND\",\n          \"deployer\": \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\",\n          \"wallet_6\": \"ST3AM1A56AK2C1XAFJ4115ZSV26EB49BVQ10MGCS0\",\n          \"wallet_2\": \"ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG\",\n          \"faucet\": \"STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6\",\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAccounts(): Map<string, string>\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"get-account\">\n    ```ts\n    const accounts = simnet.getAccounts();\n\n    const wallet = accounts.get('wallet_1')!;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAccounts(): Map<string, string>\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `getAssetsMap`\n\nRetrieve a list of asset balances associated with Stacks addresses, including fungible and non-fungible tokens.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting STX account balances</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"get-ft-balance\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting ft balances</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"get-nft-balance\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting nft balances</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"get-deployer-balance\" className='tab group'>\n      <Badge className='badge transition-colors'>Filtering for an account</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const assets = simnet.getAssetsMap();\n\n    const stxBalances = assets.get('STX')!;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        Map(10) {\n          \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\": 100000000000000n,\n          \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\": 100000000000000n,\n          \"ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG\": 100000000000000n,\n          \"ST2JHG361ZXG51QTKY2NQCVBPPRRE2KZB1HR05NNC\": 100000000000000n,\n          \"ST2NEB84ASENDXKYGJPQW86YXQCEFEX2ZQPG87ND\": 100000000000000n,\n          \"ST2REHHS5J3CERCRBEPMGH7921Q6PYKAADT7JP2VB\": 100000000000000n,\n          \"ST3AM1A56AK2C1XAFJ4115ZSV26EB49BVQ10MGCS0\": 100000000000000n,\n          \"ST3NBRSFKX28FQ2ZJ1MAKX58HKHSDGNV5N7R21XCP\": 100000000000000n,\n          \"ST3PF13W7Z0RRM42A8VZRVFQ75SV1K26RXEP8YGKJ\": 100000000000000n,\n          \"STNHKEPYEPJ8ET55ZZ0M5A34J0R3N5FM2CMMMAZ6\": 100000000000000n,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAssetsMap(): Map<string, Map<string, bigint>>\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"get-ft-balance\">\n    ```ts\n    const contractName = 'token';\n    const sourceCode = `\n      (define-fungible-token sbtc)\n      (ft-mint? sbtc u19 tx-sender)\n    `;\n\n    simnet.deployContract(\n      contractName,\n      sourceCode,\n      null,\n      simnet.deployer\n    );\n\n    const assets = simnet.getAssetsMap();\n\n    const tokenBalance = assets.get('.token.sbtc')!;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        Map(1) {\n          \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\": 19n,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAssetsMap(): Map<string, Map<string, bigint>>\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"get-nft-balance\">\n    ```ts\n    const contractName = 'nft';\n    const sourceCode = `\n      (define-non-fungible-token ticket uint)\n      (nft-mint? ticket u42 tx-sender)\n    `;\n\n    simnet.deployContract(\n      contractName,\n      sourceCode,\n      null,\n      simnet.deployer\n    );\n\n    const assets = simnet.getAssetsMap();\n\n    const nftBalance = assets.get('.nft.ticket')!;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        Map(1) {\n          \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\": 1n,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAssetsMap(): Map<string, Map<string, bigint>>\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"get-deployer-balance\">\n    ```ts\n    const assets = simnet.getAssetsMap();\n    const stxBalances = assets.get('STX')!;\n\n    const deployerBalance = stxBalances.get('ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM')!;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        100000000000000n\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getAssetsMap(): Map<string, Map<string, bigint>>\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `getDataVar`\n\nGet the value of a `data-var` defined in a contract.\n\n## Parameters\n\nThe contract identifier of the contract.\n\n<span>Example: `counter`</span>\n\nThe name of the `data-var` for the contract.\n\n<span>Example: `count`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the value of a data variable</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const currentCount = simnet.getDataVar('counter', 'count');\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity counter.clar\n        (define-data-var count uint u0)\n        (define-data-var contractOwner principal tx-sender)\n        \n        (var-set count (+ (var-get count) u1))\n        (var-set contractOwner 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 1,\n          value: 1n\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getDataVar(contract: string, dataVar: string): ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { cvToValue } from '@stacks/transactions';\n\n    const contractOwner = simnet.getDataVar(\"counter\", \"contractOwner\");\n\n    const response = cvToValue(contractOwner);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity counter.clar\n        (define-data-var count uint u0)\n        (define-data-var contractOwner principal tx-sender)\n        \n        (var-set count (+ (var-get count) u1))\n        (var-set contractOwner 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getDataVar(contract: string, dataVar: string): ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `getMapEntry`\n\nGet the value of a map entry by its key. Note that this method will always return an optional value `some` or `none`, just like Clarity `map-get?`.\n\n## Parameters\n\nThe contract identifier of the contract.\n\n<span>Example: `pool`</span>\n\nThe name of the map within the contract.\n\n<span>Example: `Participants`</span>\n\nThe key to access the value in the map.\n\n<span>Example: `Cl.standardPrincipal(\n  'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5'\n)`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the value of an entry</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('wallet_1')!;\n\n    const hasParticipated = simnet.getMapEntry(\n      \"pool\",\n      \"Participants\",\n      Cl.standardPrincipal(wallet)\n    );\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n\n        (map-set Participants 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 true)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 10,\n          value: {\n            type: 3,\n          },\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getMapEntry(\n          contract: string,\n          mapName: string,\n          mapKey: ClarityValue\n        ): ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { Cl, cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('wallet_1')!;\n\n    const hasParticipated = simnet.getMapEntry(\n      \"pool\",\n      \"Participants\",\n      Cl.standardPrincipal(wallet)\n    );\n\n    const response = cvToValue(hasParticipated);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n\n        (map-set Participants 'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5 true)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"bool\",\n          value: true,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getMapEntry(\n          contract: string,\n          mapName: string,\n          mapKey: ClarityValue\n        ): ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n# `callReadOnlyFn`\n\nCall read-only functions exposed by a contract.\n\nThis method returns an object with the result of the function call as a `ClarityValue`. It takes function arguments in the form of Clarity values, which are available in the package [`@stacks/transactions`](/stacks/stacks.js/packages/transactions).\n\n## Parameters\n\nThe contract identifier of the contract.\n\n<span>Example: `pool`</span>\n\nThe name of the read-only function within the contract.\n\n<span>Example: `get-participant`</span>\n\nThe arguments to pass to the read-only function. If no arguments are needed, pass an empty array.\n\n<span>Example: `[Cl.standardPrincipal(\n  'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5'\n)]`</span>\n\nThe Stacks address of the sender.\n\n<span>Example: `ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Making a function call</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"with-no-arguments\" className='tab group'>\n      <Badge className='badge transition-colors'>With no arguments</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"deployer\" className='tab group'>\n      <Badge className='badge transition-colors'>With an explicit contract address</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('wallet_1')!;\n\n    const getContributionAmount = simnet.callReadOnlyFn(\n      'pool',\n      'get-contribution-amount',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );  \n    \n    const response = getContributionAmount.result\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (get-contribution-amount (who principal))\n          (default-to u0 (get contributionAmount (get-participant who)))\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 1,\n          value: 420000000n,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n            result: ClarityValue;\n            events: ClarityEvent[];\n        }\n        \n        callReadOnlyFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"with-no-arguments\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('wallet_1')!;\n\n    const isActive = simnet.callReadOnlyFn(\n      'pool',\n      'is-active',\n      [],\n      wallet\n    );\n    \n    const response = isActive.result\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (get-contribution-amount (who principal))\n          (default-to u0 (get contributionAmount (get-participant who)))\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 10,\n          value: {\n            type: 3,\n          },\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n            result: ClarityValue;\n            events: ClarityEvent[];\n        }\n        \n        callReadOnlyFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"deployer\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n    const contractAddress = `${wallet}.pool`;\n\n    const getParticipant = simnet.callReadOnlyFn(\n      contractAddress,\n      'get-participant',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );\n\n    const response = getParticipant.result;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (get-contribution-amount (who principal))\n          (default-to u0 (get contributionAmount (get-participant who)))\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 9,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n            result: ClarityValue;\n            events: ClarityEvent[];\n        }\n        \n        callReadOnlyFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { Cl, cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n\n    const getContributionAmount = simnet.callReadOnlyFn(\n      'pool',\n      'get-contribution-amount',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );\n\n    const response = cvToValue(getContributionAmount.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (get-contribution-amount (who principal))\n          (default-to u0 (get contributionAmount (get-participant who)))\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        42000000n\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n            result: ClarityValue;\n            events: ClarityEvent[];\n        }\n        \n        callReadOnlyFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n    \n  </TabsContent>\n</Tabs>\n\n\n# `callPublicFn`\n\nCall public functions exposed by a contract.\n\nThis method returns an object with the result of the function call as a `ClarityValue` and the events fired during the function execution. It takes function arguments in the form of Clarity values, which are available in the package [`@stacks/transactions`](/stacks/stacks.js/packages/transactions).\n\nThis method will simulate a block being mined and increase the block height by one.\n\n## Parameters\n\nThe contract identifier of the contract.\n\n<span>Example: `pool`</span>\n\nThe name of the public function within the contract.\n\n<span>Example: `register-participant`</span>\n\nThe arguments to pass to the public function. If no arguments are needed, pass an empty array.\n\n<span>Example: `[Cl.standardPrincipal(\n  'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5'\n)]`</span>\n\nThe Stacks address of the sender.\n\n<span>Example: `ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Broadcasting your transaction</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"events\" className='tab group'>\n      <Badge className='badge transition-colors'>Filtering for contract events</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n\n    const registerParticipant = simnet.callPublicFn(\n      'pool',\n      'register-participant',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );\n\n    const response = registerParticipant.result;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-public (register-participant (who principal))\n          (begin\n            (map-set Participants who true)\n            (map-set ParticipantStatus who { enrollmentBlock: block-height, contributionAmount: u0 })\n            (print { message: \"Registered\", who: who, at: block-height })\n            (ok true)\n          )\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 7,\n          value: {\n            type: 3,\n          },\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        callPublicFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { Cl, cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n\n    const registerParticipant = simnet.callPublicFn(\n      'pool',\n      'register-participant',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );\n    \n    const response = cvToValue(registerParticipant.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-public (register-participant (who principal))\n          (begin\n            (map-set Participants who true)\n            (map-set ParticipantStatus who { enrollmentBlock: block-height, contributionAmount: u0 })\n            (print { message: \"Registered\", who: who, at: block-height })\n            (ok true)\n          )\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"bool\",\n          value: true,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        callPublicFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"events\">\n    ```ts\n    import { Cl, cvToValue, type ClarityValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n\n    const registerParticipant = simnet.callPublicFn(\n      'pool',\n      'register-participant',\n      [Cl.standardPrincipal(wallet)],\n      wallet\n    );\n    \n    const eventValues = registerParticipant.events.map((event) =>\n      cvToValue(event.data.value as ClarityValue)\n    );\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-public (register-participant (who principal))\n          (begin\n            (map-set Participants who true)\n            (map-set ParticipantStatus who { enrollmentBlock: block-height, contributionAmount: u0 })\n            (print { message: \"Registered\", who: who, at: block-height })\n            (ok true)\n          )\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        [\n          {\n            at: {\n              type: \"uint\",\n              value: \"2\",\n            },\n            message: {\n              type: \"(string-ascii 10)\",\n              value: \"Registered\",\n            },\n            who: {\n              type: \"principal\",\n              value: \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\",\n            },\n          }\n        ]\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        callPublicFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `callPrivateFn`\n\nCall private functions exposed by a contract.\n\nThis method returns an object with the result of the function call as a `ClarityValue` and the events, if any, fired during the function execution. It takes function arguments in the form of Clarity values, which are available in the package [`@stacks/transactions`](/stacks/stacks.js/packages/transactions).\n\nThis method will simulate a block being mined and increase the block height by one.\n\n## Parameters\n\nThe contract identifier of the contract.\n\n<span>Example: `pool`</span>\n\nThe name of the private function within the contract.\n\n<span>Example: `reward-participant-points`</span>\n\nThe arguments to pass to the private function. If no arguments are needed, pass an empty array.\n\n<span>Example: `[Cl.standardPrincipal(\n  'ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5'\n)]`</span>\n\nThe Stacks address of the sender.\n\n<span>Example: `ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Broadcasting your transaction</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n    const address1 = accounts.get(\"wallet_1\")!\n\n    const rewardParticipantPoints = simnet.callPrivateFn(\n      \"pool\",\n      \"reward-participant-points\",\n      [Cl.standardPrincipal(address1)],\n      wallet\n    );\n\n    const response = rewardParticipantPoints.result;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n        (define-map ParticipantPoints principal int)\n\n        (define-public (register-participant (who principal))\n          (begin\n            (map-set Participants who true)\n            (map-set ParticipantStatus who { enrollmentBlock: block-height, contributionAmount: u0 })\n            (reward-participant-points who)\n            (print { message: \"Registered\", who: who, at: block-height })\n            (ok true)\n          )\n        )\n\n        (define-private (reward-participant-points (who principal))\n            (map-insert ParticipantPoints who 100)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        (map-set ParticipantPoints tx-sender 1000)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: 3,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n\n        callPrivateFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { Cl, cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get('deployer')!;\n    const address1 = accounts.get(\"wallet_1\")!\n\n    const rewardParticipantPoints = simnet.callPrivateFn(\n      \"pool\",\n      \"reward-participant-points\",\n      [Cl.standardPrincipal(address1)],\n      wallet\n    );\n\n    const response = cvToValue(registerParticipant.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n        (define-map ParticipantPoints principal int)\n\n        (define-public (register-participant (who principal))\n          (begin\n            (map-set Participants who true)\n            (map-set ParticipantStatus who { enrollmentBlock: block-height, contributionAmount: u0 })\n            (reward-participant-points who)\n            (print { message: \"Registered\", who: who, at: block-height })\n            (ok true)\n          )\n        )\n\n        (define-private (reward-participant-points (who principal))\n            (map-insert ParticipantPoints who 100)\n        )\n\n        (map-set Participants tx-sender true)\n        (map-set ParticipantStatus tx-sender { enrollmentBlock: block-height, contributionAmount: u42000000 })\n        (map-set ParticipantPoints tx-sender 1000)\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"bool\",\n          value: true,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n\n        callPrivateFn(\n          contract: string,\n          method: string,\n          args: ClarityValue[],\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  \n</Tabs>\n\n\n\n# `transferSTX`\n\nTransfer STX from one address to another. The amount transferred is in `uSTX`.\n\nThis method will simulate a block being mined and increase the block height by one.\n\n## Parameters\n\nThe amount of `uSTX` to transfer.\n\n<span>Example: `1000000` equals 1 STX</span>\n\nThe Stacks address of the recipient.\n\n<span>Example: `ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5`</span>\n\nThe Stacks address of the sender.\n\n<span>Example: `ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM`</span>\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Transferring STX</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"clarity-value\" className='tab group'>\n      <Badge className='badge transition-colors'>Converting Clarity values</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"events\" className='tab group'>\n      <Badge className='badge transition-colors'>Filtering for contract events</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const accounts = simnet.getAccounts();\n    const recipient = accounts.get('wallet_1')!;\n\n    const transfer = simnet.transferSTX(\n      42000000, // 42 STX\n      recipient,\n      simnet.deployer\n    );\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          result: {\n            type: 7,\n            value: {\n              type: 3,\n            },\n          },\n          events: [\n            {\n              event: \"stx_transfer_event\",\n              data: [\n                {\n                  amount: \"42000000\",\n                  memo: \"\",\n                  recipient: \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\",\n                  sender: \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\",\n                },\n              ],\n            }\n          ],\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        transferSTX(\n          amount: number | bigint,\n          recipient: string,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"clarity-value\">\n    ```ts\n    import { cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const recipient = accounts.get('wallet_1')!;\n\n    const transfer = simnet.transferSTX(\n      42000000, // 42 STX\n      recipient,\n      simnet.deployer\n    );\n    \n    const response = cvToValue(transfer.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"bool\",\n          value: true,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        transferSTX(\n          amount: number | bigint,\n          recipient: string,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"events\">\n    ```ts\n    const accounts = simnet.getAccounts();\n    const recipient = accounts.get('wallet_1')!;\n\n    const transfer = simnet.transferSTX(\n      42000000, // 42 STX\n      recipient,\n      simnet.deployer\n    );\n\n    const events = transfer.events.map((event) => event);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        [\n          {\n            event: \"stx_transfer_event\",\n            data: {\n              amount: \"42000000\",\n              memo: \"\",\n              recipient: \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\",\n              sender: \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\",\n            },\n          }\n        ]\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        transferSTX(\n          amount: number | bigint,\n          recipient: string,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `deployContract`\n\nDeploy a contract to simnet.\n\nThis method will simulate a block being mined and increase the block height by one.\n\n## Parameters\n\nThe name of the contract to be deployed.\n\n<span>Example: `hello-world`</span>\n\nThe Clarity source code (or content) of the contract.\n\n<span>Example: `(define-read-only (say-hi) (ok \"Hello World\"))`</span>\n\nAn object to specify options, such as the Clarity version.\n\n<span>Example: `{ clarityVersion: 2 }` | `null`</span>\n\nThe Stacks address of the sender.\n\n<span>Example: `ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Deploying your contract</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"options\" className='tab group'>\n      <Badge className='badge transition-colors'>Specifying a Clarity version</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"interact\" className='tab group'>\n      <Badge className='badge transition-colors'>Interacting with your contract</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { cvToValue } from '@stacks/transactions';\n\n    const sourceCode = '(define-read-only (say-hi) (ok \"Hello World\"))';\n\n    const contract = simnet.deployContract(\n      'hello-world',\n      sourceCode,\n      null,\n      simnet.deployer\n    );\n\n    const response = cvToValue(contract.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        true\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        deployContract(\n          name: string,\n          content: string,\n          options: DeployContractOptions | null,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"options\">\n    ```ts\n    import { cvToValue } from '@stacks/transactions';\n\n    const sourceCode = '(define-read-only (say-hi) (ok \"Hello World\"))';\n\n    const contract = simnet.deployContract(\n      'hello-world',\n      sourceCode,\n      { clarityVersion: 2 },\n      simnet.deployer\n    );\n\n    const response = cvToValue(contract.result);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        true\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        deployContract(\n          name: string,\n          content: string,\n          options: DeployContractOptions | null,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n  <TabsContent value=\"interact\">\n    ```ts\n    import { cvToValue } from '@stacks/transactions';\n\n    const sourceCode = '(define-read-only (say-hi) (ok \"Hello World\"))';\n\n    simnet.deployContract(\n      'hello-world',\n      sourceCode,\n      null,\n      simnet.deployer\n    );\n\n    const sayHi = simnet.callReadOnlyFn(\"hello-world\", \"say-hi\", [], simnet.deployer);\n\n    const response = sayHi.result\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"(string-ascii 11)\",\n          value: \"Hello World\",\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        deployContract(\n          name: string,\n          content: string,\n          options: DeployContractOptions | null,\n          sender: string\n        ): ParsedTransactionResult\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `mineBlock`\n\nThe `callPublicFn`, `transferSTX`, and `deployContract` methods all mine one block with only one transaction. It can also be useful to mine a block with multiple transactions.\n\nThis is what `mineBlock` is for.\n\nThis method takes an array of transaction objects. The transactions can be built with the `tx` helper exported by the SDK.\n\nThe `tx` helper has three methods:\n- `callPublicFn`\n- `transferSTX`\n- `deployContract`\n\nThese methods have the same interface as simnet methods but instead of performing a transaction, they will build a transaction object that can be passed to the `mineBlock` function.\n\nIn epochs from 3.0 on, the stacks chaintip is advanced separately from the burn chaintip. This means `mineBlock` will only affect the stacks chaintip. If you'd like to also mine burn blocks, use the `mineEmptyBurnBlock` function.\n\n## Parameters\n\nAn array of transactions to be included in the block.\n\n<span>Example: `[tx.transferSTX(100, recipient, sender), ...]`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Mining multiple transactions in a single block</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { tx } from '@hirosystems/clarinet-sdk';\n    import { Cl, cvToValue } from '@stacks/transactions';\n\n    const accounts = simnet.getAccounts();\n    const wallet = accounts.get(\"wallet_1\")!;\n\n    const block = simnet.mineBlock([\n      tx.callPublicFn(\"counter\", \"increment\", [], simnet.deployer),\n      tx.callPublicFn(\"counter\", \"add\", [Cl.uint(10)], simnet.deployer),\n      tx.transferSTX(19000000, wallet, simnet.deployer),\n    ]);\n\n    block.forEach((transaction) => {\n      console.log(cvToValue(transaction.result));\n      if (transaction.events.length > 0) console.log(transaction.events);\n    });\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity counter.clar\n        (define-data-var count uint u0)\n\n        (define-public (increment)\n          (begin\n            (var-set count (+ (var-get count) u1))\n            (ok (var-get count))\n          )\n        )\n\n        (define-public (add (amount uint))\n          (begin\n            (var-set count (+ (var-get count) amount))\n            (ok (var-get count))\n          )\n        )\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"uint\",\n          value: \"1\",\n        }\n        {\n          type: \"uint\",\n          value: \"11\",\n        }\n        {\n          type: \"bool\",\n          value: true,\n        }\n        [\n          {\n            event: \"stx_transfer_event\",\n            data: {\n              amount: \"19000000\",\n              memo: \"\",\n              recipient: \"ST1SJ3DTE5DN7X54YDH5D64R3BCB6A2AG2ZQ8YPD5\",\n              sender: \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\",\n            },\n          }\n        ]\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        type ParsedTransactionResult = {\n          result: ClarityValue;\n          events: ClarityEvent[];\n        }\n        \n        mineBlock(txs: Tx[]): ParsedTransactionResult[]\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `mineEmptyBlock`\n\nMine one empty block and increase the block height by one.\n\nReturns the new block height.\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Mining an empty block</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    simnet.mineEmptyBlock();\n\n    const response = simnet.blockHeight;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        2\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        mineEmptyBlock(): number\n        ```\n      </Accordion>\n    </Accordions>\n\n  </TabsContent>\n</Tabs>\n\n\n\n# `mineEmptyBlocks`\n\nMine multiple empty blocks to reach a certain block height.\n\nReturns the new block height.\n\n## Parameters\n\nThe number of empty blocks to mine. This parameter is optional.\n\n<span>Example: `5`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Mining multiple empty blocks</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"options\" className='tab group'>\n      <Badge className='badge transition-colors'>Mining an empty block without a count</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    simnet.mineEmptyBlocks(5);\n\n    const response = simnet.blockHeight;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        6\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        mineEmptyBlocks(count?: number): number\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"options\">\n    ```ts\n    simnet.mineEmptyBlocks();\n\n    const response = simnet.blockHeight;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        2\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        mineEmptyBlocks(count?: number): number\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `runSnippet`\n\nExecute arbitrary Clarity code directly, which allows you to test and interact with smart contract functions without deploying them.\n\n## Parameters\n\nThe Clarity code snippet to be executed.\n\n<span>Example: `(define-read-only (get-balance) (ok stx-balance))`</span>\n\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Executing arbitrary Clarity code</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"transfer\" className='tab group'>\n      <Badge className='badge transition-colors'>Running a snippet for a STX transfer</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    import { Cl } from '@stacks/transactions';\n\n    const codeSnippet = simnet.runSnippet(\n      '(stx-account tx-sender)'\n    );\n\n    const response = Cl.prettyPrint(codeSnippet, 2);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          locked: u0,\n          unlock-height: u0,\n          unlocked: u100000000000000\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        runSnippet(snippet: string): string | ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"transfer\">\n    ```ts\n    import { cvToValue } from \"@stacks/transactions\";\n\n    const accounts = simnet.getAccounts();\n    const recipient = accounts.get(\"wallet_1\")!;\n\n    const codeSnippet = simnet.runSnippet(\n      `(stx-transfer? u19000000 tx-sender '${recipient})`\n    );\n\n    const response = cvToValue(codeSnippet);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          type: \"bool\",\n          value: true,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        runSnippet(snippet: string): string | ClarityValue\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `getContractsInterfaces`\n\nReturns the interfaces of the project contracts as a Map of Contracts, with the keys being the contract addresses.\n\nThese interfaces contain information such as the available `functions`, `data-vars`, `maps`, `NFTs`, and `FTs` defined in the contract.\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting a specific contract interface</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"filter\" className='tab group'>\n      <Badge className='badge transition-colors'>Filtering for contract functions</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const contractInterfaces = simnet.getContractsInterfaces();\n\n    const response = contractInterfaces.get(`${simnet.deployer}.pool`);\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          functions: [\n            {\n              name: \"get-participant\",\n              access: \"read_only\",\n              args: [\n                [Object ...]\n              ],\n              outputs: [Object ...],\n            }, {\n              name: \"is-active\",\n              access: \"read_only\",\n              args: [],\n              outputs: [Object ...],\n            }\n          ],\n          variables: [],\n          maps: [\n            {\n              name: \"ParticipantStatus\",\n              key: \"principal\",\n              value: [Object ...],\n            }, {\n              name: \"Participants\",\n              key: \"principal\",\n              value: \"bool\",\n            }\n          ],\n          fungible_tokens: [],\n          non_fungible_tokens: [],\n          epoch: \"Epoch25\",\n          clarity_version: \"Clarity2\",\n        }\n\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getContractsInterfaces(): Map<string, ContractInterface>\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n  <TabsContent value=\"filter\">\n    ```ts\n    const poolContract = contractInterfaces.get(`${simnet.deployer}.pool`);\n\n    const response = poolContract?.functions;\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```ts\n        [\n          {\n            name: \"get-participant\",\n            access: \"read_only\",\n            args: [\n              [Object ...]\n            ],\n            outputs: [Object ...],\n          }, {\n            name: \"is-active\",\n            access: \"read_only\",\n            args: [],\n            outputs: [Object ...],\n          }\n        ]\n\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getContractsInterfaces(): Map<string, ContractInterface>\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n\n# `getContractSource`\n\nGet the source code of a contract as a string.\n\n## Parameters\n\nThe identifier of the contract for which the source code is requested.\n\n<span>Example: `pool`</span>\n\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the source code of a contract</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const contractSource = simnet.getContractSource('pool');\n    ```\n\n    <Accordions>\n      <Accordion title=\"Source code\">\n        ```clarity pool.clar\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n        ```\n      </Accordion>\n      <Accordion title=\"Response\">\n        ```clarity\n        (define-map Participants principal bool)\n        (define-map ParticipantStatus principal { enrollmentBlock: uint, contributionAmount: uint })\n\n        (define-read-only (get-participant (who principal))\n          (map-get? ParticipantStatus who)\n        )\n\n        (define-read-only (is-active)\n          (map-get? Participants tx-sender)\n        )\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getContractSource(contract: string): string | undefined\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n\n# `getContractAST`\n\nGet the full AST (Abstract Syntax Tree) of a Clarity contract.\n\nThis method throws an error if it fails to get the AST or to encode it.\n\n## Parameters\n\nThe identifier of the contract for which the AST (Abstract Syntax Tree) is requested.\n\n<span>Example: `pool`</span>\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Getting the source code of a contract</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```ts\n    const contractAST = simnet.getContractAST('pool');\n    ```\n\n    <Accordions>\n      <Accordion title=\"Response\">\n        ```ts\n        {\n          contract_identifier: {\n            issuer: [ 26, [\n                109, 120, 222, 123, 6, 37, 223, 191, 193, 108, 58, 138, 87, 53, 246, 220,\n                61, 195, 242, 206\n              ] ],\n            name: \"pool\",\n          },\n          pre_expressions: [],\n          expressions: [\n            {\n              expr: [Object ...],\n              id: 1,\n              span: [Object ...],\n              pre_comments: [],\n              end_line_comment: undefined,\n              post_comments: [],\n            },\n            ...\n          ],\n          top_level_expression_sorting: [ 0, 1, 2, 3 ],\n          referenced_traits: Map {},\n          implemented_traits: [],\n          wasm_module: undefined,\n        }\n        ```\n      </Accordion>\n      <Accordion title=\"Schema\">\n        ```ts\n        getContractAST(contractId: string): ContractAST\n        ```\n      </Accordion>\n    </Accordions>\n  </TabsContent>\n</Tabs>\n\n"
  },
  {
    "title": "@hirosystems/clarinet-sdk",
    "description": "The main entry point for the Clarinet JS SDK. It provides properties and methods for interacting with the Clarinet network.",
    "slug": "/stacks/reference/clarinet-js-sdk/clarinet-sdk",
    "content": "\nimport {\n  Accordion,\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"@/components/ui/accordion\"\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\n# `initSimnet`\n\nThe `initSimnet` function initializes a simulated network. It will often be the first function you call when using the SDK.\n\n## Parameters\n\nThe `manifestPath` is the path to the `Clarinet.toml` manifest file.\n\n  <Tabs defaultValue=\"default\">\n    <TabsList className='flex flex-wrap'>\n      <TabsTrigger value=\"default\" className='tab group'>\n        <Badge className='transition-colors'>Creating a new instance of simnet</Badge>\n      </TabsTrigger>\n      <TabsTrigger value=\"custom\" className='tab group'>\n        <Badge className='badge transition-colors'>With a custom config path</Badge>\n      </TabsTrigger>\n    </TabsList>\n    <TabsContent value=\"default\">\n      ```ts\n      import { initSimnet } from '@hirosystems/clarinet-sdk';\n\n      const simnet = await initSimnet();\n      ```\n    </TabsContent>\n    <TabsContent value=\"custom\">\n      ```ts\n      import { initSimnet } from '@hirosystems/clarinet-sdk';\n\n      const simnet = await initSimnet('./config/Clarinet.toml');\n      ```\n    </TabsContent>\n  </Tabs>\n\n  <Accordion type=\"single\" collapsible className=\"w-full\">\n    <AccordionItem value=\"schema\">\n      <AccordionTrigger>Schema</AccordionTrigger>\n      <AccordionContent>\n        ```ts\n        initSimnet(manifestPath?: string): Promise<Simnet>\n        ```\n      </AccordionContent>\n    </AccordionItem>\n  </Accordion>"
  },
  {
    "title": "SDKs & Libraries",
    "description": "The following guides cover ways to use Hiro tools to build apps on Stacks.",
    "slug": "/stacks/reference/index",
    "content": "\nimport { Database, Ticket } from 'lucide-react';\nimport { Blockchain, BitcoinIcon, Clarinet, Container, DAO, Js, Plant, Shapes, StacksIcon } from '@/components/ui/icon';\nimport { SecondaryCard, SmallCard } from '@/components/card';\n\n<div className='flex flex-col space-y-10'>\n\n<Cards>\n  <SecondaryCard\n    icon={<Clarinet />}\n    href=\"/stacks/clarinet/quickstart\"\n    title=\"Create your first smart contract\"\n    description=\"Build a simple counter contract using Clarinet.\"\n    tag='Clarinet'\n  />\n  <SecondaryCard\n    icon={<Blockchain />}\n    href=\"/stacks/clarinet-js-sdk/quickstart\"\n    title=\"Write unit tests for your smart contracts\"\n    description=\"Learn how run unit tests with Clarinet JS SDK.\"\n    tag='Clarinet JS SDK'\n  />\n  <SecondaryCard\n    icon={<Js />}\n    href=\"/stacks/stacks.js/quickstart\"\n    title=\"Make a contract call with Stacks.js\"\n    description=\"Learn how to integrate smart contracts into your app.\"\n    tag='Stacks.js'\n  />\n  <SecondaryCard\n    icon={<Database />}\n    href=\"/stacks/chainhook/quickstart\"\n    title=\"Stream custom blockchain events\"\n    description=\"Use Chainhook to filter & stream for contract deployments.\"\n    tag='Chainhook'\n  />\n</Cards>\n\n<div className='flex flex-col'>\n\n<h4 id=\"learn-by-example\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#learn-by-example\" className=\"not-prose group text-sm uppercase\">Learn by example</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<Shapes />}\n    href=\"/guides/build-an-nft-marketplace\"\n    title=\"Build an NFT Marketplace\"\n    description=\"Learn how to create and deploy your own NFT marketplace.\"\n  />\n  {/* <SmallCard\n    icon={<DAO />}\n    href=\"/stacks/clarinet\"\n    title=\"Launch a Decentralized Autonomous Organization (DAO)\"\n    description=\"Discover the steps to creating your own DAO.\"\n  /> */}\n  <SmallCard\n    icon={<Ticket />}\n    href=\"/guides/no-loss-lottery\"\n    title=\"Create a no-loss lottery pool\"\n    description=\"Build a no-loss lottery pool that leverages stacking yield.\"\n  />\n  <SmallCard\n    icon={<Plant />}\n    href=\"/guides/build-a-decentralized-kickstarter\"\n    title=\"Build a decentralized Kickstarter\"\n    description=\"Learn how to create a crowdfunding app, enabling creators to fund their projects without a third party.\"\n  />\n</Cards>\n\n</div>\n\n<div className='flex flex-col'>\n\n<h4 id=\"installation-guides\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#installation-guides\" className=\"not-prose group text-sm uppercase\">Installation guides</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<BitcoinIcon />}\n    href=\"/guides/sync-a-bitcoin-node\"\n    title=\"Sync a Bitcoin node\"\n    description=\"Set up and run a Bitcoin node to run tools like Chainhook as a service.\"\n  />\n  <SmallCard\n    icon={<StacksIcon />}\n    href=\"/guides/sync-a-stacks-node\"\n    title=\"Sync a Stacks node\"\n    description=\"Set up and run a Stacks node to use tools like Chainhook or spin up your own API.\"\n  />\n  <SmallCard\n    icon={<Container />}\n    href=\"/guides/installing-docker\"\n    title=\"Install and run Docker on your machine\"\n    description=\"Essential for running a local development with Clarinet\"\n  />\n</Cards>\n\n</div>\n\n<Callout type=\"tip\">\nFor more, check out our [guides](/guides) section.\n</Callout>\n\n</div>\n"
  },
  {
    "title": "Clarinet CLI",
    "description": "The Clarinet CLI is a command-line tool for interacting with the Clarinet network.",
    "slug": "/stacks/reference/cli/clarinet",
    "content": ""
  },
  {
    "title": "Stacks.js CLI",
    "description": "The Stacks.js CLI is a command-line tool for creating new Stacks.js projects.",
    "slug": "/stacks/reference/cli/stacks-js",
    "content": "\n\n```package-install\ncreate stacks\n```"
  },
  {
    "title": "@stacks/blockchain-api-client",
    "description": "Interact with the Stacks blockchain using a JavaScript client library.",
    "slug": "/stacks/reference/stacks-blockchain-api/client",
    "content": "\nimport { Accordion, Accordions } from \"fumadocs-ui/components/accordion\";\nimport { Blocks, Braces, CircleUserRound } from 'lucide-react';\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\nThe `@stacks/blockchain-api-client` library provides a robust interface for interacting with the Stacks Blockchain API by offering type-safe methods to access REST and WebSocket endpoints.\n\nThe client includes automatically generated HTTP API methods, comprehensive Schemas for Clarity smart contract values, and a WebSocket client for real-time data streaming.\n\n```ts\nimport { AccountsApi } from '@stacks/blockchain-api-client';\n\nconst accounts = new AccountsApi(apiConfig);\n\nawait accounts.getAccountTransactions({\n  principal: 'ST000000000000000000002AMW42H',\n});\n```\n\n### Using WebSockets\n\n```ts\nimport { connectWebSocketClient } from '@stacks/blockchain-api-client';\nconst client = await connectWebSocketClient('ws://api.hiro.so/');\nconst sub = await client.subscribeAddressTransactions(contractCall.txId, event => {\n  console.log(event);\n});\n\nawait sub.unsubscribe();\n```\n"
  },
  {
    "title": "@stacks/connect",
    "description": "Connect is a JavaScript library for building web applications connected to Stacks.",
    "slug": "/stacks/reference/stacks.js/connect",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\n\nStacks Connect enables you to authenticate your users and connect your app to their wallet. This reference contains more detailed information on how you can authenticate users, sign and broadcast transactions on their behalf, and enable users to sign messages.\n\n<Callout title=\"Migration Note\">\nPlease be patient during the migration to version 8.x.x. There has been a long-running effort together with wallets to modernize the Stacks web ecosystem, culminating in [SIP-030](https://github.com/janniks/sips/blob/main/sips/sip-030/sip-030-wallet-interface.md) and the new `request` method in Stacks Connect 8.x.x. For the legacy version of `@stacks/connect` using JWT tokens, please use version 7.10.1. See the [Migration Guide](/docs/stacks/connect/guides/migration) for more details.\n</Callout>\n\n### Installation\n\n```package-install\n@stacks/connect\n```\n\n### Connect to a wallet\n\nInitiate a wallet connection and request addresses:\n\n```typescript\nimport { connect } from '@stacks/connect';\n\nconst response = await connect(); // stores users address in local storage by default\n```\n\nGet the local storage data (stored by a connect call):\n\n```typescript\nimport { getLocalStorage } from '@stacks/connect';\n\nconst data = getLocalStorage();\n// {\n//   \"addresses\": {\n//     \"stx\": [\n//       { \"address\": \"SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN\" },\n//     ],\n//     \"btc\": [\n//       { \"address\": \"bc1pp3ha248m0mnaevhp0txfxj5xaxmy03h0j7zuj2upg34mt7s7e32q7mdfae\" },\n//     ]\n//   }\n```\n\nManaging the connection state:\n\n```typescript\nimport { connect, disconnect, isConnected } from '@stacks/connect';\n\nisConnected(); // false\nawait connect(); // similar to the `getAddresses` method\nisConnected(); // true\ndisconnect(); // clears local storage and selected wallet\nisConnected(); // false\n```\n\n### Use request to trigger wallet interactions\n\n```typescript\nimport { request } from '@stacks/connect';\n\n// CONNECT\nconst response = await request({ forceWalletSelect: true }, 'getAddresses');\n```\n\n### Available methods\n\n- [getAddresses](#getaddresses)\n- [sendTransfer](#sendtransfer)\n- [signPsbt](#signpsbt)\n- [stx_getAddresses](#stx_getaddresses)\n- [stx_getAccounts](#stx_getaccounts)\n- [stx_transferStx](#stx_transferstx)\n- [stx_callContract](#stx_callcontract)\n- [stx_deployContract](#stx_deploycontract)\n- [stx_signMessage](#stx_signmessage)\n- [stx_signStructuredMessage](#stx_signstructuredmessage)\n\n#### getAddresses\n\n```typescript\nconst response = await request('getAddresses');\n// {\n//   \"addresses\": [\n//     {\n//       \"address\": \"bc1pp3ha248m0mnaevhp0txfxj5xaxmy03h0j7zuj2upg34mt7s7e32q7mdfae\",\n//       \"publicKey\": \"062bd2c825300d74f4f9feb6b2fec2590beac02b8938f0fc042a34254581ee69\",\n//     },\n//     {\n//       \"address\": \"bc1qtmqe7hg4etkq4t384nzg0mrmwf2sam9fjsz0mr\",\n//       \"publicKey\": \"025b65a0ec0e00699794847f2af1b5d8a53db02a2f48e09417598bef09cfea1114\",\n//     },\n//     {\n//       \"address\": \"SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN\",\n//       \"publicKey\": \"02d3331cbb9f72fe635e6f87c2cf1a13cdea520f08c0cc68584a96e8ac19d8d304\",\n//     }\n//   ]\n// }\n```\n\n#### sendTransfer\n\n```typescript\nconst response = await request('sendTransfer', {\n  recipients: [\n    {\n      address: 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4', // recipient address\n      amount: '1000', // amount in sats\n    },\n    // You can specify multiple recipients\n    {\n      address: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',\n      amount: '2000',\n    },\n  ],\n});\n// {\n//   \"txid\": \"0x1234...\", // The transaction ID\n// }\n```\n\n#### signPsbt\n\n```typescript\nconst response = await request('signPsbt', {\n  psbt: 'cHNidP...', // base64 encoded PSBT string\n  signInputs: [{ index: 0, address }], // indices of inputs to sign (optional)\n  broadcast: false, // whether to broadcast the transaction after signing (optional)\n});\n// {\n//   \"txid\": \"0x1234...\", // The transaction ID (if broadcast is true)\n//   \"psbt\": \"cHNidP...\" // The signed PSBT in base64 format\n// }\n```\n\n#### stx_getAddresses\n\n```typescript\nconst response = await request('stx_getAddresses');\n// {\n//   \"addresses\": [\n//     {\n//       \"address\": \"bc1pp3ha248m0mnaevhp0txfxj5xaxmy03h0j7zuj2upg34mt7s7e32q7mdfae\",\n//       \"publicKey\": \"062bd2c825300d74f4f9feb6b2fec2590beac02b8938f0fc042a34254581ee69\",\n//     },\n//     {\n//       \"address\": \"bc1qtmqe7hg4etkq4t384nzg0mrmwf2sam9fjsz0mr\",\n//       \"publicKey\": \"025b65a0ec0e00699794847f2af1b5d8a53db02a2f48e09417598bef09cfea1114\",\n//     },\n//     {\n//       \"address\": \"SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN\",\n//       \"publicKey\": \"02d3331cbb9f72fe635e6f87c2cf1a13cdea520f08c0cc68584a96e8ac19d8d304\",\n//     }\n//   ]\n// }\n```\n\n#### stx_getAccounts\n\n```typescript\nconst response = await request('stx_getAccounts');\n// {\n//   \"addresses\": [\n//     {\n//       \"address\": \"SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN\",\n//       \"publicKey\": \"02d3331cbb9f72fe635e6f87c2cf1a13cd...\",\n//       \"gaiaHubUrl\": \"https://hub.hiro.so\",\n//       \"gaiaAppKey\": \"0488ade4040658015580000000dc81e3a5...\"\n//     }\n//   ]\n// }\n```\n\n#### stx_transferStx\n\n```typescript\nconst response = await request('stx_transferStx', {\n  amount: '1000', // amount in micro-STX (1 STX = 1,000,000 micro-STX)\n  recipient: 'SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN', // recipient address\n  network: 'mainnet', // optional, defaults to mainnet\n  memo: 'Optional memo', // optional memo field\n});\n// {\n//   \"txid\": \"0x1234...\", // The transaction ID\n// }\n```\n\n#### stx_callContract\n\n```typescript\nconst response = await request('stx_callContract', {\n  contract: 'SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN.counters', // contract in format: address.contract-name\n  functionName: 'count', // name of the function to call\n  functionArgs: [Cl.int(3)], // array of Clarity values as arguments\n  network: 'mainnet', // optional, defaults to mainnet\n});\n// {\n//   \"txid\": \"0x1234...\", // The transaction ID\n// }\n```\n\n#### stx_deployContract\n\n```typescript\nconst response = await request('stx_deployContract', {\n  name: 'counters', // name of the contract\n  clarityCode: `(define-map counters principal int)\n\n(define-public (count (change int))\n  (ok (map-set counters tx-sender (+ (get-count tx-sender) change)))\n)\n\n(define-read-only (get-count (who principal))\n  (default-to 0 (map-get? counters who))\n)`, // Clarity code as string\n  clarityVersion: '2', // optional, defaults to latest version\n  network: 'mainnet', // optional, defaults to mainnet\n});\n// {\n//   \"txid\": \"0x1234...\", // The transaction ID\n// }\n```\n\n#### stx_signMessage\n\n```typescript\nconst response = await request('stx_signMessage', {\n  message: 'Hello, World!', // message to sign\n});\n// {\n//   \"signature\": \"0x1234...\", // The signature of the message\n//   \"publicKey\": \"02d3331cbb9f72fe635e6f87c2cf1a13cdea520f08c0cc68584a96e8ac19d8d304\" // The public key that signed the message\n// }\n```\n\n#### stx_signStructuredMessage\n\n```typescript\nconst clarityMessage = Cl.parse('{ structured: \"message\", num: u3 }');\nconst clarityDomain = Cl.tuple({\n  domain: Cl.stringAscii('example.com'),\n  version: Cl.stringAscii('1.0.0'),\n  'chain-id': Cl.uint(1),\n});\n\nconst response = await request('stx_signStructuredMessage', {\n  message: clarityMessage, // Clarity value representing the structured message\n  domain: clarityDomain, // domain object for SIP-018 style signing\n});\n// {\n//   \"signature\": \"0x1234...\", // The signature of the structured message\n//   \"publicKey\": \"02d3331cbb9f72fe635e6f87c2cf1a13cdea520f08c0cc68584a96e8ac19d8d304\" // The public key that signed the message\n// }\n```\n\n### Error Handling\n\nThe `request` method returns a Promise, allowing you to handle errors using standard Promise-based error handling patterns. You can use either `try/catch` with `async/await` or the `.catch()` method with Promise chains.\n\n#### Using try/catch with async/await\n\n```typescript\nimport { request } from '@stacks/connect';\n\ntry {\n  const response = await request('stx_transferStx', {\n    amount: '1000',\n    recipient: 'SP2MF04VAGYHGAZWGTEDW5VYCPDWWSY08Z1QFNDSN',\n  });\n  // SUCCESS\n  console.log('Transaction successful:', response.txid);\n} catch (error) {\n  // ERROR\n  console.error('Wallet returned an error:', error);\n}\n```\n\n### Compatibility\n\nThe `request` method by default adds a layer of auto-compatibility for different wallet providers. This is meant to unify the interface where wallet providers may not implement methods and results the same way.\n\n<Callout title=\"Wallet Support\">\nFor a complete list of wallet compatibility and support status, see the [Wallet Support](/docs/stacks/connect/support) page.\n</Callout>\n\n### Advanced Usage\n\n#### request\n\nThe `request` method is called with an optional options object as the first parameter:\n\n```typescript\nimport { request } from '@stacks/connect';\n\n// WITH options\nconst response = await request(\n  {\n    provider?: StacksProvider;        // Custom provider to use for the request\n\n    forceWalletSelect?: boolean;      // Force user to select a wallet (default: false)\n    persistWalletSelect?: boolean;     // Persist selected wallet (default: true)\n    enableOverrides?: boolean;         // Enable provider compatibility (default: true)\n    enableLocalStorage?: boolean;      // Store address in local storage (default: true)\n\n    defaultProviders?: WbipProvider[]; // Default wallets to display in modal\n    approvedProviderIds?: string[];    // List of approved provider IDs to show in modal\n  },\n  'method',\n  params\n);\n\n// WITHOUT options\nconst response = await request('method', params);\n```\n\n<Callout title=\"Provider Compatibility\">\nThe `enableOverrides` option enables automatic compatibility fixes for different wallet providers. For example, it handles converting numeric types between string and number formats as needed by different wallets, and remaps certain method names to match wallet-specific implementations. This ensures consistent behavior across different wallet providers without requiring manual adjustments.\n</Callout>\n\n<Callout title=\"Approved Providers\">\nThe `approvedProviderIds` option allows you to filter which wallet providers are shown in the connect modal. This is useful when you want to limit the available wallet options to specific providers. For example, you might only want to support Leather wallet:\n\n```typescript\nconnect({ approvedProviderIds: ['LeatherProvider'] });\n```\n\nOr multiple specific wallets:\n\n```typescript\nconnect({ approvedProviderIds: ['LeatherProvider', 'xverse'] });\n```\n</Callout>\n\n#### requestRaw\n\nThe `requestRaw` method provides direct access to wallet providers without the additional features of `request`:\n\n```typescript\nimport { requestRaw } from '@stacks/connect';\n\nconst response = await requestRaw(provider, 'method', params);\n```\n\n<Callout title=\"Raw Request\">\n`requestRaw` bypasses the UI wallet selector, automatic provider compatibility fixes, and other features that come with `request`. Use this when you need more manual control over the wallet interaction process.\n</Callout>\n"
  },
  {
    "title": "sbtc",
    "description": "A JS/TS helper package for interacting with sBTC.",
    "slug": "/stacks/reference/stacks.js/sbtc",
    "content": "\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\nimport { Callout } from \"@/components/callout\";\n\n\n## Installation\n\n```package-install\nsbtc\n```\n\n## Architecture\n\nThe sBTC protocol operates across multiple layers:\n\n- **Bitcoin**: The original funds are sourced from Bitcoin. A depositor sends these funds to a group of signers, which manage a (rotating) multisignature address formatted for sBTC transactions.\n\n- **sBTC API (Emily)**: This API is responsible for tracking deposits and notifying the signers about pending deposits.\n\n- **Stacks**: The network where sBTC is minted. Once the deposit is confirmed, the signers mint the corresponding amount of sBTC to the depositor's specified address on the Stacks network.\n\n## Deposit Flow\n\n- **Create Deposit (Bitcoin) Transaction**:\n  - Structure a Bitcoin transaction to send funds to the group of signers.\n  - Use a specialized format that includes:\n    - Deposit Script: Identifies which Stacks address the sBTC will be minted to and what the maximum fee (in satoshis) the signers may take in exchange for minting.\n    - Reclaim Script: Allows the sender to reclaim their funds if the transaction is not processed by the signers.\n\n- **Sign and Broadcast the Transaction**:\n  - Sign the transaction with the sender's private key.\n  - Broadcast the transaction to the Bitcoin network (Bitcoin Regtest for Stacks Testnet).\n\n- **Notify the sBTC API (Emily)**:\n  - Inform the API about the transaction by submitting its details. This step ensures that the signers are aware of the deposit and can track it.\n\n- **Processing by Signers**: (no action required)\n  - The signers retrieve and verify the deposit transaction from the Bitcoin blockchain.\n  - Once verified, the signers mint the equivalent amount of sBTC on the Stacks network.\n\n- **Receive sBTC (Stacks)**: (no action required)\n  - The minted sBTC is sent to the depositor's designated Stacks address, completing the deposit process.\n  - sBTC is SIP-010 compatible and will show up in Stacks wallets and explorers.\n\n## Withdrawal Flow\n_Coming soon_\n\n## sBTC Package Functions\n\nThe sBTC package exports high-level functions for building addresses and transactions for deposits.\n\n### Examples\n\n  \n#### buildSbtcDepositAddress\nBuild a deposit address and metadata using `buildSbtcDepositAddress` with a wallet provider using `sendTransfer`.\n\n```ts\nimport { buildSbtcDepositAddress, SbtcApiClientTestnet } from 'sbtc';\n\nconst client = new SbtcApiClientTestnet();\n\n// 1. BUILD THE DEPOSIT ADDRESS AND METADATA\nconst deposit = buildSbtcDepositAddress({\n  stacksAddress: TARGET_STX_ADDRESS,\n  signersPublicKey: await client.fetchSignersPublicKey(),\n\n  // OPTIONAL DEFAULTS\n  // maxSignerFee: 80_000, // optional: fee to pay for the deposit transaction (taken from the signers from the sats)\n  // reclaimLockTime: 6_000, // optional: lock time for the reclaim script\n  // network: REGTEST, // optional: which bitcoin network to use\n});\n\n// `deposit.address` is the deposit address (send funds here, aka the deposit address as an output)\n\n// 2. DEPOSIT USING YOUR FAVORITE WALLET (TYPICALLY ALSO BROADCASTED BY THE WALLET)\nconst txid = await WalletProvider.sendTransfer({\n  recipient: deposit.address,\n  amount: 100_000, // the amount to deposit; <=maxSignerFee is taken from this amount\n});\n\n// 3. NOTIFY THE SIGNERS\nawait client.notifySbtc({ txid, ...deposit });\n```\n\n#### buildSbtcDepositTx\nThe `buildSbtcDepositTx` function is similar to `buildSbtcDepositAddress`, but instead of returning just a deposit address, it constructs a complete Bitcoin transaction for depositing sBTC.\n\n```ts\nimport { buildSbtcDepositTx } from 'sbtc';\n\n// 1. BUILD THE DEPOSIT TRANSACTION AND METADATA\nconst deposit = buildSbtcDepositTx({\n  amountSats: DEPOSIT_AMOUNT, // the amount in sats/sBTC to deposit; <=maxSignerFee is taken from this amount\n\n  // same options as `buildSbtcDepositAddress`\n  network,\n  stacksAddress,\n  signersPublicKey,\n  maxSignerFee,\n  reclaimLockTime,\n});\n\n// `deposit.transaction` has one output, which is the combined taproot of the deposit and reclaim scripts\n\n// 2. SIGN THE TRANSACTION\ndeposit.transaction.sign(YOUR_BTC_PRIVATE_KEY);\ndeposit.transaction.finalize();\n\n// 2. OR SIGN VIA EXTERNAL WALLET\nconst psbtBytes = deposit.transaction.toPSBT();\n\n// 3. BROADCAST THE TRANSACTION\nconst txid = await client.broadcastTx(deposit.transaction);\n\n// 4. NOTIFY THE SIGNERS\nawait client.notifySbtc(deposit);\n```\n\n\n#### sbtcDepositHelper\nCreate a fully-formed deposit transaction (assuming an address with spendable bitcoin UTXOs)\n\n<Callout>Use this helper function if you are not using a wallet provider</Callout>\n\n```ts\nimport { sbtcDepositHelper, SbtcApiClientTestnet } from 'sbtc';\n\nconst client = new SbtcApiClientTestnet();\n\n// 1. BUILD THE DEPOSIT TRANSACTION AND METADATA (GIVEN UTXOS FOR AN ADDRESS)\nconst deposit = await sbtcDepositHelper({\n  stacksAddress: TARGET_STX_ADDRESS, // where to send/mint the sBTC\n  amountSats: 5_000_000, // (maximum) amount of sBTC to deposit\n\n  signersPublicKey: pub, // the aggregated public key of the signers\n\n  feeRate: await client.fetchFeeRate('medium'),\n  utxos: await client.fetchUtxos(YOUR_BTC_ADDRESS),\n\n  bitcoinChangeAddress: YOUR_BTC_ADDRESS,\n});\n\n// 2. SIGN THE TRANSACTION\ndeposit.transaction.sign(YOUR_BTC_PRIVATE_KEY);\ndeposit.transaction.finalize();\n\n// 2. OR SIGN VIA EXTERNAL WALLET\nconst psbtBytes = deposit.transaction.toPSBT();\n\n// 3. BROADCAST TRANSACTION\nconst txid = await client.broadcastTx(deposit.transaction);\nconsole.log('txid', txid);\n\n// 4. NOTIFY THE SIGNERS\nconst res = await client.notifySbtc(deposit);\nconsole.log('res', res.status, res.statusMessage);\n```\n\n\n## HTTP Clients\n\nAdditionally, there are two API helpers, which make it easier to get all the data needed to create the above transactions:\n\n- **SbtcApiClientMainnet** — a client for communicating with the different pieces of the sBTC deployment\n- **SbtcApiClientTestnet** — a client for communicating with the different pieces of the sBTC deployment on Testnet\n- **SbtcApiClientDevenv** — a client for developing against a local deployment of sBTC\n\nWhile the final adjustments are still being made in the pre-release phase, this package may change default URLs and contract addresses on every minor release.\n\n| Version | Purpose | Functionality |\n| --- | --- | --- |\n| 0.1.x | Developer release (hackathon) | |\n| 0.2.x | Regtest/Testnet release | Deposit only |\n| 0.3.x | Mainnet pre-release | Deposit only |\n\n### Examples\n\n```ts\nimport { SbtcApiClientMainnet, SbtcApiClientTestnet, SbtcApiClientDevenv } from 'sbtc';\n\nconst client = new SbtcApiClientMainnet();\n// const client = new SbtcApiClientTestnet();\n// const client = new SbtcApiClientDevenv();\n\nconst pub = await client.fetchSignersPublicKey(); // fetches the aggregated public key of the signers\nconst address = await client.fetchSignersAddress(); // fetches the p2tr address of the aggregated public key of the signers\n\nconst feeRate = await client.fetchFeeRate('low'); // or 'medium', 'high'\nconst unspents = await client.fetchUtxos(BTC_ADDRESS);\nconst hex = await client.fetchTxHex(TXID);\n\nawait client.broadcastTx(DEPOSIT_BTC_TX); // broadcast a deposit BTC transaction\nawait client.notifySbtc(DEPOSIT_BTC_TX); // notify the sBTC API about the deposit (otherwise it won't be processed)\n\nconst sbtcBalance = await client.fetchSbtcBalance(STX_ADDRESS); // fetch the sBTC balance of an Stacks address\n```\n\n## API Reference\n\n### sbtcDepositHelper\n\n| Parameter | Description | Type | Default |\n| --- | --- | --- | --- |\n| signersPublicKey | Signers public key (aggregated schnorr) | string 32 byte hex | — |\n| amountSats | Bitcoin amount denominated in sats (* 10^8) | number, bigint | — |\n| stacksAddress | The deposit recipient Stacks address | string | — |\n| bitcoinChangeAddress | Bitcoin change address | string | — |\n| feeRate | Fee rate in sat/vbyte | number | — |\n| utxos | UTXOs to \"fund\" the transaction | UtxoWithTx[] | — |\n| reclaimPublicKey | Public key (schnorr, x-only) for reclaiming failed deposits | string | — |\n| reclaimLockTime | Optional reclaim lock time | number | 144 |\n| maxSignerFee | Optional maximum fee to pay to signers for the sBTC mint | number | 80_000 |\n| network | Optional Bitcoin network | BitcoinNetwork | MAINNET |\n| utxoToSpendable | Optional function to convert p2wpk and p2sh utxos to spendable inputs | Function | Best effort default implementation to make utxos spendable |\n| paymentPublicKey | Optional payment public key (currently only used for default utxoToSpendable.sh implementation) | string hex | — |\n\n### SbtcApiClient Configuration\n\n| Parameter | Description | Type |\n| --- | --- | --- |\n| sbtcContract | The multisig address of the initial sBTC contract | string |\n| sbtcApiUrl | The base URL of the sBTC API (Emily) | string |\n| btcApiUrl | The base URL of the Bitcoin mempool/electrs API | string |\n| stxApiUrl | The base URL of the Stacks API | string |\n"
  },
  {
    "title": "@stacks/transactions",
    "description": "Construct, decode transactions and work with Clarity smart contracts on the Stacks blockchain.",
    "slug": "/stacks/reference/stacks.js/transactions",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\n\n<Callout type=\"info\">\nThis reference refers to the `7.x.x` release of Stacks.js—it's the recommended version to use, but not needed for the Stacks Nakamoto release.\nRead the [migration guide](https://github.com/hirosystems/stacks.js/blob/main/.github/MIGRATION.md#stacksjs-5xx--7xx) to learn how to update to the latest version.\n</Callout>\n\n## Installation\n\n```package-install\n@stacks/transactions\n```\n\nThis library supports the creation of the following Stacks transaction types:\n\n1. STX token transfer\n2. Smart contract deploy\n3. Smart contract function call\n\n## Key Generation\n\n```typescript -n\nimport { randomPrivateKey, privateKeyToPublicKey } from '@stacks/transactions';\n\n// Random key\nconst privateKey = randomPrivateKey();\nconst publicKey = privateKeyToPublicKey(privateKey);\n\n// Private key from hex string\nconst privateKey = 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01';\n```\n\n## STX Token Transfer Transaction\n\nUse the [`makeSTXTokenTransfer`](https://stacks.js.org/functions/_stacks_transactions.makeSTXTokenTransfer) (with a sender private key), or the \"unsigned\" version [`makeUnsignedSTXTokenTransfer`](https://stacks.js.org/functions/_stacks_transactions.makeUnsignedSTXTokenTransfer) (with a sender public key, without yet signing) to create a STX token transfer transaction.\n\n```ts -n\nimport { makeSTXTokenTransfer, broadcastTransaction } from '@stacks/transactions';\n\nconst txOptions = {\n  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',\n  amount: 12345n,\n  memo: 'test memo',\n\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  network: 'testnet', // for mainnet, use 'mainnet'\n};\n\nconst transaction = await makeSTXTokenTransfer(txOptions);\n\n// to see the raw serialized tx\nconst serializedTx = transaction.serialize(); // hex string\n\n// broadcast to the network\nconst response = await broadcastTransaction({ transaction, network: 'testnet' });\nconsole.log(response.txid);\n```\n\n## Smart Contract Deploy Transaction\n\nUse the [`makeContractDeploy`](https://stacks.js.org/functions/_stacks_transactions.makeContractDeploy), or the \"unsigned\" version [`makeUnsignedContractDeploy`](https://stacks.js.org/functions/_stacks_transactions.makeUnsignedContractDeploy) to create a smart contract deploy transaction.\n\n```ts -n\nimport { makeContractDeploy, broadcastTransaction } from '@stacks/transactions';\nimport { readFileSync } from 'fs';\n\nconst clarityCode = readFileSync('/path/to/contract.clar').toString();\n\nconst txOptions = {\n  contractName: 'contract_name',\n  codeBody: clarityCode,\n  clarityVersion: 3, // optional, defaults to latest deployed version\n\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  network: 'testnet', // for mainnet, use 'mainnet'\n};\n\nconst transaction = await makeContractDeploy(txOptions);\n\n// broadcast to the network\nconst response = await broadcastTransaction({ transaction, network: 'testnet' });\nconsole.log(response.txid);\n```\n\n## Smart Contract Function Call (On-chain)\n\nIf you want to call a readonly function, use [`fetchCallReadOnlyFunction`](https://stacks.js.org/functions/_stacks_transactions.fetchCallReadOnlyFunction) instead.\n\nUse the [`makeContractCall`](https://stacks.js.org/functions/_stacks_transactions.makeContractCall) or the \"unsigned\" version [`makeUnsignedContractCall`](https://stacks.js.org/functions/_stacks_transactions.makeUnsignedContractCall) to create a smart contract function call transaction.\n\n```ts -n\nimport { makeContractCall, broadcastTransaction, Cl, Pc } from '@stacks/transactions';\n\n// Add an optional post condition\nconst condition01 = Pc.principal('SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE')\n  .willSendGte(1000000n)\n  .ustx();\n\nconst txOptions = {\n  contractAddress: 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X',\n  contractName: 'contract_name',\n  functionName: 'contract_function',\n  functionArgs: [Cl.bufferFromUtf8('foo string')],\n  postConditions: [condition01],\n\n  validateWithAbi: true, // check if the arguments given are compatible with the function\n\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  network: 'testnet', // for mainnet, use 'mainnet'\n};\n\nconst transaction = await makeContractCall(txOptions);\n\n// broadcast to the network\nconst response = await broadcastTransaction({ transaction, network: 'testnet' });\nconsole.log(response.txid);\n```\n\nIn this example we construct a `contract-call` transaction with a post condition. We have set the `validateWithAbi` option to `true`, so the `makeContractCall` builder will attempt to fetch this contracts ABI from the specified Stacks network, and validate that the provided functionArgs match what is described in the ABI. This should help you avoid constructing invalid contract-call transactions. If you would prefer to provide your own ABI instead of fetching it from the network, the `validateWithAbi` option also accepts [ClarityABI](https://stacks.js.org/interfaces/_stacks_transactions.ClarityAbi) objects.\n\n## Sponsoring Transactions\n\nTo generate a sponsored transaction, first create and sign the transaction as the origin. The `sponsored` property in the options object must be set to true.\n\n```ts -n\nimport { makeContractCall, Cl } from '@stacks/transactions';\n\nconst txOptions = {\n  contractAddress: 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X',\n  contractName: 'contract_name',\n  functionName: 'contract_function',\n  functionArgs: [Cl.bufferFromUtf8('foo string')],\n  validateWithAbi: true,\n\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  network: 'testnet', // for mainnet, use 'mainnet'\n  sponsored: true,\n};\n\nconst transaction = await makeContractCall(txOptions);\nconst serializedTx = transaction.serialize();\n\n// can't broadcast sponsored transactions before they are sponsored\n```\n\nThe serialized transaction can now be passed to the sponsoring party which will sign the sponsor portion of the transaction and set the fee.\n\n```ts -n\nimport { sponsorTransaction, broadcastTransaction } from '@stacks/transactions';\n\nconst deserializedTx = deserializeTransaction(serializedTx);\nconst sponsorKey = '770287b9471081c8acd37d57190c7a70f0da2633311cc120853537362d32e67c01';\nconst fee = 1000n;\n\nconst sponsorOptions = {\n  transaction: deserializedTx,\n  sponsorPrivateKey: sponsorKey,\n  sponsorNonce: 0,\n  fee,\n};\n\nconst sponsoredTx = await sponsorTransaction(sponsorOptions);\n\n// broadcast to the network\nconst response = await broadcastTransaction({ transaction: sponsoredTx, network: 'testnet' });\nconsole.log(response.txid);\n```\n\n## Supporting multi-signature transactions\n\nTo generate a multi-sig transaction, first create an unsigned transaction.\nThe `numSignatures` and `publicKeys` properties in the options object must be set:\n\n```ts -n\nimport {\n  makeUnsignedSTXTokenTransfer,\n  createStacksPrivateKey,\n  deserializeTransaction,\n  pubKeyfromPrivKey,\n  publicKeyToString,\n  TransactionSigner,\n  standardPrincipalCV,\n  BytesReader,\n  AnchorMode,\n} from '@stacks/transactions';\n\nconst recipient = standardPrincipalCV('SP3FGQ8...');\nconst amount = 2500000n;\nconst fee = 0n;\nconst memo = 'test memo';\n\n// private keys of the participants in the transaction\nconst privKeyStrings = ['6d430bb9...', '2a584d89...', 'd5200dee...'];\n\n// create private key objects from string array\nconst privKeys = privKeyStrings.map(createStacksPrivateKey);\n\n// corresponding public keys\nconst pubKeys = privKeyStrings.map(pubKeyfromPrivKey);\n\n// create public key string array from objects\nconst pubKeyStrings = pubKeys.map(publicKeyToString);\n\nconst transaction = await makeUnsignedSTXTokenTransfer({\n  recipient,\n  amount,\n  fee,\n  memo,\n  numSignatures: 2, // number of signature required\n  publicKeys: pubKeyStrings, // public key string array with >= numSignatures elements\n  anchorMode: AnchorMode.Any,\n});\n\nconst serializedTx = transaction.serialize();\n```\n\nThis transaction payload can be passed along to other participants to sign. In addition to\nmeeting the numSignatures requirement, the public keys of the parties who did not sign the\ntransaction must be appended to the signature.\n\n```ts -n\n// deserialize and sign transaction\nconst bytesReader = new BytesReader(serializedTx);\n// Partially signed or unsigned multi-sig tx can be deserialized to add the required signatures\nconst deserializedTx = deserializeTransaction(bytesReader);\n\nconst signer = new TransactionSigner(deserializedTx);\n\n// first signature\nsigner.signOrigin(privKeys[0]);\n\n// second signature\nsigner.signOrigin(privKeys[1]);\n\n// after meeting the numSignatures requirement, the public\n// keys of the participants who did not sign must be appended\nsigner.appendOrigin(pubKeys[2]);\n\n// the serialized multi-sig tx\nconst serializedSignedTx = deserializedTx.serialize();\n```\n\n## Calling Read-only Contract Functions\n\nRead-only contract functions can be called without generating or broadcasting a transaction. Instead it works via a direct API call to a Stacks node.\n\n```ts -n\nimport { bufferCVFromString, callReadOnlyFunction } from '@stacks/transactions';\nimport { StacksTestnet } from '@stacks/network';\n\nconst contractAddress = 'ST3KC0MTNW34S1ZXD36JYKFD3JJMWA01M55DSJ4JE';\nconst contractName = 'kv-store';\nconst functionName = 'get-value';\nconst buffer = bufferCVFromString('foo');\nconst network = new StacksTestnet();\nconst senderAddress = 'ST2F4BK4GZH6YFBNHYDDGN4T1RKBA7DA1BJZPJEJJ';\n\nconst options = {\n  contractAddress,\n  contractName,\n  functionName,\n  functionArgs: [buffer],\n  network,\n  senderAddress,\n};\n\nconst result = await callReadOnlyFunction(options);\n```\n\n## Constructing Clarity Values\n\nBuilding transactions that call functions in deployed clarity contracts requires you to construct valid Clarity Values to pass to the function as arguments. The [Clarity type system](https://github.com/stacksgov/sips/blob/master/sip/sip-002-smart-contract-language.md#clarity-type-system) contains the following types:\n\n- `(tuple (key-name-0 key-type-0) (key-name-1 key-type-1) ...)` : a typed tuple with named fields.\n- `(list max-len entry-type)` : a list of maximum length max-len, with entries of type entry-type\n- `(response ok-type err-type)` : object used by public functions to commit their changes or abort. May be returned or used by other functions as well, however, only public functions have the commit/abort behavior.\n- `(optional some-type)` : an option type for objects that can either be (some value) or none\n- `(buff max-len)` : byte buffer or maximum length max-len.\n- `principal` : object representing a principal (whether a contract principal or standard principal).\n- `bool` : boolean value (`true` or `false`)\n- `int` : signed 128-bit integer\n- `uint`: unsigned 128-bit integer\n\nThis library contains Typescript types and classes that map to the Clarity types, in order to make it easy to construct well-typed Clarity values in Javascript. These types all extend the abstract class `ClarityValue`.\n\n```ts -n\nimport {\n  trueCV,\n  falseCV,\n  noneCV,\n  someCV,\n  intCV,\n  uintCV,\n  standardPrincipalCV,\n  contractPrincipalCV,\n  responseErrorCV,\n  responseOkCV,\n  listCV,\n  tupleCV,\n  bufferCV,\n} from '@stacks/transactions';\nimport { utf8ToBytes } from '@stacks/common';\n\n// construct boolean clarity values\nconst t = trueCV();\nconst f = falseCV();\n\n// construct optional clarity values\nconst nothing = noneCV();\nconst something = someCV(t);\n\n// construct a buffer clarity value from an existing byte array\nconst bytes = utf8ToBytes('foo'); // Uint8Array(3) [ 102, 111, 111 ]\nconst bufCV = bufferCV(bytes);\n\n// construct signed and unsigned integer clarity values\nconst i = intCV(-10);\nconst u = uintCV(10);\n\n// construct principal clarity values\nconst address = 'SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B';\nconst contractName = 'contract-name';\nconst spCV = standardPrincipalCV(address);\nconst cpCV = contractPrincipalCV(address, contractName);\n\n// construct response clarity values\nconst errCV = responseErrorCV(trueCV());\nconst okCV = responseOkCV(falseCV());\n\n// construct tuple clarity values\nconst tupCV = tupleCV({\n  a: intCV(1),\n  b: trueCV(),\n  c: falseCV(),\n});\n\n// construct list clarity values\nconst l = listCV([trueCV(), falseCV()]);\n```\n\nIf you develop in Typescript, the type checker can help prevent you from creating wrongly-typed Clarity values. For example, the following code won't compile since in Clarity lists are homogeneous, meaning they can only contain values of a single type. It is important to include the type variable `BooleanCV` in this example, otherwise the typescript type checker won't know which type the list is of and won't enforce homogeneity.\n\n```ts -n\nconst l = listCV<BooleanCV>([trueCV(), intCV(1)]);\n```\n\n## Post Conditions\n\nThree types of post conditions can be added to transactions:\n\n1. STX post condition\n2. Fungible token post condition\n3. Non-Fungible token post condition\n\nFor details see: https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-post-conditions\n\n## STX post condition\n\n```ts -n\nimport {\n  FungibleConditionCode,\n  makeStandardSTXPostCondition,\n  makeContractSTXPostCondition,\n} from '@stacks/transactions';\n\n// With a standard principal\nconst postConditionAddress = 'SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE';\nconst postConditionCode = FungibleConditionCode.GreaterEqual;\nconst postConditionAmount = 12345n;\n\nconst standardSTXPostCondition = makeStandardSTXPostCondition(\n  postConditionAddress,\n  postConditionCode,\n  postConditionAmount\n);\n\n// With a contract principal\nconst contractAddress = 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X';\nconst contractName = 'test-contract';\n\nconst contractSTXPostCondition = makeContractSTXPostCondition(\n  contractAddress,\n  contractName,\n  postConditionCode,\n  postConditionAmount\n);\n```\n\n## Fungible token post condition\n\n```ts -n\nimport {\n  FungibleConditionCode,\n  createAssetInfo,\n  makeStandardFungiblePostCondition,\n} from '@stacks/transactions';\n\n// With a standard principal\nconst postConditionAddress = 'SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE';\nconst postConditionCode = FungibleConditionCode.GreaterEqual;\nconst postConditionAmount = 12345n;\nconst assetAddress = 'SP62M8MEFH32WGSB7XSF9WJZD7TQB48VQB5ANWSJ';\nconst assetContractName = 'test-asset-contract';\nconst assetName = 'test-token';\nconst fungibleAssetInfo = createAssetInfo(assetAddress, assetContractName, assetName);\n\nconst standardFungiblePostCondition = makeStandardFungiblePostCondition(\n  postConditionAddress,\n  postConditionCode,\n  postConditionAmount,\n  fungibleAssetInfo\n);\n\n// With a contract principal\nconst contractAddress = 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X';\nconst contractName = 'test-contract';\nconst assetAddress = 'SP62M8MEFH32WGSB7XSF9WJZD7TQB48VQB5ANWSJ';\nconst assetContractName = 'test-asset-contract';\nconst assetName = 'test-token';\nconst fungibleAssetInfo = createAssetInfo(assetAddress, assetContractName, assetName);\n\nconst contractFungiblePostCondition = makeContractFungiblePostCondition(\n  contractAddress,\n  contractName,\n  postConditionCode,\n  postConditionAmount,\n  fungibleAssetInfo\n);\n```\n\n## Non-fungible token post condition\n\n> **Warning**\n> The Stacks blockchain's post-condition processor can NOT check ownership.\n> It checks whether or not a principal **will send** or **will not send** an NFT.\n> Post-conditions can NOT verify anything about the recipient of an asset.\n> If you want to verify conditions about asset recipients, you will need to use [Clarity](https://docs.stacks.co/docs/write-smart-contracts/).\n\n```ts -n\nimport {\n  NonFungibleConditionCode,\n  createAssetInfo,\n  makeStandardNonFungiblePostCondition,\n  makeContractNonFungiblePostCondition,\n  bufferCVFromString,\n} from '@stacks/transactions';\n\n// With a standard principal\nconst postConditionAddress = 'SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE';\nconst postConditionCode = NonFungibleConditionCode.DoesNotSend;\nconst assetAddress = 'SP62M8MEFH32WGSB7XSF9WJZD7TQB48VQB5ANWSJ';\nconst assetContractName = 'test-asset-contract';\nconst assetName = 'test-asset';\nconst assetId = bufferCVFromString('test-token-asset-id');\nconst nonFungibleAssetInfo = createAssetInfo(assetAddress, assetContractName, assetName);\n\nconst standardNonFungiblePostCondition = makeStandardNonFungiblePostCondition(\n  postConditionAddress,\n  postConditionCode,\n  nonFungibleAssetInfo,\n  assetId\n);\n\n// With a contract principal\nconst contractAddress = 'SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X';\nconst contractName = 'test-contract';\n\nconst contractNonFungiblePostCondition = makeContractNonFungiblePostCondition(\n  contractAddress,\n  contractName,\n  postConditionCode,\n  nonFungibleAssetInfo,\n  assetId\n);\n```\n\n## Conversion of Clarity Values to JSON\n\nClarity Values represent values of Clarity contracts. If a JSON format is required the helper function `cvToJSON` can be used.\n\n```ts -n\nimport { cvToJSON, hexToCV } from '@stacks/transactions';\n\ncvToJSON(hexToCV(tx.tx_result.hex));\n```\n"
  },
  {
    "title": "@stacks/network",
    "description": "Network and API library for working with Stacks blockchain nodes.",
    "slug": "/stacks/reference/stacks.js/network",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\nimport { Callout } from \"@/components/callout\";\n\n<Callout type=\"info\">\nThis reference refers to the `7.x.x` release of Stacks.js—it's the recommended version to use, but not needed for the Stacks Nakamoto release.\nRead the [migration guide](https://github.com/hirosystems/stacks.js/blob/main/.github/MIGRATION.md#stacksjs-5xx--7xx) to learn how to update to the latest version.\n</Callout>\n\nThe `@stacks/network` package contains default network configurations for Stacks.\n\n## Installation\n\n<Callout type=\"tip\">\nBefore you install: most of the time you don't need to use or even install this library directly.\nFor example, instead of `STACKS_MAINNET`, simply use the string `\"mainnet\"` as the network parameter.\n</Callout>\n\n```package-install\n@stacks/network@latest\n```\n\n## Usage\n\n## The network object\n\nA network in Stacks.js is an object defining several properties.\n\n```ts\nimport { STACKS_MAINNET, STACKS_TESTNET, STACKS_DEVNET } from '@stacks/network';\n\nconsole.log(STACKS_MAINNET);\n// {\n//   chainId: 1,\n//   transactionVersion: 0,\n//   peerNetworkId: 385875968,\n//   magicBytes: 'X2',\n//   bootAddress: 'SP000000000000000000002Q6VF78',\n//   addressVersion: { singleSig: 22, multiSig: 20 }\n// }\n```\n\n## Network usage in transaction building\n\n```ts\nimport { STACKS_MAINNET } from '@stacks/network';\nimport { makeSTXTokenTransfer } from '@stacks/transactions';\n\nconst txOptions = {\n  recipient: 'SP2BS6HD7TN34V8Z5BNF8Q2AW3K8K2DPV4264CF26',\n  amount: 100,\n  // ...\n  network: 'mainnet', // 'mainnet', 'testnet', or 'devnet', (defaults to mainnet)\n  // OR\n  network: STACKS_MAINNET, // any compatible network object\n};\n\nconst transaction = await makeSTXTokenTransfer(txOptions);\n```\n"
  },
  {
    "title": "@stacks/common",
    "description": "Common utilities for working with Stacks.",
    "slug": "/stacks/reference/stacks.js/common",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\nimport { Callout } from \"@/components/callout\";\n\n<Callout type=\"info\">\nThis reference refers to the `7.x.x` release of Stacks.js—it's the recommended version to use, but not needed for the Stacks Nakamoto release.\nRead the [migration guide](https://github.com/hirosystems/stacks.js/blob/main/.github/MIGRATION.md#stacksjs-5xx--7xx) to learn how to update to the latest version.\n</Callout>\n\nThe `@stacks/common` package contains common utilities for working with Stacks.\nThis includes fetch helpers, middleware, and various other functions.\n\n## Installation\n\n```package-install\n@stacks/common@latest\n```\n\n\n## Use the built-in API key middleware\n\nSome Stacks APIs make use API keys to provide less rate-limited plans.\n\n```typescript\nimport { createApiKeyMiddleware, createFetchFn, StacksMainnet } from '@stacks/network';\nimport { broadcastTransaction, getNonce, makeSTXTokenTransfer } from '@stacks/transactions';\n\nconst myApiMiddleware = createApiKeyMiddleware('example_e8e044a3_41d8b0fe_3dd3988ef302');\nconst myFetchFn = createFetchFn(myApiMiddleware); // middlewares can be used to create a new fetch function\n\nconst txOptions = {\n  recipient: 'SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159',\n  amount: 12345n,\n  senderKey: 'b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01',\n  memo: 'some memo',\n  anchorMode: AnchorMode.Any,\n  client: {\n    fetch: myFetchFn,\n  }\n};\nconst transaction = await makeSTXTokenTransfer(txOptions); // fee-estimation will use the custom fetchFn\n\nconst response = await broadcastTransaction(transaction, myMainnet); // make sure to broadcast via the custom network object\n\n// stacks.js functions, which take a StacksNetwork object will use the custom fetchFn\nconst nonce = await getNonce('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159', myMainnet);\n```\n\n## Use custom middleware\n\nMiddleware can be used to hook into network calls before sending a request or after receiving a response.\n\n```typescript\nimport { createFetchFn, RequestContext, ResponseContext } from '@stacks/common';\n\nconst preMiddleware = (ctx: RequestContext) => {\n  ctx.init.headers = new Headers();\n  ctx.init.headers.set('x-foo', 'bar'); // override headers and set new `x-foo` header\n};\nconst postMiddleware = (ctx: ResponseContext) => {\n  console.log(await ctx.response.json()); // log response body as json\n};\n\nconst fetchFn = createFetchFn({ pre: preMiddleware, post: preMiddleware }); // a middleware can contain `pre`, `post`, or both\nconst network = new StacksTestnet({ fetchFn });\n\n// stacks.js functions, which take a StacksNetwork object will use the custom fetchFn\nconst nonce = await getNonce('SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159', network);\n```\n\n## Get various API URLs\n\n```typescript\nconst txBroadcastUrl = network.getBroadcastApiUrl();\n\nconst feeEstimateUrl = network.getTransferFeeEstimateApiUrl();\n\nconst address = 'SP2BS6HD7TN34V8Z5BNF8Q2AW3K8K2DPV4264CF26';\nconst accountInfoUrl = network.getAccountApiUrl(address);\n\nconst contractName = 'hello_world';\nconst abiUrl = network.getAbiApiUrl(address, contractName);\n\nconst functionName = 'hello';\nconst readOnlyFunctionCallUrl = network.getReadOnlyFunctionCallApiUrl(\n  address,\n  contractName,\n  functionName\n);\n\nconst nodeInfoUrl = network.getInfoUrl();\n\nconst blockTimeUrl = network.getBlockTimeInfoUrl();\n\nconst poxInfoUrl = network.getPoxInfoUrl();\n```\n"
  },
  {
    "title": "Bitcoin Scopes",
    "description": "Reference guide for available scopes for Bitcoin.",
    "slug": "/stacks/chainhook/references/scopes/bitcoin",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\n\nimport { InlineCode } from '@/components/inline-code';\n\nBitcoin scopes are parameters you use to define the `if this` specification logic of your Chainhook on the Bitcoin blockchain. In other words, scopes specify what on-chain events you are looking to monitor and track. For more information on Chainhook design, please view [predicate design](/stacks/chainhook/concepts/predicate-design).\n\n<Root>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`txid`</h2>\n\nThe `txid` scope allows you to query transactions based on their transaction ID. This is particularly useful for tracking specific transactions or auditing transaction histories.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"equals\"} type={\"string\"}>\n\nThe `equals` property is a 32 byte hex encoded type used to specify the exact transaction ID to match.\n\n</Property>\n\n</div>\n\n<APIExample className='w-full'>\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>By transaction ID</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"txid\",\n      \"equals\": \"0xfaaac1833dc4883e7ec28f61e35b41f896c395f8d288b1a177155de2abd6052f\"\n    }\n  }\n  ```\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`outputs`</h2>\n\nThe `outputs` scope allows you to query blocks based on the payload returned by the specified operation.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"operation\"} type={\"object\"}>\n \nThe `operation` property is used to identify the Bitcoin operation that will trigger Chainhook as it observes Bitcoin transactions.  The available operations are `op_return`, `p2pkh`, `p2sh`,`p2wpkh` and `p2wsh`.\n\n</Property>\n\n</div>\n\n<APIExample className='w-full'>\n\n<Tabs defaultValue=\"op_return\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"op_return\" className='tab group'>\n      <Badge className='badge transition-colors'>Using op_return</Badge>\n    </TabsTrigger>\n     <TabsTrigger value=\"p2kph\" className='tab group'>\n      <Badge className='badge transition-colors'>Using p2pkh</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"p2sh\" className='tab group'>\n      <Badge className='badge transition-colors'>Using p2sh</Badge>\n    </TabsTrigger>\n     <TabsTrigger value=\"p2wpkh\" className='tab group'>\n      <Badge className='badge transition-colors'>Using p2wpkh</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"p2wsh\" className='tab group'>\n      <Badge className='badge transition-colors'>Using p2wsh</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"descriptor\" className='tab group'>\n      <Badge className='badge transition-colors'>Using descriptor</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"op_return\">\n\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"outputs\",\n      \"op_return\": {\n        \"equals\": \"0xbtc21000042stx016\"\n      }\n    }\n  }\n  ```\n  <Accordions>\n    <Accordion title=\"Parameters\">\n      <Property required={true} deprecated={false} name=\"equals\" type=\"string/32-byte encoded hex\">\n        The `equals` property specifies the exact characters of the string or 32 byte encoded hex to match.\n      </Property>\n      <Property required={true} deprecated={false} name=\"starts_with\" type=\"string/32-byte encoded hex\">\n        The `starts_with` property specifies the starting characters of the string or 32 byte encoded hex to match.\n      </Property>\n      <Property required={true} deprecated={false} name=\"ends_with\" type=\"string/32-byte encoded hex\">\n        The `ends_with` property specifies the ending characters of the string or 32 byte encoded hex to match.\n      </Property>\n    </Accordion>\n  </Accordions>\n  <Callout type=\"info\" title=\"Note\">\n    The `op_return` operation allows for `equals`, `starts_with` and `ends_with` for matching against the desired input. \n  </Callout>\n  </TabsContent>\n  <TabsContent value=\"p2kph\">\n\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"outputs\",\n      \"p2kph\": {\n        \"equals\": \"0xbtc21000042stx016\"\n      }\n    }\n  }\n  ```\n  <Accordions>\n    <Accordion title=\"Parameters\">\n      <Property required={true} deprecated={false} name=\"equals\" type=\"string/32-byte encoded hex\">\n        The `equals` property specifies the exact characters of the string or 32 byte encoded hex to match.\n      </Property>\n    </Accordion>\n  </Accordions>\n  <Callout type=\"info\" title=\"Note\">\n    `p2pkh`(Pay-to-Public-Key-Hash) is a Bitcoin transaction output script type that allows users to send funds to a recipient's hashed public key, providing security and privacy by concealing the actual public key.\n  </Callout>\n  </TabsContent>\n  <TabsContent value=\"p2sh\">\n\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"outputs\",\n      \"p2sh\": {\n        \"equals\": \"0xbtc21000042stx016\"\n      }\n    }\n  }\n  ```\n  <Accordions>\n    <Accordion title=\"Parameters\">\n      <Property required={true} deprecated={false} name=\"equals\" type=\"string/32-byte encoded hex\">\n        The `equals` property specifies the exact characters of the string or 32 byte encoded hex to match.\n      </Property>\n    </Accordion>\n  </Accordions>\n  <Callout type=\"info\" title=\"Note\">\n    `p2sh`(Pay-to-Script-Hash) is a Bitcoin transaction output script type that enables users to send funds to a script instead of a public key, allowing for more complex transaction conditions and multi-signature addresses.\n  </Callout>\n  </TabsContent>\n  <TabsContent value=\"p2wpkh\">\n\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"outputs\",\n      \"p2wpkh\": {\n        \"equals\": \"0xbtc21000042stx016\"\n      }\n    }\n  }\n  ```\n  <Accordions>\n    <Accordion title=\"Parameters\">\n      <Property required={true} deprecated={false} name=\"equals\" type=\"string\">\n        The `equals` property specifies the exact characters of the string to match.\n      </Property>\n    </Accordion>\n  </Accordions>\n  <Callout type=\"info\" title=\"Note\">\n    `p2wpkh`(Pay-to-Witness-Public-Key-Hash) is a Bitcoin transaction output script type used in Segregated Witness (SegWit) that allows for more efficient and secure transactions by separating the witness data from the transaction data and storing it in a separate block. \n  </Callout>\n  </TabsContent>\n  <TabsContent value=\"p2wsh\">\n\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"outputs\",\n      \"p2wsh\": {\n        \"equals\": \"0xbtc21000042stx016\"\n      }\n    }\n  }\n  ```\n  <Accordions>\n    <Accordion title=\"Parameters\">\n      <Property required={true} deprecated={false} name=\"equals\" type=\"string\">\n        The `equals` property specifies the exact characters of the string to match.\n      </Property>\n    </Accordion>\n  </Accordions>\n  <Callout type=\"info\" title=\"Note\">\n    `p2wsh` (Pay-to-Witness-Script-Hash) is a Bitcoin transaction output script type used in Segregated Witness (SegWit) that enables users to send funds to a hashed script, allowing for more complex transaction conditions and greater scalability by separating the script from the transaction data.\n  </Callout>\n  </TabsContent>\n  <TabsContent value=\"descriptor\">\n\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"outputs\",\n      \"descriptor\": {\n        \"expression\": \"wpkh(tprv8ZgxMBicQKsPePxn6j3TjvB2MBzQkuhGgc6oRh2WZancZQgxktcnjZJ44XdsRiw3jNkbVTK9JW6KFHvnRKgAMtSyuBevMJprSkZ4PTfmTgV/84'/1'/0'/0/*)\",\n        \"range\": [0, 3]\n      }\n    }\n  }\n  ```\n  <Accordions>\n    <Accordion title=\"Parameters\">\n     <Property required={true} deprecated={false} name=\"expression\" type=\"string\">\n        The `expression` property specifies the exact characters of the string to match.\n      </Property>\n      <Property required={true} deprecated={false} name=\"range\" type=\"integer[]\">\n        The `range` property specifies and array of integers representing the desired indexes.\n      </Property>\n    </Accordion>\n  </Accordions>\n  <Callout type=\"info\" title=\"Note\">\n    <Accordions>\n      <Accordion title=\"Wallet descriptors\">\n        Wallet descriptors provide a compact and semi-standardized method for describing how scripts and addresses within a wallet are generated. Chainhook users that want to track addresses derived from an extended pubkey or a multisig-wallet can now rely on this feature instead of defining one predicate per address.\n        For example, let's say we wanted to track the first 3 addresses generated by the following descriptor:\n\n        ```\n        wpkh(tprv8ZgxMBicQKsPePxn6j3TjvB2MBzQkuhGgc6oRh2WZancZQgxktcnjZJ44XdsRiw3jNkbVTK9JW6KFHvnRKgAMtSyuBevMJprSkZ4PTfmTgV/84'/1'/0'/0/*)\n        ```\n\n        This descriptor reads: describe a P2WPKH output with the specified extended public key, and it produces these BIP84 addresses:\n\n        ```\n        bcrt1qzy2rdyvu8c57qd8exyyp0mw7dk5drsu9ewzdsu\n        bcrt1qsfsjnagr29m8h3a3vdand2s85cg4cefkcwk2fy\n        bcrt1qauewfytqe5mtr0xwp786r6fl39kmum2lr65kmj\n        ```\n      </Accordion>\n    </Accordions>\n  </Callout>\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`stacks_protocol`</h2>\n\nThe `stacks_protocol` scope allows you query Bitcoin transactions related to the Stacks Proof of Transfer (PoT) [concensus mechanism](https://www.hiro.so/blog/securing-web3-apps-through-bitcoin-an-overview-of-stacks-consensus-mechanism).\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"operation\"} type={\"string\"}>\n\nThe `operation` property is used to identify the Stacks operation that will trigger Chainhook as it observes Bitcoin transactions.  The available operations are `block_committed`, `leader_registered`, `inscription_feed`, `stx_transferred` and `stx_locked`.\n\n</Property>\n\n</div>\n\n<APIExample className='w-full'>\n\n<Tabs defaultValue=\"block_committed\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"block_committed\" className='tab group'>\n      <Badge className='badge transition-colors'>Using block_committed</Badge>\n    </TabsTrigger>\n     <TabsTrigger value=\"leader_registered\" className='tab group'>\n      <Badge className='badge transition-colors'>Using leader_registered</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"inscription_feed\" className='tab group'>\n      <Badge className='badge transition-colors'>Using inscription_feed</Badge>\n    </TabsTrigger>\n     <TabsTrigger value=\"stx_transferred\" className='tab group'>\n      <Badge className='badge transition-colors'>Using stx_transferred</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"stx_locked\" className='tab group'>\n      <Badge className='badge transition-colors'>Using stx_locked</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"block_committed\">\n\n  ```json\n    {\n      \"if_this\": {\n        \"scope\": \"stacks_protocol\",\n        \"operation\": \"block_committed\"\n      }\n    }\n  ```\n  </TabsContent>\n  <TabsContent value=\"leader_registered\">\n\n   ```json\n    {\n      \"if_this\": {\n        \"scope\": \"stacks_protocol\",\n        \"operation\": \"leader_registered\"\n      }\n    }\n  ```\n  </TabsContent>\n  <TabsContent value=\"inscription_feed\">\n\n   ```json\n    {\n      \"if_this\": {\n        \"scope\": \"stacks_protocol\",\n        \"operation\": \"inscription_feed\"\n      }\n    }\n  ```\n\n  <Callout type=\"info\" title=\"Note\">\n    `inscription_feed` observes the reveal and transfer of an Ordinal inscription.\n  </Callout>\n  </TabsContent>\n  <TabsContent value=\"stx_transferred\">\n\n   ```json\n    {\n      \"if_this\": {\n        \"scope\": \"stacks_protocol\",\n        \"operation\": \"stx_transferred\"\n      }\n    }\n  ```\n  </TabsContent>\n  <TabsContent value=\"stx_locked\">\n\n   ```json\n    {\n      \"if_this\": {\n        \"scope\": \"stacks_protocol\",\n        \"operation\": \"stx_locked\"\n      }\n    }\n  ```\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n</Root>"
  },
  {
    "title": "Stacks Scopes",
    "description": "Reference guide for available scopes for Stacks.",
    "slug": "/stacks/chainhook/references/scopes/stacks",
    "content": "\nimport { Root, API, APIExample } from 'fumadocs-openapi/ui';\nimport { Property } from 'fumadocs-openapi/ui'\n\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Badge } from '@/components/ui/badge';\n\nimport { InlineCode } from '@/components/inline-code';\n\nStacks scopes are parameters you use to define the `if this` specification logic of your Chainhook on the Stacks blockchain. In other words, scopes specify what on-chain events you are looking to monitor and track. For more information on Chainhook design, please view [predicate design](/stacks/chainhook/concepts/predicate-design).\n\n<Root>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`txid`</h2>\n\nThe `txid` scope allows you to query transactions based on their transaction ID. This is particularly useful for tracking specific transactions or auditing transaction histories.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"equals\"} type={\"string\"}>\n\nThe `equals` property is a 32 bytes hex encoded type used to specify the exact transaction ID to match.\n\n</Property>\n\n</div>\n\n<APIExample className='w-full'>\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>By transaction ID</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n    ```json\n    {\n      \"if_this\": {\n        \"scope\": \"txid\",\n        \"equals\": \"0xfaaac1833dc4883e7ec28f61e35b41f896c395f8d288b1a177155de2abd6052f\"\n      }\n    }\n    ```\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`block_height`</h2>\n\nThe `block_height` scope allows you to query blocks based on their height. This is useful for identifying specific blocks or ranges of blocks in the blockchain.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"equals\"} type={\"integer\"}>\n\nThe `equals` property specifies the exact height of the block to match.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"higher_than\"} type={\"integer\"}>\n\nThe `higher_than` property specifies that the block height should be greater than the provided value.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"lower_than\"} type={\"integer\"}>\n\nThe `lower_than` property specifies that the block height should be less than the provided value.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"between\"} type={\"array of integers\"}>\n\nThe `between` property specifies a range of block heights to match, inclusive of the provided start and end values.\n\n</Property>\n\n</div>\n\n<APIExample className='w-full'>\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>By block height</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"higher_than\" className='tab group'>\n      <Badge className='badge transition-colors'>Using higher_than</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"lower_than\" className='tab group'>\n      <Badge className='badge transition-colors'>Using lower_than</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"between\" className='tab group'>\n      <Badge className='badge transition-colors'>Between two block heights</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"block_height\",\n      \"equals\": 141200\n    }\n  }\n  ```\n  </TabsContent>\n  <TabsContent value=\"higher_than\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"block_height\",\n      \"higher_than\": 10000\n    }\n  }\n  ```\n  </TabsContent>\n  <TabsContent value=\"lower_than\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"block_height\",\n      \"lower_than\": 10000\n    }\n  }\n  ```\n  </TabsContent>\n  <TabsContent value=\"between\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"block_height\",\n      \"between\": [0, 10000]\n    }\n  }\n  ```\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`ft_transfer`</h2>\n\nThe `ft_transfer` scope allows you to query transactions based on fungible token transfers. This is useful for tracking specific token movements or auditing token transfer histories.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"asset_identifier\"} type={\"string\"}>\n\nThe `asset_identifier` property specifies the fully qualified asset identifier to observe.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"actions\"} type={\"string[]\"}>\n\nThe `actions` property specifies the types of token actions to observe, such as `mint`, `transfer`, or `burn`.\n\n</Property>\n\n</div>\n\n<APIExample className='w-full'>\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>By a single action</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"all\" className='tab group'>\n      <Badge className='badge transition-colors0'>Passing all ft actions</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"ft_transfer\",\n      \"asset_identifier\": \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.cbtc-token::cbtc\",\n      \"actions\": [\"transfer\"]\n    }\n  }\n  ```\n  </TabsContent>\n  <TabsContent value=\"all\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"ft_transfer\",\n      \"asset_identifier\": \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.cbtc-token::cbtc\",\n      \"actions\": [\"mint\", \"transfer\", \"burn\"]\n    }\n  }\n  ```\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`nft_transfer`</h2>\n\nThe `nft_transfer` scope allows you to query transactions based on non-fungible token transfers. This is useful for tracking specific NFT movements or auditing NFT transfer histories.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"asset_identifier\"} type={\"string\"}>\n\nThe `asset_identifier` property specifies the fully qualified asset identifier to observe.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"actions\"} type={\"array of strings\"}>\n\nThe `actions` property specifies the types of NFT actions to observe, such as `mint`, `transfer`, or `burn`.\n\n</Property>\n\n</div>\n\n<APIExample className='w-full'>\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>By non-fungible token mint</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"all\" className='tab group'>\n      <Badge className='badge transition-colors'>Passing all nft actions</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"nft_transfer\",\n      \"asset_identifier\": \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.monkey-sip09::monkeys\",\n      \"actions\": [\"mint\"]\n    }\n  }\n  ```\n  </TabsContent>\n  <TabsContent value=\"all\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"nft_transfer\",\n      \"asset_identifier\": \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.monkey-sip09::monkeys\",\n      \"actions\": [\"mint\", \"transfer\", \"burn\"]\n    }\n  }\n  ```\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`stx_transfer`</h2>\n\nThe `stx_transfer` scope allows you to query transactions involving STX token movements. This is crucial for monitoring STX transfers, including minting, burning, and locking actions.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"actions\"} type={\"array of strings\"}>\n\nThe `actions` property specifies the types of STX token actions to observe, such as `mint`, `transfer`, `burn`, and `lock`.\n\n</Property>\n\n</div>\n\n<APIExample className='w-full'>\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>By STX token transfer</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"all\" className='tab group'>\n      <Badge className='badge transition-colors'>Passing all actions</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"stx_transfer\",\n      \"actions\": [\"transfer\"]\n    }\n  }\n  ```\n  </TabsContent>\n    <TabsContent value=\"all\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"stx_transfer\",\n      \"actions\": [\"mint\", \"transfer\", \"burn\", \"lock\"]\n    }\n  }\n  ```\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`print_event`</h2>\n\nThe `print_event` scope allows you to query transactions based on specific print events emitted during contract execution. This is useful for monitoring specific events for auditing or tracking purposes.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"contract_identifier\"} type={\"string\"}>\n\nThe `contract_identifier` property specifies the fully qualified contract identifier to observe.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"contains\"} type={\"string\"}>\n\nThe `contains` property is used for matching an event containing the specified string.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"matches_regex\"} type={\"string\"}>\n\nThe `matches_regex` property is used for matching an event that regex matches with the specified string.\n\n</Property>\n\n</div>\n\n<APIExample className='w-full'>\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Using contains</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"matches_regex\" className='tab group'>\n      <Badge className='badge transition-colors'>Using matches_regex</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"print_event\",\n      \"contract_identifier\": \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.monkey-sip09\",\n      \"contains\": \"monkey\"\n    }\n  }\n  ```\n  </TabsContent>\n  <TabsContent value=\"matches_regex\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"print_event\",\n      \"contract_identifier\": \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.monkey-sip09\",\n      \"matches_regex\": \"(?:^|\\\\W)monkey(?:$|\\\\W)\"\n    }\n  }\n  ```\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`contract_call`</h2>\n\nThe `contract_call` scope allows you to query transactions that involve direct calls to specific methods within a smart contract. This is particularly useful for tracking interactions with critical contract functions.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"contract_identifier\"} type={\"string\"}>\n\nThe `contract_identifier` property specifies the fully qualified contract identifier to observe.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"method\"} type={\"string\"}>\n\nThe `method` property specifies the specific method within the contract to observe.\n\n</Property>\n\n</div>\n\n<APIExample className='w-full'>\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>Scoping by contract method call</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"contract_call\",\n      \"contract_identifier\": \"SP000000000000000000002Q6VF78.pox\",\n      \"method\": \"stack-stx\"\n    }\n  }\n  ```\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n<API className='my-20'>\n\n<div className='flex-1'>\n\n<h2 className='mt-0'>`contract_deployment`</h2>\n\nThe `contract_deployment` scope allows you to query transactions involving the deployment of smart contracts. This is crucial for monitoring new contract deployments and ensuring compliance with expected deployments.\n\n## Parameters\n\n<Property required={true} deprecated={false} name={\"deployer\"} type={\"string\"}>\n\nThe `deployer` property specifies the STX address of the deployer to observe.\n\n</Property>\n\n<Property required={true} deprecated={false} name={\"implement_trait\"} type={\"string\"}>\n\nThe `implement_trait` property specifies the contract trait to observe.\n\n</Property>\n\n</div>\n\n<APIExample className='w-full'>\n\n<Tabs defaultValue=\"default\">\n  <TabsList className='flex flex-wrap'>\n    <TabsTrigger value=\"default\" className='tab group'>\n      <Badge className='badge transition-colors'>By deployer</Badge>\n    </TabsTrigger>\n    <TabsTrigger value=\"trait\" className='tab group'>\n      <Badge className='badge transition-colors'>By contract trait</Badge>\n    </TabsTrigger>\n  </TabsList>\n  <TabsContent value=\"default\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"contract_deployment\",\n      \"deployer\": \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\"\n    }\n  }\n  ```\n  </TabsContent>\n  <TabsContent value=\"trait\">\n  ```json\n  {\n    \"if_this\": {\n      \"scope\": \"contract_deployment\",\n      \"implement_trait\": \"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.sip09-protocol\"\n    }\n  }\n  ```\n  </TabsContent>\n</Tabs>\n\n</APIExample>\n\n</API>\n\n</Root>\n"
  },
  {
    "title": "Overview",
    "description": "Chainhook enables you to target events on the Bitcoin and Stacks blockchain important to your use case in order to trigger actions based on those events.",
    "slug": "/stacks/chainhook/index",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nChainhook is a reorg-aware indexer that serves reliable blockchain data—you don’t have to waste time reindexing your database every time there's a fork. Chainhook also lets you index only the data you need, which means you can build lighter databases, get faster query results, and deliver a better experience to your users.\n\nTo get started, check out our [installation guide](/stacks/chainhook/installation).\n\n## Create event streams\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/chainhook/guides/chainhook-as-a-service\"\n    title=\"Create a Bitcoin chainhook\"\n    description=\"Build a chainhook that indexes events on the Bitcoin blockchain.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/chainhook/guides/chainhook-as-a-service-with-stacks-node\"\n    title=\"Create a Stacks chainhook\"\n    description=\"Build a chainhook that indexes events on the Stacks blockchain.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/chainhook/guides/register-chainhooks-on-devnet\"\n    title=\"Test your chainhooks\"\n    description=\"Test and debug your chainhooks in a local environment.\"\n  />\n</Cards>\n\n## Setting up Chainhook predicates\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/chainhook/concepts/bitcoin-predicates\"\n    title=\"Bitcoin predicates\"\n    description=\"A list of &quot;if this, then that&quot; logic for Bitcoin chainhooks.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/chainhook/concepts/stacks-predicates\"\n    title=\"Stacks predicates\"\n    description=\"A list of &quot;if this, then that&quot; logic for Bitcoin chainhooks.\"\n  />\n</Cards>\n\n## Related tools\n\n- **[Bitcoin Indexer](/bitcoin/indexer)**: Simplify your testing with the Clarinet JS SDK.\n- **[Hiro Platform](/stacks/platform)**: A developer platform for building, deploying and scaling Bitcoin apps.\n\n<br />\n\n<Callout title=\"Need help building with Chainhook?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#chainhook</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>"
  },
  {
    "title": "Run Chainhook as a service with a Stacks node",
    "description": "Learn how to run Chainhook as a service with a Stacks node to evaluate Stacks blocks against your predicates.",
    "slug": "/stacks/chainhook/examples/chainhook-as-a-service-with-stacks-node",
    "content": "\nYou can run Chainhook as a service to evaluate Stacks blocks against your predicates. You can also dynamically register new predicates by enabling the predicates registration API.\n\nIn this guide, you will learn how to:\n\n1. [Configure your Stacks node to work with Chainhook](#configure-your-stacks-node).\n2. [Configure Chainhook](#configure-chainhook).\n3. [Create a predicate to evaluate your events](#create-a-predicate).\n4. [Initiate a Chainhook service to watch for matching transactions](#initiate-chainhook-as-a-service).\n5. [Dynamically register your predicates with Chainhook](#dynamically-register-predicates).\n\n{/* <Callout>Check out a full example [here](https://github.com/hiro-so/stacks-connect-example).</Callout> */}\n\n---\n\n## Configure Your Stacks Node\n\nIf you followed along with the previous guide on syncing a Stacks node, you should generate a `Stacks.toml` file within your Stacks node repository. Below is a sample `Stacks.toml` file:\n\n```toml title=\"Stacks.toml\"\n[node]\nworking_dir = \"/stacks-blockchain\"\nrpc_bind = \"0.0.0.0:20443\"          # Make a note of this port to use in the `Chainhook.toml`\np2p_bind = \"0.0.0.0:20444\"\nbootstrap_node = \"02da7a464ac770ae8337a343670778b93410f2f3fef6bea98dd1c3e9224459d36b@seed-0.mainnet.stacks.co:20444,02afeae522aab5f8c99a00ddf75fbcb4a641e052dd48836408d9cf437344b63516@seed-1.mainnet.stacks.co:20444,03652212ea76be0ed4cd83a25c06e57819993029a7b9999f7d63c36340b34a4e62@seed-2.mainnet.stacks.co:20444\"\n\n[burnchain]\nchain = \"bitcoin\"\nmode = \"mainnet\"\npeer_host = \"localhost\"\nusername = \"bitcoind_username\"       # Must match the rpcuser in the bitcoin.conf\npassword = \"bitcoind_password\"       # Must match the rpcpassword in the bitcoin.conf\nrpc_port = 8332                      # Must match the rpcport in the bitcoin.conf\npeer_port = 8333\n\n[[events_observer]]\nendpoint = \"localhost:20455\"\nretry_count = 255\nevents_keys = [\"*\"]\n```\n<Callout title=\"Note\">\nEnsure that the `username`, `password`, and `rpc_port` values in the `Stacks.toml` file match the values in the `bitcoin.conf` file. Also, note the `rpc_bind` port to use in the `Chainhook.toml` configuration in the next section.\n</Callout>\n\n## Configure Chainhook\n\nIn this section, you will configure Chainhook to communicate with the network. Run the following command in your terminal to generate the `Chainhook.toml` file:\n\n```terminal\n$ chainhook config generate --mainnet\n```\n\nSeveral network parameters in the generated Chainhook.toml configuration file need to match those in the bitcoin.conf file created earlier in the Setting up a Bitcoin Node section. Update the following parameters accordingly:\n\n1. Update `bitcoind_rpc_username` with the username set for `rpcuser` in `bitcoin.conf`.\n2. Update `bitcoind_rpc_password` with the password set for `rpcpassword` in `bitcoin.conf`.\n3. Update `bitcoind_rpc_url` with the same host and port used for `rpcport` in `bitcoin.conf`.\n4. Ensure `stacks_node_rpc_url` matches the `rpc_bind` in the `Stacks.toml` file.\n\nThe generated `Chainhook.toml` file should look like this:\n\n```toml title=\"Chainhook.toml\"\n[storage]\nworking_dir = \"cache\"\n\n# The http API allows you to register / deregister predicates dynamically.\n# This is disabled by default.\n\n# [http_api]\n# http_port = 20456\n# database_uri = \"redis://localhost:6379/\"\n\n[network]\nmode = \"mainnet\"\nbitcoind_rpc_url = \"http://localhost:8332\"\nbitcoind_rpc_username = \"devnet\"\nbitcoind_rpc_password = \"devnet\"\n# Bitcoin block events can be received by Chainhook\n# either through a Bitcoin node's ZeroMQ interface,\n# or through the Stacks node. The Stacks node is\n# used by default:\nstacks_node_rpc_url = \"http://localhost:20443\"\nstacks_events_ingestion_port = 20455\n# but zmq can be used instead:\n# bitcoind_zmq_url = \"tcp://0.0.0.0:18543\"\n\n[limits]\nmax_number_of_bitcoin_predicates = 100\nmax_number_of_concurrent_bitcoin_scans = 100\nmax_number_of_stacks_predicates = 10\nmax_number_of_concurrent_stacks_scans = 10\nmax_number_of_processing_threads = 16\nmax_number_of_networking_threads = 16\nmax_caching_memory_size_mb = 32000\n\n[[event_source]]\ntsv_file_url = \"https://archive.hiro.so/mainnet/stacks-blockchain-api/mainnet-stacks-blockchain-api-latest\"\n```\n\nEnsure the following configurations are matched to allow Chainhook to communicate with both Stacks and Bitcoin:\n\n| bitcoin.conf       | Stacks.toml | Chainhook.toml             |\n|--------------------|-------------|-----------------------------|\n| rpcuser            | username    | bitcoind_rpc_username      |\n| rpcpassword        | password    | bitcoind_rpc_password      |\n| rpcport            | rpc_port    | bitcoind_rpc_url           |\n| zmqpubhashblock    |             | bitcoind_zmq_url           |\n|                    | rpc_bind    | stacks_node_rpc_url        |\n|                    | endpoint    | stacks_events_ingestion_port |\n\n<Callout title=\"Note\">\nThe `bitcoind_zmq_url` is optional when running Chainhook as a service using Stacks because Stacks will pull the blocks from Stacks and the Bitcoin chain.\n</Callout>\n\n## Create a predicate\n\nNow that the Stacks and Chainhook configurations are done, you can scan your blocks by defining your predicates.\n\n### Appending events to a file\n\nThe following command will generate a sample JSON file `print-event.json`.\n\n```terminal\n$ chainhook predicates new print-event.json --stacks\n```\n\nOnce the boilerplate predicate code has been generated, update the `print-event.json` file with the following content:\n\n```json title=\"print-event.json\"\n{\n  \"chain\": \"stacks\",\n  \"uuid\": \"6ad27176-2b83-4381-b51c-50baede11e3f\",\n  \"name\": \"Hello world\",\n  \"version\": 1,\n  \"networks\": {\n    \"testnet\": {\n      \"start_block\": 34239,\n      \"end_block\": 50000,\n      \"if_this\": {\n        \"scope\": \"print_event\",\n        \"contract_identifier\": \"ST1SVA0SST0EDT4MFYGWGP6GNSXMMQJDVP1G8QTTC.arkadiko-freddie-v1-1\",\n        \"contains\": \"vault\"\n      },\n      \"then_that\": {\n        \"file_append\": {\n          \"path\": \"arkadiko.txt\"\n        }\n      }\n    },\n    \"mainnet\": {\n      \"start_block\": 34239,\n      \"end_block\": 50000,\n      \"if_this\": {\n        \"scope\": \"print_event\",\n        \"contract_identifier\": \"SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-freddie-v1-1\",\n        \"contains\": \"vault\"\n      },\n      \"then_that\": {\n        \"file_append\": {\n          \"path\": \"arkadiko.txt\"\n        }\n      }\n    }\n  }\n}\n```\n\nNow, use the following command to scan the blocks based on the predicates defined in the `print-event.json` file:\n\n```terminal\n$ chainhook predicates scan print-event.json --mainnet\n```\n\nThe output of the above command will be a file `arkadiko.txt` generated based on the predicate definition.\n\n### Sending events to an API endpoint\n\n```terminal\n$ chainhook predicates new print-event-post.json --stacks\n```\n\nThis will generate a sample JSON file `print-event-post.json`. Update the generated `print-event-post.json` file with the following content:\n\n```json title=\"print-event-post.json\"\n{\n  \"chain\": \"stacks\",\n  \"uuid\": \"e5fa09b2-ec3e-4b6a-9a4a-0ebb454f6e19\",\n  \"name\": \"Hello world\",\n  \"version\": 1,\n  \"networks\": {\n    \"testnet\": {\n      \"if_this\": {\n        \"scope\": \"print_event\",\n        \"contract_identifier\": \"ST1SVA0SST0EDT4MFYGWGP6GNSXMMQJDVP1G8QTTC.arkadiko-freddie-v1-1\",\n        \"contains\": \"vault\"\n      },\n      \"then_that\": {\n        \"http_post\": {\n          \"url\": \"http://localhost:3000/events\",\n          \"authorization_header\": \"Bearer cn389ncoiwuencr\"\n        }\n      },\n      \"start_block\": 10200,\n      \"expire_after_occurrence\": 5\n    },\n    \"mainnet\": {\n      \"if_this\": {\n        \"scope\": \"print_event\",\n        \"contract_identifier\": \"SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.arkadiko-freddie-v1-1\",\n        \"contains\": \"vault\"\n      },\n      \"then_that\": {\n        \"http_post\": {\n          \"url\": \"http://localhost:3000/events\",\n          \"authorization_header\": \"Bearer cn389ncoiwuencr\"\n        }\n      },\n      \"start_block\": 10200,\n      \"expire_after_occurrence\": 5\n    }\n  }\n}\n```\n\n<Callout>\nThe `start_block` is a required field to use the `http_post` then_that predicate.\n</Callout>\n\nNow, use the following command to scan the blocks based on the predicates defined in the `print-event-post.json` file:\n\n```terminal\n$ chainhook predicates scan print-event-post.json --mainnet\n```\n\nThe above command posts events to the URL `http://localhost:3000/events` mentioned in the `Chainhook.toml` file.\n\n## Initiate Chainhook as a service\n\n```terminal\n$ chainhook service start --predicate-path=print-event.json --config-path=Chainhook.toml\n```\n\nThis command registers the predicate and starts the Chainhook service.\n\n## Dynamically register predicates\n\nYou can also dynamically register new predicates with your Chainhook service.\n\n<Callout title=\"Requirements\" type=\"warn\"> This section requires that you have Redis running locally. To install, refer to the [Redis documentation](https://redis.io/docs/getting-started/).</Callout>\n\nFirst, ensure that the following lines in the `Chainhook.toml` file are uncommented to enable the predicate registration server:\n\n```toml title=\"Chainhook.toml\"\n[http_api]\nhttp_port = 20456\ndatabase_uri = \"redis://localhost:6379/\"\n```\n\n```terminal\n$ chainhook service start --predicate-path=print-event.json --config-path=Chainhook.toml\n```\n\nStart the Chainhook service with the following command:\n\n```terminal\n$ chainhook service start --config-path=Chainhook.toml\n```\n\nTo dynamically register a new predicate, send a POST request to the running predicate registration server at `localhost:20456/v1/chainhooks`.\n\nUse the following `curl` command template as an example:\n\n```terminal\n$ curl -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -d @predicate.json \\\n  http://localhost:20456/v1/chainhooks\n\n{\"result\":\"<uuid>\",\"status\":200}\n```\n\n<Callout title=\"Note\">You can also run the Chainhook service by passing multiple predicates: `chainhook service start --predicate-path=predicate_1.json --predicate-path=predicate_2.json --config-path=Chainhook.toml` </Callout>\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/chainhook/guides/register-chainhooks-on-devnet\"\n    title=\"Register Chainhooks on devnet\"\n    description=\"Learn how to register Chainhooks on devnet.\"\n  />\n  <Card\n    href=\"/stacks/chainhook/references/scopes/stacks\"\n    title=\"Stacks scopes\"\n    description=\"Learn how to use scopes to scan for specific Stacks blockchain events.\"\n  />\n</Cards>"
  },
  {
    "title": "Register Chainhooks on devnet",
    "description": "Learn how to register chainhooks on devnet.",
    "slug": "/stacks/chainhook/examples/register-chainhooks-on-devnet",
    "content": "\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\n\nFollow these steps to register your Chainhooks on devnet using Clarinet:\n\n<Callout title=\"Requirements\" type=\"warn\">\n  This feature requires Clarinet version 2.1.0 or higher. To upgrade or install, refer to our [installation](/stacks/clarinet/installation) page for Clarinet.\n</Callout>\n\n## Create your Chainhook predicates\n\nFirst, within your Clarinet project, you'll need to create your Chainhook predicate files.\n\nThese should be situated in the root of your project directory. The files can either be separate or stored within a specific folder, e.g., `/chainhooks` in your project root directory:\n\n<Files className='pointer-events-none'>\n  <Folder name=\"contracts\" defaultOpen>\n    <File name=\"counter.clar\" />\n  </Folder>\n  <Folder name=\"chainhooks\" defaultOpen className='bg-[hsl(var(--highlight))]'>\n    <File name=\"increment.json\" />\n    <File name=\"decrement.json\" />\n  </Folder>\n  <Folder name=\"settings\" />\n  <Folder name=\"tests\" defaultOpen>\n    <File name=\"counter.test.ts\" />\n  </Folder>\n  <File name=\".gitignore\" />\n  <File name=\"Clarinet.toml\" />\n  <File name=\"package.json\" />\n  <File name=\"tsconfig.json\" />\n  <File name=\"vitest.config.js\" />\n</Files>\n\nFor examples on how to define your predicates, refer to the [scopes](/stacks/chainhook/references/scopes/stacks) reference page.\n\n## Start devnet\n\nTo start devnet, run the _`clarinet devnet start`_ command from the root of your project directory. Running this command will begin a local Chainhook service in the background that automatically registers your Chainhook files within the project directory against the network.\n\n## Confirm registration\n\nOnce your devnet starts, the Chainhook service initiates the registration process. You'll know that the registration of your Chainhooks was successful by checking the confirmation message in your terminal:\n\n```terminal\n$ clarinet devnet start\n# ...\nINFO Feb  5 15:20:07.233382 2 chainhooks registered\n```\n\nIf you do not see this message at the top of your _`clarinet devnet start`_ logs, verify that you are using `clarinet` version 2.1.0 or higher.\n\n## Working with chainhooks\n\nWith these steps completed, your chainhooks are ready to trigger whenever local contract actions occur. You can monitor your network activity locally, through the _`clarinet devnet start` terminal, to confirm chainhooks execution as you further develop and test your smart contracts. When an action occurs, you should see something like this:\n\n```terminal\n$ clarinet devnet start\n# ...\nINFO Feb  5 15:21:07.233382 1 hooks triggered\n```\n\nAt this point, you can verify the payload for that action depending on whether you are expecting an _json`http_post`_ or _json`file_append`_ result from your _json`then_that`_ configuration.\n"
  },
  {
    "title": "Run Chainhook as a service",
    "description": "Learn how to run Chainhook as a service to evaluate your \"if this, then that\" predicates against the Bitcoin and Stacks blockchains.",
    "slug": "/stacks/chainhook/examples/chainhook-as-a-service",
    "content": "\nIn order to build out a more robust and secure web app, you can run Chainhook as a service to stream your events continously to a server you designate.\n\nIn this guide, you will learn how to:\n\n1. [Configure an existing Bitcoin node to work with Chainhook](#configure-an-existing-bitcoin-node-to-work-with-chainhook).\n2. [Generate a Chainhook predicate to target specific transactions](#generate-a-chainhook-predicate-to-target-specific-transactions).\n3. [Scan the Bitcoin blockchain for transactions that match your predicate](#scan-the-bitcoin-blockchain-for-transactions-that-match-your-predicate).\n4. [Initiate a Chainhook service to watch for matching transactions](#initiate-a-chainhook-service-to-watch-for-matching-transactions).\n5. [Dynamically register your predicate with Chainhook](#dynamically-register-your-predicate-with-chainhook).\n\n---\n\n## Configure Chainhook\n\nIn this section, you will configure Chainhook to match the network configurations with the bitcoin config file. First, [install the latest version of Chainhook](/stacks/chainhook/installation).\n\nNext, you will generate a `Chainhook.toml` file to connect Chainhook with your bitcoind node. Navigate to the directory where you want to generate the `Chainhook.toml` file and use the following command in your terminal:\n\n```terminal\n$ chainhook config generate --mainnet\n```\n\nSeveral network parameters in the generated `Chainhook.toml` configuration file need to match those in the `bitcoin.conf` file created earlier in the [setting up a Bitcoin node](/guides/sync-a-bitcoin-node) section. Update the following parameters accordingly:\n\n1. Update `bitcoind_rpc_username` with the username set for `rpcuser` in `bitcoin.conf`.\n2. Update `bitcoind_rpc_password` with the password set for `rpcpassword` in `bitcoin.conf`.\n3. Update `bitcoind_rpc_url` with the same host and port used for `rpcport` in `bitcoin.conf`.\n\nAdditionally, if you want to receive events from the configured Bitcoin node, substitute `stacks_node_rpc_url` with `bitcoind_zmq_url`, as follows:\n\n```toml\n[storage]\nworking_dir = \"cache\"\n\n# The http API allows you to register / deregister predicates dynamically.\n# This is disabled by default.\n\n# [http_api]\n# http_port = 20456\n# database_uri = \"redis://localhost:6379/\"\n\n[network]\nmode = \"mainnet\"\nbitcoind_rpc_url = \"http://localhost:8332\"\nbitcoind_rpc_username = \"devnet\"\nbitcoind_rpc_password = \"devnet\"\n# Bitcoin block events can be received by Chainhook\n# either through a Bitcoin node's ZeroMQ interface,\n# or through the Stacks node. The Stacks node is\n# used by default:\n# stacks_node_rpc_url = \"http://localhost:20443\"\n# but zmq can be used instead:\nbitcoind_zmq_url = \"tcp://0.0.0.0:18543\"\n\n[limits]\nmax_number_of_bitcoin_predicates = 100\nmax_number_of_concurrent_bitcoin_scans = 100\nmax_number_of_stacks_predicates = 10\nmax_number_of_concurrent_stacks_scans = 10\nmax_number_of_processing_threads = 16\nmax_number_of_networking_threads = 16\nmax_caching_memory_size_mb = 32000\n\n[[event_source]]\ntsv_file_url = \"https://archive.hiro.so/mainnet/stacks-blockchain-api/mainnet-stacks-blockchain-api-latest\"\n```\n\nHere is a table of the relevant parameters this guide changes in our configuration files.\n\n| bitcoin.conf    | Chainhook.toml        |\n| :--------------- | :--------------------- |\n| rpcuser         | bitcoind_rpc_username |\n| rpcpassword     | bitcoind_rpc_password |\n| rpcport         | bitcoind_rpc_url      |\n| zmqpubhashblock | bitcoind_zmq_url      |\n\n## Scan the blockchain based on predicates\n\nNow that your `bitcoind` and Chainhook configurations are complete, you can define the Chainhook [Bitcoin predicate scope](/stacks/chainhook/references/scopes/bitcoin) you would like to scan for.\n\nThese predicates are where you specify the `if_this / then_that` pattern to trigger Chainhook to deliver a result (either a file appendation or an HTTP POST request).\n\n## Appending events to a file\n\nTo generate a sample JSON file with predicates, execute the following command in your terminal:\n\n```terminal\n$ chainhook predicates new stacking-pool.json --bitcoin\n```\n\nReplace the contents of the `stacking-pool.json` file with the following:\n\n```json\n{\n  \"chain\": \"bitcoin\",\n  \"uuid\": \"1\",\n  \"name\": \"Stacking Pool\",\n  \"version\": 1,\n  \"networks\": {\n    \"mainnet\": {\n      \"start_block\": 801500,\n      \"end_block\": 802000,\n      \"if_this\": {\n        \"scope\": \"outputs\",\n        \"p2wpkh\": {\n          \"equals\": \"bc1qs0kkdpsrzh3ngqgth7mkavlwlzr7lms2zv3wxe\"\n        }\n      },\n      \"then_that\": {\n        \"file_append\": {\n          \"path\": \"bitcoin-transactions.txt\"\n        }\n      }\n    }\n  }\n}\n```\n\nThis example demonstrates scanning a portion of the Bitcoin blockchain to capture specific outputs from a Bitcoin address associated with a Stacking pool, in this case [Friedgar Pool](https://pool.friedger.de/). Notice the `then_that` predicate specifying a `file_append`.\n\n<Callout title=\"Note\">\nYou can get blockchain height and current block by referring to the [Stacks Explorer](https://explorer.hiro.so/blocks?chain=mainnet).\n</Callout>\n\nNow, use the following command to scan the blocks based on the predicates defined in the `stacking-pool.json` file.\n\n```terminal\n$ chainhook predicates scan stacking-pool.json --config-path=./Chainhook.toml\n```\n\nThe output of the above command will be a text file `bitcoin-transactions.txt` generated based on the predicate definition.\n\n## Sending events to an API endpoint\n\nNow you will generate another sample predicate, but this time you will send the payload to an API endpoint:\n\n```terminal\n$ chainhook predicates new stacking-pool-api.json --bitcoin\n```\n\nReplace the contents of the `stacking-pool-api.json` file with the following:\n\n```json\n{\n  \"chain\": \"bitcoin\",\n  \"uuid\": \"2\",\n  \"name\": \"Stacking Pool (API)\",\n  \"version\": 1,\n  \"networks\": {\n    \"mainnet\": {\n      \"start_block\": 801500,\n      \"if_this\": {\n        \"scope\": \"outputs\",\n        \"p2wpkh\": {\n          \"equals\": \"bc1qs0kkdpsrzh3ngqgth7mkavlwlzr7lms2zv3wxe\"\n        }\n      },\n      \"then_that\": {\n        \"http_post\": {\n          \"url\": \"http://localhost:3000/events\",\n          \"authorization_header\": \"12345\"\n        }\n      }\n    }\n  }\n}\n```\n\n<Callout title=\"Note\">\nThe `start_block` is a required field when using the `http_post` `then_that` predicate.\n</Callout>\n\nOnce you are finished setting up your endpoint, use the following command to scan the blocks based on the predicates defined in the `stacking-pool-api.json` file.\n\n```terminal\n$ chainhook predicates scan stacking-pool-api.json --config-path=./Chainhook.toml\n```\n\nThe above command posts events to the URL `http://localhost:3000/events`, mentioned in the JSON file.\n\n## Initiate Chainhook service\n\nIn the examples above, your Chainhook scanned historical blockchain data against predicates and delivered results. In this next section, you will learn how to set up a Chainhook that acts as an ongoing observer and event-streaming service.\n\nYou can start a Chainhook service with an existing predicate. You can also dynamically register new predicates by making an API call to your chainhook. In both of these instances, your predicates will be delivering their results to a server set up to receive results.\n\nInitiate the chainhook service by passing the predicate path to the command as shown below:\n\n```terminal\n$ chainhook service start --predicate-path=stacking-pool-api.json --config-path=Chainhook.toml\n```\n\nThe above command registers the predicate based on the predicate definition in the `stacking-pool-api.json` file.\n\n## Dynamically register predicates\n\nYou can also dynamically register new predicates with your Chainhook service. This means you can start a long-running process that exposes HTTP endpoints to register, deregister, and report on new predicates.\n\n<Callout title=\"Requirements\" type=\"warn\">\nThis section requires that you have Redis running locally. To install, refer to the [Redis documentation](https://redis.io/docs/getting-started/).\n</Callout>\n\nFirst, ensure that the following lines of code are uncommented in the `Chainhook.toml` file to enable the predicate registration server:\n\n```toml\n[http_api]\nhttp_port = 20456\ndatabase_uri = \"redis://localhost:6379/\"\n```\n\nIf you have an instance of Redis running locally, you can now start the Chainhook service by running the following command:\n\n```terminal\n$ chainhook service start --config-path=Chainhook.toml\n```\n\nTo dynamically register a new predicate, send a POST request to the running predicate registration server at `localhost:20456/v1/chainhooks`.\n\nUse the following `curl` command template as an example:\n\n```terminal\n$ curl -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -d @predicate.json \\\n  http://localhost:20456/v1/chainhooks\n\n{\"result\":\"<uuid>\",\"status\":200}\n```\n\n<Callout title=\"Note\">\nYou can also run chainhook service by passing multiple predicates, ie `chainhook service start --predicate-path=predicate_1.json --predicate-path=predicate_2.json --config-path=Chainhook.toml`\n</Callout>\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/chainhook/guides/register-chainhooks-on-devnet\"\n    title=\"Register Chainhooks on devnet\"\n    description=\"Learn how to register Chainhooks on devnet.\"\n  />\n  <Card\n    href=\"/stacks/chainhook/references/scopes/bitcoin\"\n    title=\"Bitcoin scopes\"\n    description=\"Learn how to use scopes to scan for specific Bitcoin blockchain events.\"\n  />\n</Cards>"
  },
  {
    "title": "Observing contract calls with Chainhook",
    "description": "Learn how to use Chainhook to observe a function call for a voting contract.",
    "slug": "/stacks/chainhook/examples/observing-contract-calls",
    "content": "\nimport { Step, Steps } from \"fumadocs-ui/components/steps\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\n\nThe _json`contract_call`_ predicate scope is designed to target direct function calls within a smart contract. When triggered, Chainhook will return a payload with transaction data detailing the on-chain events contained in these functions.\n\nIn this guide, you will learn how to:\n\n1. [Build a predicate to target the `cast-vote` function](#creating-the-predicate).\n2. [Scan the Stacks blockchain using your predicate](#running-the-predicate).\n3. [Use a Clarity function to return specific contract data](#return-contract-data-with-the-clarity-function).\n4. [Find data related to the contract call within the Chainhook payload](#chainhook-payload).\n\n<Callout type=\"warn\" title=\"Requirements\">\n  To follow this guide, make sure you have installed Chainhook [directly](/stacks/chainhook/installation).\n</Callout>\n\n<Steps>\n<Step>\n\n## Create the predicate\n\nThe `predicate` is your main interface for querying the Chainhook data indexer. Chainhook uses this predicate to select the appropriate blockchain, network, and scope for monitoring transactions.\n\nFor the Stacks blockchain, run the following command to generate a `predicate` template:\n\n```terminal\n$ chainhook predicates new contract-call-chainhook.json --stacks\n```\n\n<Callout title=\"Note\">\n  Alternatively, [Hiro Platform](https://platform.hiro.so/) has an excellent UI to help you to create a `predicate` using a form builder or upload a json file containing your `predicate`.\n</Callout>\n\nThere are 3 main components to your `predicate` that you need to address:\n\n1. Targeting the appropriate blockchain and network\n2. Defining the scope and targeting the function you want to observe\n3. Defining the payload destination\n\nTo begin, you need to configure the `predicate` to target the voting contract:\n\n- Specify `testnet` in the network object.\n- Set the `start_block` property to <TooltipProvider inline><Tooltip><TooltipTrigger asChild><span className='cursor-default border-dotted border-b border-primary'>21443</span></TooltipTrigger><TooltipContent>This value represents the block height that our voting contract was deployed at.</TooltipContent></Tooltip></TooltipProvider>.\n\n```json contract-call-chainhook.json\n{\n  \"chain\": \"stacks\",\n  \"uuid\": \"1\",\n  \"name\": \"Contract-Call-Chainhook\",\n  \"version\": 1,\n  \"networks\": {\n    \"testnet\": {\n      \"start_block\": 21443,\n      \"decode_clarity_values\": true,\n      \"expire_after_occurrence\": 1,\n      // ...\n    }\n  }\n}\n```\n\nNext, define the scope of the `predicate` within the `if_this` specification.\n\nThe `contract_call` scope allows Chainhook to observe blockchain data when the specified function is directly called from its contract.\n\n```json contract-call-chainhook.json\n{\n  \"if_this\": {\n    \"scope\": \"contract_call\",\n    \"contract_identifier\": \"STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0\",\n    \"method\": \"cast-vote\"\n  }\n}\n```\n\n<Callout type=\"warn\" title=\"Warning\">\n  The function defined in the `method` property of your `predicate` must be directly called in order for Chainhook to observe events. Calling the function from another contract or from within a different function on the same contract will not generate a `payload`. Below is an example of a `cast-vote` function that would not trigger an event.\n  ```clarity\n  (define-public (call-cast-vote)\n    (cast-vote)\n  )\n  ```\n</Callout>\n\nFinally, define how Chainhook delivers the payload when it is triggered by your `predicate` using the `then_that` specification. \n\nUsing `file_append`, specify the path where Chainhook will post the payload data.\n\n```json contract-call-chainhook.json\n{\n  \"then_that\": {\n    \"file_append\": {\n      \"path\": \"/tmp/events.json\"\n    }\n  }\n}\n```\n\n<Accordion type=\"single\" collapsible className=\"w-full\">\n  <AccordionItem value=\"full-predicate\">\n    <AccordionTrigger>Full predicate file</AccordionTrigger>\n    <AccordionContent>\n      ```json\n      {\n        \"chain\": \"stacks\",\n        \"uuid\": \"1\",\n        \"name\": \"Contract-Call-Chainhook\",\n        \"version\": 1,\n        \"networks\": {\n          \"testnet\": {\n            \"start_block\": 21443,\n            \"decode_clarity_values\": true,\n            \"expire_after_occurrence\": 1,\n            \"if_this\": {\n              \"scope\": \"contract_call\",\n              \"contract_identifier\": \"STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0\",\n              \"method\": \"cast-vote\"\n            },\n            \"then_that\": {\n              \"file_append\": {\n                \"path\": \"/tmp/events.json\"\n              }\n            }\n          }\n        }\n      }\n      ```\n    </AccordionContent>\n  </AccordionItem>\n</Accordion>\n\n<Callout title=\"Note\">\n\n  For more details on optional configurations, other predicate elements and scopes, check out the [Predicate Design](/stacks/chainhook/concepts/predicate-design) and [Stacks scopes](/stacks/chainhook/references/scopes/stacks) pages.\n\n</Callout>\n\n</Step>\n<Step>\n\n## Scan the predicate\n\nWith your `predicate` set up, you can now scan for blocks that match the `contract_call` scope and analyze the returned payload.\n\nChainhook will track events where this function is directly invoked and deliver detailed transaction data at the block level, based on your configuration.\n\nTo scan the Stacks blockchain using your predicate, run the following command, replacing `/path/to/contract-call-chainhook.json` with the actual path to your `contract-call-chainhook.json` file:\n\n```terminal\n$ chainhook predicates scan /path/to/contract-call-chainhook.json --testnet\n```\n\n<Callout title=\"Note\">\n  If you are using Platform, creating your Chainhook will automatically begin the scan for you.\n</Callout>\n\n</Step>\n<Step>\n\n## Return contract data with the Clarity function\n\nThe _clarity`cast-vote`_ function records a vote by storing the address that calls it. It also logs relevant data using the _clarity`print`_ function, which can be useful for when you want to track additional on-chain events that are not part of the built-in Clarity functions.\n\nWhen you examine the `payload`, this is the data you will look for.\n\n```clarity simple-vote-v0.clar\n(define-public (cast-vote)\n  (begin\n    ;; Check if the voter has already voted.\n    (asserts! (is-none (map-get? UserVotes tx-sender)) (err ERR_ALREADY_VOTED))\n\n    ;; Update the map that the vote has been cast.  Print vote related data.\n    (map-set UserVotes tx-sender { hasVoted: true })\n    (var-set VoteCount (+ (var-get VoteCount) u1))\n    (print\n      {\n        notification: \"cast-vote\",\n        payload: {\n          status: \"Has voted set to true\",\n          voter: tx-sender,\n          totalVotes: (get-total-votes)\n        }\n      }\n    )\n    (ok \"Vote cast successfully\")\n  )\n)\n```\n\n<Callout title=\"Note\">\n  This contract has been deployed to the Stacks [testnet network](https://explorer.hiro.so/txid/0x312a3c559af0f75381a9eb4540912c310d74682ed3036207ec890ad8cd1aebe6?chain=testnet) under the name `STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0`.\n</Callout>\n\n</Step>\n<Step>\n\n## Dive deeper into the Chainhook payload\n\nWhen triggered by your predicate, the `payload` returned by Chainhook is a standarized, block level observation in json format.\n\nWithin the `apply` arrays element, the `block_identifer` object gives us the `index` for the observed block height.\n\n```json contract-call-payload.json\n\"block_identifier\": {\n  \"hash\": \"0x4d88015a6df9ec4f6df875941d87337ce64f8d51608563f80b6e27adeb327e4d\",\n  \"index\": 21544\n}\n```\n\n<Callout type=\"warn\" title=\"Warning\">\n  The hash returned in the `block_identifer` object is not that block hash you\n  would see in [Stacks Explorer](https://explorer.hiro.so/?chain=testnet), but\n  `index_block_hash` returned from the Stacks API's [get\n  block](/stacks/api/blocks/get-block) endpoint. You can use the `apply` array's\n  metadata object to get the `stacks_block_hash`.\n</Callout>\n\nWe can retrieve the `stacks_block_hash` by navigating to the `apply` arrays object `metadata` element. This hash will match the block hash display in the Stacks Explorer.\n\n```json contract-call-payload.json\n\"apply\": [\n  {\n    \"metadata\": {\n      \"stacks_block_hash\": \"0x4ad36f77ff76042f3b7355006556375970b0f99d1232b14a3b4a2eadda4a806a\"\n    }\n  }\n]\n```\n\nThere is also a `timestamp` value returned in the `apply` array. This UNIX time stamp represents the initiation of the Stacks block.\n\n```json contract-call-payload.json\n\"timestamp\": 1722208524\n```\n\n<Callout type=\"warn\" title=\"Warning\">\n  The timestamp returned in this object is not the finalized block time you\n  would see in the [Stacks Explorer](https://explorer.hiro.so/?chain=testnet), but\n  `block_time` returned from the Stacks API's [get\n  block](/stacks/api/blocks/get-block) endpoint.\n</Callout>\n\n### Transaction object\n\nBecause Chainhook is triggered on the block level, we will receive a single response that contains data specific to each `transaction` that matches your predicate's `contract_call` scope.\n\nTo find this data, we start with the `apply` array element of the `payload` object. The single object that makes up the `apply` array contains a child element, the `transactions` array. Every `transaction` will be represents by a single object within this array. This `transaction` object contains its own children elements which can be seen in the example below.\n\n```json\n{\n  \"apply\": [\n    {\n      \"transactions\": [\n        {\n          \"transaction_identifier\": { ... },\n          \"metdata\": { ... },\n          \"operations\": [],\n        }\n      ],\n    }\n  ],\n  \"rollback\": [ ... ],\n  \"chainhook\": { ... }\n}\n```\n\nOnce the `transaction` object is returned, we can begin examining the important data elements this object contains. The first element, `transaction_identifier`, includes a hash value that uniquely identifies your transaction.\n\n```json contract-call-payload.json\n\"transaction_identifier\": {\n  \"hash\": \"0x98195af8f888d2f9ca3462c41c1691e7798ea6d9e5e3afe42955c0921f981f2c\"\n}\n```\n\nNext, focus on the `metadata` object within your `contract_call` data. It's crucial to determine the success state of your transaction. Chainhook captures and reports on transactions regardless of their outcome.\n\nUtilize the `success` object to assess transaction success and extract the `sender` of the transaction and the `result` returned by the contract.\n\n```json contract-call-payload.json\n\"metadata\": {\n  \"success\": true,\n  \"sender\": \"STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV\",\n  \"result\": \"(ok \\\"Vote cast successfully\\\")\"\n}\n```\n\nMoving forward, examine the `kind` object and its components within your `contract_call`. The data object contains crucial information:\n\n- `contract_identifier` specifies the contract your function resides in\n- `method` identifies the function called\n- `args` lists the arguments passed when invoking this function\n\nIn this case, the `cast-vote` function accepts no arguments, resulting in an empty `args` array.\n\n```json contract-call-payload.json\n{\n  \"metadata\":\n  \"kind\": {\n    \"data\": {\n      \"args\": [],\n      \"contract_identifier\": \"STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0\",\n      \"method\": \"cast-vote\"\n    }\n  }\n}\n```\n\nIn the `metadata` object's `receipt`, the `events` array holds the key data for your `contract_call`.\n\nSince the `cast-vote` function uses a `print` statement, the events array will contain `topic` and `value` keys representing the data output.\n\n```json contract-call-payload.json\n{\n  \"metadata\":\n  \"receipt\": {\n    \"contract_calls_stack\": [],\n    \"events\": [\n      {\n        \"data\": {\n          \"contract_identifier\": \"STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0\",\n          \"topic\": \"print\",\n          \"value\": {\n            \"notification\": \"cast-vote\",\n            \"payload\": {\n              \"status\": \"Has voted set to true\",\n              \"totalVotes\": 1,\n              \"voter\": \"STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV\"\n            }\n          }\n        },\n        \"position\": {\n          \"index\": 0\n        },\n        \"type\": \"SmartContractEvent\"\n      }\n    ],\n    \"mutated_assets_radius\": [],\n    \"mutated_contracts_radius\": [\n      \"STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0\"\n    ]\n  }\n}\n```\n\n<Callout type=\"info\">\n  You can view the full [contract-call-payload.json](/contract-call-payload.json) here.\n</Callout>\n\n</Step>\n</Steps>\n\n---\n\nNow that you've located the relevant data in the payload, you can start to extract the relevant information into your API.\n\nThe following is an example of how you might store your information in a database table:\n\n| Block Height | Timestamp  | Transaction Identifier                                             | Success | Sender                                   | Result                        | Args | Contract Identifier                                     | Function  | Value                                                                                                                                                   |\n| ------------ | ---------- | ------------------------------------------------------------------ | ------- | ---------------------------------------- | ----------------------------- | ---- | ------------------------------------------------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 21544        | 1722208524 | 0x98195af8f888d2f9ca3462c41c1691e7798ea6d9e5e3afe42955c0921f981f2c | True    | STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV | (ok \"Vote cast successfully\") | []   | STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0 | cast-vote | \\{\"notification\": \"cast-vote\", \"payload\": \\{\"status\": \"Has voted set to true\", \"totalVotes\": 1, \"voter\": \"STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV\"\\}\\} |\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/platform/guides/create-chainhooks\"\n    title=\"Create a Chainhook\"\n    description=\"Learn how to create a Chainhook using the Hiro Platform.\"\n  />\n  <Card\n    href=\"/stacks/chainhook/references/scopes/stacks\"\n    title=\"Stacks scopes\"\n    description=\"Learn how to use additional scopes to scan for specific Stacks blockchain events.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Quickstart",
    "description": "Learn how to scan the Stacks blockchain for STX transactions.",
    "slug": "/stacks/chainhook/quickstart",
    "content": "\nimport { Accordion, Accordions } from \"fumadocs-ui/components/accordion\"\nimport { Steps, Step } from 'fumadocs-ui/components/steps';\n\nIn this quickstart guide, you will set up `Chainhook` to generate and scan predicates on the Stacks blockchain. You will learn how to generate predicates and run basic commands using the CLI to scan and inspect blockchain events.\n\nCheck out the [run Chainhook as a service](/stacks/chainhook/guides/chainhook-as-a-service) for a more advanced use case.\n\n<Steps>\n  <Step>\n    ## Generate a predicate file\n  \n    To generate a predicate file, use the `predicates new` command. This command generates a template that you can use to help set up your own predicate.\n\n    ```terminal\n    $ chainhook predicates new stx-transfer.json --stacks \n    ```\n\n    <Callout title=\"Note\">\n      The `--stacks` flag is required and allows you to specify the network to scan. Other options include `--bitcoin`.\n    </Callout>\n  </Step>\n  <Step>\n    ## Track the latest stx_event for a given address\n  \n    The generated file contains helpful boilerplate configuration, but you still need to make some edits to tell it to track specific Stacks-related transactions.\n\n    To do this, update your `if_this` construct in your `stx-transfer.json` file.\n\n    ```json title=\"stx-transfer.json\"\n    {\n      \"if_this\": {\n        \"scope\": \"stx_event\",\n        \"actions\": [\"transfer\"]\n      }\n    }\n    ```\n\n    <Accordions>\n      <Accordion title=\"Full code example\">\n        ```json\n          {\n            \"chain\": \"stacks\",\n            \"uuid\": \"87ac9bff-1052-4d02-9c79-3768a6f08a09\",\n            \"name\": \"STX Transfer\",\n            \"version\": 1,\n            \"networks\": {\n              \"mainnet\": {\n                \"start_block\": 154670,\n                \"if_this\": {\n                  \"scope\": \"stx_event\",\n                  \"contract_identifier\": \"SPM113AY78VCMJJ0SDFJ4XJXFHHQ6R9KB3710X7D\",\n                  \"actions\": [\"transfer\"]\n                },\n                \"then_that\": {\n                  \"file_append\": {\n                    \"path\": \"stx-transfers.txt\"\n                  }\n                }\n              }\n            }\n          }\n          ```\n      </Accordion>\n    </Accordions>\n  \n    <Callout title=\"Note\">\n      Other available `actions` include `mint`, `burn`, and `lock`. For more information on these actions, check out the [predicates](/stacks/chainhook/concepts/stacks-predicates) section.\n    </Callout>\n  </Step>\n  <Step>\n    ## Scanning for events\n  \n    With your updated predicate file, you can now use the `predicate scan` command to scan for `stx_event` transactions.\n\n    ```terminal\n    $ chainhook predicates scan /path/to/stx-transfer.json --mainnet\n    ```\n\n    <Callout title=\"Note\">\n      When running `scan` for the first time, a chainstate archive will be downloaded. The subsequent scans will use the cached chainstate if already present, speeding up iterations and the overall feedback loop. For more information on the Hiro Archive, click [here](/stacks/archive).\n    </Callout>\n  </Step>\n</Steps>\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/chainhook/guides/chainhook-as-a-service\"\n    title=\"Run Chainhook as a service\"\n    description=\"Learn how to run Chainhook as a service.\"\n  />\n  <Card\n    href=\"/bitcoin/indexer\"\n    title=\"Run the Bitcoin Indexer\"\n    description=\"Learn how to run the Bitcoin Indexer.\"\n  />\n  <Card\n    href=\"/guides/sync-a-stacks-node\"\n    title=\"Sync a Stacks node\"\n    description=\"Learn how to sync a Stacks node for running a local devnet.\"\n  />\n</Cards>"
  },
  {
    "title": "Predicate design",
    "description": "Predicates are the building blocks of Chainhook.",
    "slug": "/stacks/chainhook/predicate-design",
    "content": "\nThe core design of Chainhook revolves around the concept of predicates. Each individual chainhook has a customizable predicate that specifies what Bitcoin or Stacks blockchain data you are scanning for.\n\n<Callout type=\"warn\" title=\"Requirements\">\n  Commands outlined here will require that you have [installed Chainhook directly](/stacks/chainhook/installation) first.\n</Callout>\n\n## Predicate design\nBelow is the general strucure of the `predicate` JSON with its primary elements.  These elements and their values are required. \n\n- Chainhook will evaluate the predicate against the specfied blockchain specified in `chain`.\n- The `uuid` will be returned in the Chainhook payload, providing a record of the predicate that triggers it.\n- Identify your predicate for your app using `name` and `version`.\n\n```json\n  {\n    \"chain\": \"stacks\",\n    \"uuid\": \"1\",\n    \"name\": \"STX_Transfer_Predicate\",\n    \"version\": 1,\n    \"networks\": {\n      // Other configurations\n    }\n  }\n  ```\n\n<Callout type=\"info\" title=\"Note\">\n  You can use the following command to verify your predicate:\n  ```\n    chainhook predicate check your-predicate-file.json --mainnet\n  ```\n</Callout>\n\n## Networks\n\nThe `networks` element contains an object who's key determines the blockchain network you want Chainhook to scan.  \n- This object's value will contain the `if_this` and then `then_that` specifications.\n- Multple networks can be specified in the `networks` element.\n\n```json\n  \"networks\": {\n    \"mainnet\": {\n      // if_this and then_that specifications\n      // Other configurations\n    },\n    \"testnet\": {\n      // if_this and then_that specifications\n      // Other configurations\n    },\n  }\n```\n\n<Callout type=\"info\" title=\"Note\">\n  For additional information, check out the [Bitcoin scopes](/stacks/chainhook/references/scopes/bitcoin) and [Stacks scopes](/stacks/chainhook/references/scopes/stacks) references pages.\n</Callout>\n\n## if_this specification\n\nThe `predicate` identifies what data you want Chainhook to scan for using the `scope` define within the `if_this` specification.  Additional arguments specific to the `scope` will also be passed here.\n\n```json\n  {\n    \"if_this\": {\n      \"scope\": \"contract_call\",\n      \"contract_identifier\": \"STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0\",\n      \"method\": \"cast-vote\"\n    }\n  }\n```\n\n## then_that specification\n\nChainhook delivers the payload when it is triggered by your `predicate` using the `then_that` specification. There are 2 options available:\n\n1. `file_append`\n2. `http_post`\n\nWhen choosing to use file_append, specify the path where Chainhook will post the payload data.\n\n```json \n{\n  \"then_that\": {\n    \"file_append\": { \n      \"path\": \"/tmp/events.json\"\n    }\n  }\n}\n```\n\nWhen using `http_post`, specify the endpoint's `url` and `authorization_header`.\n\n```json\n{\n  \"then_that\": {\n    \"http_post\": {\n      \"url\": \"https://webhook.site/abc123456-789e-0fgh-1ijk-23lmno456789\",\n      \"authorization_header\": \"12345\"\n    }\n  }\n}\n```\n\n<Callout title=\"Note\">\n  Chainhook requires `https` to post to your endpoint. You can use a service like [LocalTunnel](https://github.com/localtunnel/localtunnel) to test locally or a site like [WebhookSite](https://webhook.site).\n</Callout>\n\n## Blockchain specific configurations\n\n<Tabs defaultValue=\"bitcoin\">\n  <TabsList>\n    <TabsTrigger value=\"bitcoin\">Bitcoin predicate</TabsTrigger>\n    <TabsTrigger value=\"stacks\">Stacks predicate</TabsTrigger>\n  </TabsList>\n\n  <TabsContent value=\"bitcoin\">\n    ```json\n    {\n      \"chain\": \"bitcoin\",\n      \"uuid\": \"1\",\n      \"name\": \"Wrap BTC\",\n      \"version\": 1,\n      \"networks\": {\n        \"testnet\": {\n          \"if_this\": {\n            \"scope\": \"ordinals_protocol\",\n            \"operation\": \"inscription_feed\"\n          },\n          \"then_that\": {\n            \"http_post\": {\n              \"url\": \"http://localhost:3000/api/v1/ordinals\",\n              \"authorization_header\": \"Bearer cn389ncoiwuencr\"\n            }\n          },\n          \"start_block\": 10200\n          // Additional configurations\n        },\n        \"mainnet\": {\n          \"if_this\": {\n            \"scope\": \"ordinals_protocol\",\n            \"operation\": \"inscription_feed\"\n          },\n          \"then_that\": {\n            \"http_post\": {\n              \"url\": \"http://my-protocol.xyz/api/v1/ordinals\",\n              \"authorization_header\": \"Bearer cn389ncoiwuencr\"\n            }\n          },\n          \"start_block\": 90232\n          // Additional configurations\n        }\n      }\n    }\n    ```\n\n    <Accordion type=\"single\" collapsible className=\"w-full\">\n      <AccordionItem value=\"start-block\">\n        <AccordionTrigger>Ignore blocks before start block</AccordionTrigger>\n        <AccordionContent>\n          ```json\n          \"start_block\": 101\n          ```\n        </AccordionContent>\n      </AccordionItem>\n      <AccordionItem value=\"end-block\">\n        <AccordionTrigger>Ignore blocks after end block</AccordionTrigger>\n        <AccordionContent>\n          ```json\n          \"end_block\": 201\n          ```\n        </AccordionContent>\n      </AccordionItem>\n      <AccordionItem value=\"expire\">\n        <AccordionTrigger>Stop after number of occurrences</AccordionTrigger>\n        <AccordionContent>\n          ```json\n          \"expire_after_occurrence\": 1\n          ```\n        </AccordionContent>\n      </AccordionItem>\n      <AccordionItem value=\"proofs\">\n        <AccordionTrigger>Exclude proofs from payload</AccordionTrigger>\n        <AccordionContent>\n          ```json\n          \"include_proof\": false\n          ```\n        </AccordionContent>\n      </AccordionItem>\n      <AccordionItem value=\"inputs\">\n        <AccordionTrigger>Exclude transaction inputs from payload</AccordionTrigger>\n        <AccordionContent>\n          ```json\n          \"include_inputs\": false\n          ```\n        </AccordionContent>\n      </AccordionItem>\n      <AccordionItem value=\"outputs\">\n        <AccordionTrigger>Exclude transaction outputs from payload</AccordionTrigger>\n        <AccordionContent>\n          ```json\n          \"include_outputs\": false\n          ```\n        </AccordionContent>\n      </AccordionItem>\n      <AccordionItem value=\"witness\">\n        <AccordionTrigger>Exclude transaction witnesses from payload</AccordionTrigger>\n        <AccordionContent>\n          ```json\n          \"include_witness\": false\n          ```\n        </AccordionContent>\n      </AccordionItem>\n    </Accordion>\n\n    <Callout type=\"info\" title=\"Note\">\n    The following command allows you to generate a predicate template for the Bitcoin blockchain.\n    ```\n      chainhook predicates new your-bitcoin-predicate.json --bitcoin\n    ```\n    </Callout>\n\n  </TabsContent>\n\n  <TabsContent value=\"stacks\">\n    ```json\n      {\n        \"chain\": \"stacks\",\n        \"uuid\": \"1\",\n        \"name\": \"Contract-Call-Chainhook\",\n        \"version\": 1,\n        \"networks\": {\n          \"testnet\": {\n            \"if_this\": {\n              \"scope\": \"contract_call\",\n              \"contract_identifier\": \"STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0\",\n              \"method\": \"cast-vote\"\n            },\n            \"then_that\": {\n              \"file_append\": {\n                \"path\": \"/tmp/events.json\"\n              }\n            },\n            \"start_block\": 21443\n            // Additional configurations\n          },\n          \"mainnet\": {\n            \"if_this\": {\n              \"scope\": \"contract_call\",\n              \"contract_identifier\": \"STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0\",\n              \"method\": \"cast-vote\"\n            },\n            \"then_that\": {\n              \"http_post\": {\n                \"url\": \"http://my-protocol.xyz/api/v1/ordinals\",\n                \"authorization_header\": \"Bearer cn389ncoiwuencr\"\n              }\n            },\n            \"start_block\": 142221\n            // Additional configurations\n          }\n        }\n      }\n    ```\n\n    <Accordion type=\"single\" collapsible className=\"w-full\">\n      <AccordionItem value=\"item-1\">\n        <AccordionTrigger>Additional Stacks predicate configurations</AccordionTrigger>\n        <AccordionContent>\n          <p>These additional configurations can be used to improve the performance of Chainhook by preventing a full scan of the blockchain:</p>\n\n          <p>Ignore any block before the given block:</p>\n\n          ```json\n          \"start_block\": 101\n          ```\n\n          <p>Ignore any block after the given block:</p>\n              \n          ```json\n          \"end_block\": 201\n          ```\n\n          <p>Stop evaluating chainhook after a given number of occurrences found:</p>\n\n          ```json\n          \"expire_after_occurrence\": 1\n          ```\n\n          <p>Include decoded Clarity values in the payload:</p>\n\n          ```json\n          \"decode_clarity_values\": true\n          ```\n\n          <p>Include the contract ABI for transactions that deploy contracts:</p>\n\n          ```json\n          \"include_contract_abi\": true\n          ```\n        </AccordionContent>\n      </AccordionItem>\n    </Accordion>\n\n    <Callout type=\"info\" title=\"Note\">\n    The following command allows you to generate a predicate template for the Stacks blockchain.\n    ```\n    chainhook predicates new your-stacks-predicate.json --stacks\n    ```\n    </Callout>\n\n  </TabsContent>\n</Tabs>\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/chainhook/guides/observing-contract-calls\"\n    title=\"Observing contract calls\"\n    description=\"Learn use a predicate to observe Stacks contracts calls with Chainhook.\"\n  />\n  <Card\n    href=\"/stacks/platform/guides/create-chainhooks\"\n    title=\"Create a chainhook\"\n    description=\"Learn how to create a chainhook using the Hiro Platform.\"\n  />\n  <Card\n    href=\"/stacks/chainhook/references/scopes/stacks\"\n    title=\"Stacks scopes\"\n    description=\"Learn how to use additional scopes to scan for specific Stacks blockchain events.\"\n  />\n  <Card\n    href=\"/stacks/chainhook/references/scopes/bitcoin\"\n    title=\"Bitcoin scopes\"\n    description=\"Learn how to use additional scopes to scan for specific Bitcoin blockchain events.\"\n  />\n</Cards>\n\n"
  },
  {
    "title": "Installation",
    "description": "Chainhook is a CLI tool that allows you to create event streams for your Stacks and Bitcoin nodes.",
    "slug": "/stacks/chainhook/installation",
    "content": "\n<Tabs defaultValue=\"macos\">\n  <TabsList>\n    <TabsTrigger value=\"macos\">macOS</TabsTrigger>\n    <TabsTrigger value=\"linux\">Linux</TabsTrigger>\n    <TabsTrigger value=\"windows\">Windows</TabsTrigger>\n    <TabsTrigger value=\"cargo\">Using Cargo</TabsTrigger>\n  </TabsList>\n\n  <TabsContent value=\"macos\">\n    ```terminal\n    $ brew install chainhook\n    ```\n  </TabsContent>\n\n  <TabsContent value=\"linux\">\n    ```terminal\n    $ sudo snap install chainhook\n    ```\n  </TabsContent>\n\n  <TabsContent value=\"windows\">\n    ```terminal\n    $ winget install HiroSystems.Chainhook\n    ```\n  </TabsContent>\n\n  <TabsContent value=\"cargo\">\n    Clone the [Chainhook Repo](https://github.com/hirosystems/chainhook):\n\n    ```terminal\n    $ git clone https://github.com/hirosystems/chainhook.git\n    ```\n\n    Navigate to the root directory and run `cargo chainhook-install`:\n\n    ```terminal\n    $ cd chainhook && cargo chainhook-install\n    ```\n  </TabsContent>\n</Tabs>"
  },
  {
    "title": "Quickstarts",
    "description": "The following guides cover ways to use Hiro tools to build apps on Stacks.",
    "slug": "/stacks/quickstarts/index",
    "content": "\nimport { Database, Ticket } from 'lucide-react';\nimport { Blockchain, BitcoinIcon, Clarinet, Container, DAO, Js, Plant, Shapes, StacksIcon } from '@/components/ui/icon';\nimport { SecondaryCard, SmallCard } from '@/components/card';\n\n<div className='flex flex-col space-y-10'>\n\n<Cards>\n  <SecondaryCard\n    icon={<Clarinet />}\n    href=\"/stacks/clarinet/quickstart\"\n    title=\"Create your first smart contract\"\n    description=\"Build a simple counter contract using Clarinet.\"\n    tag='Clarinet'\n  />\n  <SecondaryCard\n    icon={<Blockchain />}\n    href=\"/stacks/clarinet-js-sdk/quickstart\"\n    title=\"Write unit tests for your smart contracts\"\n    description=\"Learn how run unit tests with Clarinet JS SDK.\"\n    tag='Clarinet JS SDK'\n  />\n  <SecondaryCard\n    icon={<Js />}\n    href=\"/stacks/stacks.js/quickstart\"\n    title=\"Make a contract call with Stacks.js\"\n    description=\"Learn how to integrate smart contracts into your app.\"\n    tag='Stacks.js'\n  />\n  <SecondaryCard\n    icon={<Database />}\n    href=\"/stacks/chainhook/quickstart\"\n    title=\"Stream custom blockchain events\"\n    description=\"Use Chainhook to filter & stream for contract deployments.\"\n    tag='Chainhook'\n  />\n</Cards>\n\n<div className='flex flex-col'>\n\n<h4 id=\"learn-by-example\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#learn-by-example\" className=\"not-prose group text-sm uppercase\">Learn by example</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<Shapes />}\n    href=\"/guides/build-an-nft-marketplace\"\n    title=\"Build an NFT Marketplace\"\n    description=\"Learn how to create and deploy your own NFT marketplace.\"\n  />\n  {/* <SmallCard\n    icon={<DAO />}\n    href=\"/stacks/clarinet\"\n    title=\"Launch a Decentralized Autonomous Organization (DAO)\"\n    description=\"Discover the steps to creating your own DAO.\"\n  /> */}\n  <SmallCard\n    icon={<Ticket />}\n    href=\"/guides/no-loss-lottery\"\n    title=\"Create a no-loss lottery pool\"\n    description=\"Build a no-loss lottery pool that leverages stacking yield.\"\n  />\n  <SmallCard\n    icon={<Plant />}\n    href=\"/guides/build-a-decentralized-kickstarter\"\n    title=\"Build a decentralized Kickstarter\"\n    description=\"Learn how to create a crowdfunding app, enabling creators to fund their projects without a third party.\"\n  />\n</Cards>\n\n</div>\n\n<div className='flex flex-col'>\n\n<h4 id=\"installation-guides\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#installation-guides\" className=\"not-prose group text-sm uppercase\">Installation guides</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<BitcoinIcon />}\n    href=\"/guides/sync-a-bitcoin-node\"\n    title=\"Sync a Bitcoin node\"\n    description=\"Set up and run a Bitcoin node to run tools like Chainhook as a service.\"\n  />\n  <SmallCard\n    icon={<StacksIcon />}\n    href=\"/guides/sync-a-stacks-node\"\n    title=\"Sync a Stacks node\"\n    description=\"Set up and run a Stacks node to use tools like Chainhook or spin up your own API.\"\n  />\n  <SmallCard\n    icon={<Container />}\n    href=\"/guides/installing-docker\"\n    title=\"Install and run Docker on your machine\"\n    description=\"Essential for running a local development with Clarinet\"\n  />\n</Cards>\n\n</div>\n\n<Callout type=\"tip\">\nFor more, check out our [guides](/guides) section.\n</Callout>\n\n</div>\n"
  },
  {
    "title": "Event streaming",
    "description": "Stream events.",
    "slug": "/stacks/quickstarts/event-streaming",
    "content": "\nimport { Accordion, Accordions } from \"fumadocs-ui/components/accordion\";\nimport { Blocks, Braces, CircleUserRound } from 'lucide-react';\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\nThe `@stacks/blockchain-api-client` library provides a robust interface for interacting with the Stacks Blockchain API by offering type-safe methods to access REST and WebSocket endpoints.\n\nThe client includes automatically generated HTTP API methods, comprehensive Schemas for Clarity smart contract values, and a WebSocket client for real-time data streaming.\n\n```ts\nimport { AccountsApi } from '@stacks/blockchain-api-client';\n\nconst accounts = new AccountsApi(apiConfig);\n\nawait accounts.getAccountTransactions({\n  principal: 'ST000000000000000000002AMW42H',\n});\n```"
  },
  {
    "title": "Wallet integration",
    "description": "Integrate with a wallet.",
    "slug": "/stacks/quickstarts/wallet-integration",
    "content": "\nimport { Accordion, Accordions } from \"fumadocs-ui/components/accordion\";\nimport { Blocks, Braces, CircleUserRound } from 'lucide-react';\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\nThe `@stacks/blockchain-api-client` library provides a robust interface for interacting with the Stacks Blockchain API by offering type-safe methods to access REST and WebSocket endpoints.\n\nThe client includes automatically generated HTTP API methods, comprehensive Schemas for Clarity smart contract values, and a WebSocket client for real-time data streaming.\n\n```ts\nimport { AccountsApi } from '@stacks/blockchain-api-client';\n\nconst accounts = new AccountsApi(apiConfig);\n\nawait accounts.getAccountTransactions({\n  principal: 'ST000000000000000000002AMW42H',\n});\n```"
  },
  {
    "title": "App templates",
    "description": "Build your app with a template.",
    "slug": "/stacks/quickstarts/app-templates",
    "content": "\nimport { Accordion, Accordions } from \"fumadocs-ui/components/accordion\";\nimport { Blocks, Braces, CircleUserRound } from 'lucide-react';\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\nThe `@stacks/blockchain-api-client` library provides a robust interface for interacting with the Stacks Blockchain API by offering type-safe methods to access REST and WebSocket endpoints.\n\nThe client includes automatically generated HTTP API methods, comprehensive Schemas for Clarity smart contract values, and a WebSocket client for real-time data streaming.\n\n```ts\nimport { AccountsApi } from '@stacks/blockchain-api-client';\n\nconst accounts = new AccountsApi(apiConfig);\n\nawait accounts.getAccountTransactions({\n  principal: 'ST000000000000000000002AMW42H',\n});\n```"
  },
  {
    "title": "NFT minting",
    "description": "Mint an NFT.",
    "slug": "/stacks/quickstarts/nft-minting",
    "content": "\nimport { Accordion, Accordions } from \"fumadocs-ui/components/accordion\";\nimport { Blocks, Braces, CircleUserRound } from 'lucide-react';\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\nThe `@stacks/blockchain-api-client` library provides a robust interface for interacting with the Stacks Blockchain API by offering type-safe methods to access REST and WebSocket endpoints.\n\nThe client includes automatically generated HTTP API methods, comprehensive Schemas for Clarity smart contract values, and a WebSocket client for real-time data streaming.\n\n```ts\nimport { AccountsApi } from '@stacks/blockchain-api-client';\n\nconst accounts = new AccountsApi(apiConfig);\n\nawait accounts.getAccountTransactions({\n  principal: 'ST000000000000000000002AMW42H',\n});\n```"
  },
  {
    "title": "Contract templates",
    "description": "Build your contract with a template.",
    "slug": "/stacks/quickstarts/contract-templates",
    "content": "\nimport { Accordion, Accordions } from \"fumadocs-ui/components/accordion\";\nimport { Blocks, Braces, CircleUserRound } from 'lucide-react';\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\nThe `@stacks/blockchain-api-client` library provides a robust interface for interacting with the Stacks Blockchain API by offering type-safe methods to access REST and WebSocket endpoints.\n\nThe client includes automatically generated HTTP API methods, comprehensive Schemas for Clarity smart contract values, and a WebSocket client for real-time data streaming.\n\n```ts\nimport { AccountsApi } from '@stacks/blockchain-api-client';\n\nconst accounts = new AccountsApi(apiConfig);\n\nawait accounts.getAccountTransactions({\n  principal: 'ST000000000000000000002AMW42H',\n});\n```"
  },
  {
    "title": "Token transfers",
    "description": "Transfer tokens.",
    "slug": "/stacks/quickstarts/token-transfers",
    "content": "\nimport { Accordion, Accordions } from \"fumadocs-ui/components/accordion\";\nimport { Blocks, Braces, CircleUserRound } from 'lucide-react';\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\nThe `@stacks/blockchain-api-client` library provides a robust interface for interacting with the Stacks Blockchain API by offering type-safe methods to access REST and WebSocket endpoints.\n\nThe client includes automatically generated HTTP API methods, comprehensive Schemas for Clarity smart contract values, and a WebSocket client for real-time data streaming.\n\n```ts\nimport { AccountsApi } from '@stacks/blockchain-api-client';\n\nconst accounts = new AccountsApi(apiConfig);\n\nawait accounts.getAccountTransactions({\n  principal: 'ST000000000000000000002AMW42H',\n});\n```"
  },
  {
    "title": "Blocks",
    "description": "Get block proposal information.",
    "slug": "/stacks/rpc-api/blocks/index",
    "content": ""
  },
  {
    "title": "Validate proposed block",
    "description": "Validate a proposed Stacks block.",
    "slug": "/stacks/rpc-api/blocks/block-proposal",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/block_proposal', method: 'post' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Proof of Transfer",
    "description": "Retrieves Proof-of-Transfer (PoX) information.",
    "slug": "/stacks/rpc-api/pox/index",
    "content": ""
  },
  {
    "title": "Get stacker and signer set information",
    "description": "Retrieves stacker and signer set information for a given cycle.",
    "slug": "/stacks/rpc-api/pox/stacker-set",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/stacker_set/{cycle_number}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get Proof-of-Transfer details",
    "description": "Retrieves Proof-of-Transfer (PoX) information.",
    "slug": "/stacks/rpc-api/pox/pox-details",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/pox', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get namespace price",
    "description": "Retrieves the price of a namespace.",
    "slug": "/stacks/rpc-api/names/namespace-price",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/prices/namespaces/{tld}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Names",
    "description": "Manages and retrieve information on blockchain namespaces, names, and related details.",
    "slug": "/stacks/rpc-api/names/index",
    "content": ""
  },
  {
    "title": "Get name price",
    "description": "Retrieves the price of a name.",
    "slug": "/stacks/rpc-api/names/name-price",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/prices/names/{name}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get approximate fees for the given transaction",
    "description": "Get an estimated fee for the supplied transaction.",
    "slug": "/stacks/rpc-api/fees/estimate",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/fees/transaction', method: 'post' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Fees",
    "description": "Provide estimates, rates, and approximate calculations for transaction costs.",
    "slug": "/stacks/rpc-api/fees/index",
    "content": ""
  },
  {
    "title": "Get transfer fee estimate",
    "description": "Retrieves an estimated fee rate for STX transfer transactions.",
    "slug": "/stacks/rpc-api/fees/transfer-estimate",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/fees/transfer', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Overview",
    "description": "Query the Stacks Node RPC API, interact with smart contracts, and broadcast transactions all via a familiar REST interface.",
    "slug": "/stacks/rpc-api/index",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nThe Stacks Node RPC API allows you to query the Stacks blockchain and interact with smart contracts. Note: this is not a Hiro-maintained service. This RPC API is generated by every Stacks node and allows you to self-host your own node and API. This is a minimalist configuration. For a richer data set and an API that is easier to use, try [Hiro's Stacks Blockchain API](/stacks/api).\n\n## Popular endpoints\n\n<Cards>\n  <SecondaryCard\n    href=\"/stacks/rpc-api/transactions/broadcast-transaction\"\n    title=\"Broadcast transaction\"\n    description=\"Broadcast a transaction to the Stacks network.\"\n  />\n  <SecondaryCard\n    href=\"/stacks/rpc-api/smart-contracts/read-only\"\n    title=\"Call smart contracts\"\n    description=\"Call a read-only public function on a smart contract.\"\n  />\n    <SecondaryCard\n    href=\"/stacks/rpc-api/pox/pox-details\"\n    title=\"Retrieve PoX protocol details\"\n    description=\"Get Proof of Transfer (PoX) details, including cycles and stacking thresholds.\"\n  />\n  \n</Cards>\n\n## Related tools\n\n- **[Stacks Blockchain API](/stacks/api)**: Fetch richer data from Hiro's Stacks Blockchain API.\n- **[Token Metadata API](/stacks/token-metadata-api)**: Fetch fungible and non-fungible token data on the Stacks blockchain.\n- **[Stacks Explorer](https://explorer.hiro.so)**: Verify activity on the Stacks blockchain with an easy-to-use front end.\n\n<br />\n\n<Callout title=\"Need help building with the Stacks Node RPC API?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#api</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>\n\n\n"
  },
  {
    "title": "Info",
    "description": "Retrieves information about the Core API and the Stacks network.",
    "slug": "/stacks/rpc-api/info/index",
    "content": ""
  },
  {
    "title": "Get core API info",
    "description": "Retrieves information about the Core API, including the server version.",
    "slug": "/stacks/rpc-api/info/core-api",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/info', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Broadcast transaction",
    "description": "Broadcasts raw transactions on the network.",
    "slug": "/stacks/rpc-api/transactions/broadcast-transaction",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/transactions', method: 'post' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Transactions",
    "description": "Manage, retrieve, and broadcast transaction data on the blockchain.",
    "slug": "/stacks/rpc-api/transactions/index",
    "content": ""
  },
  {
    "title": "Accounts",
    "description": "Get account information.",
    "slug": "/stacks/rpc-api/accounts/index",
    "content": ""
  },
  {
    "title": "Get account info",
    "description": "Retrieves the account data for a given account or contract identifier.",
    "slug": "/stacks/rpc-api/accounts/info",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/accounts/{principal}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "v3",
    "description": "Version 3 of the RPC API.",
    "slug": "/stacks/rpc-api/v3/index",
    "content": ""
  },
  {
    "title": "Get Nakamoto tenure metadata",
    "description": "Fetch metadata about the ongoing Nakamoto tenure.",
    "slug": "/stacks/rpc-api/v3/tenure-metadata",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v3/tenures/info', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get Nakamoto block",
    "description": "Fetch a Nakamoto block by its index block hash.",
    "slug": "/stacks/rpc-api/v3/nakamoto-block",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v3/blocks/{block_id}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get Nakamoto tenure blocks",
    "description": "Fetch a sequence of Nakamoto blocks in a tenure.",
    "slug": "/stacks/rpc-api/v3/tenure-blocks",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v3/tenures/{block_id}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get contract interface",
    "description": "Retrieves a list of functions, variables, maps, fungible tokens and non-fungible tokens for a given smart contract.",
    "slug": "/stacks/rpc-api/smart-contracts/interface",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/contracts/interface/{contract_address}/{contract_name}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get trait implementation details",
    "description": "Determine whether or not a specified trait is implemented (either explicitly or implicitly) within a given contract.",
    "slug": "/stacks/rpc-api/smart-contracts/traits",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/traits/{contract_address}/{contract_name}/{trait_contract_address}/{trait_contract_name}/{trait_name}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Smart contracts",
    "description": "Provide information and facilitate interactions with smart contracts.",
    "slug": "/stacks/rpc-api/smart-contracts/index",
    "content": ""
  },
  {
    "title": "Get contract map entry",
    "description": "Retrieves a specific entry from a contract data map.",
    "slug": "/stacks/rpc-api/smart-contracts/map-entry",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/map_entry/{contract_address}/{contract_name}/{map_name}', method: 'post' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Call read-only function",
    "description": "Calls a read-only public function on a given smart contract.",
    "slug": "/stacks/rpc-api/smart-contracts/read-only",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/contracts/call-read/{contract_address}/{contract_name}/{function_name}', method: 'post' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get contract source",
    "description": "Retrieves the Clarity source code of a given contract, along with the block height it was published in, and the MARF proof for the data.",
    "slug": "/stacks/rpc-api/smart-contracts/source",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/contracts/source/{contract_address}/{contract_name}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get constant value",
    "description": "Get the value of a constant inside a contract.",
    "slug": "/stacks/rpc-api/smart-contracts/constants",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/constant_val/{contract_address}/{contract_name}/{constant_name}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Burn operations",
    "description": "Get burn operations of type `op_type` successfully read at `burn_height`.",
    "slug": "/stacks/rpc-api/burn-ops/index",
    "content": ""
  },
  {
    "title": "Get burn operations",
    "description": "Get all burn operations of type `op_type` successfully read at `burn_height`.",
    "slug": "/stacks/rpc-api/burn-ops/get-burn-operations",
    "content": "\n<APIPage\n  document=\"./openapi/stacks-node-rpc-api.json\"\n  operations={[{ path: '/v2/burn_ops/{burn_height}/{op_type}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Contributors guide",
    "description": "Learn how to contribute to Hiro's documentation and content.",
    "slug": "/bitcoin/contributors-guide",
    "content": "\nimport ContributorsGuideContent from '@/content/_shared/contributors-guide.mdx';\n\n<ContributorsGuideContent components={props.components} />\n"
  },
  {
    "title": "Get started",
    "description": "The following guides cover ways to use Hiro tools to build with Ordinals, BRC-20, and Runes.",
    "slug": "/bitcoin/get-started",
    "content": "\nimport { SecondaryCard, SmallCard } from '@/components/card';\nimport { API, Container, Chainhook, BitcoinIcon } from '@/components/ui/icon';\n\n<div className='flex flex-col space-y-10'>\n\n<Cards>\n  <SecondaryCard\n    className=\"group\"\n    icon={<API className='transition-colors duration-500 ease-in-out group-hover:text-primary' />}\n    href=\"/bitcoin/ordinals/api\"\n    title=\"Integrate ordinals data into your app\"\n    description=\"Use the Ordinals API to get reliable data for Ordinals and BRC-20 tokens.\"\n    tag='Ordinals API'\n  />\n  <SecondaryCard\n    className=\"group\"\n    icon={<Chainhook className='transition-colors duration-500 ease-in-out group-hover:text-primary' />}\n    href=\"/bitcoin/indexer\"\n    title=\"Stream custom blockchain events\"\n    description=\"Use the Bitcoin Indexer to filter and stream for contract deployments.\"\n    tag='Bitcoin Indexer'\n  />\n  <SecondaryCard\n    className=\"group\"\n    icon={<API className='transition-colors duration-500 ease-in-out group-hover:text-primary' />}\n    href=\"/bitcoin/runes/api\"\n    title=\"Get Runes data\"\n    description=\"Use Runes API to get reliable data for Runes.\"\n    tag='Runes API'\n  />\n</Cards>\n\n<Callout type=\"tip\">\nFor more, check out our [guides](/guides) section.\n</Callout>\n\n</div>\n"
  },
  {
    "title": "Rate limiting",
    "description": "Understand the rate limits for Hiro APIs and the STX Faucet.",
    "slug": "/bitcoin/rate-limiting",
    "content": "\nimport RateLimitingContent from '@/content/_shared/rate-limiting.mdx';\n\n<RateLimitingContent components={props.components} />\n"
  },
  {
    "title": "Overview",
    "description": "Runehook enables you to build Rune event streams, so you can create accurate, lightweight databases that gracefully handle Bitcoin forks and reorgs.",
    "slug": "/bitcoin/runes/runehook/index",
    "content": "\nimport { Step, Steps } from 'fumadocs-ui/components/steps';\n\nRunehook is a reorg-aware indexer that automatically handles chain forks, so you don’t need to waste time or resources reindexing your database yourself.\n\nWith a familiar event-driven framework, you can customize what Rune data you index in order to create lightweight databases for faster query responses and a better user experience.\n\n### Create event streams\n\n\n### Related tools\n\n- **[Runes API](/bitcoin/runes/api)**: Skip the infrastructure setup and get the runes data you need from our Runes API, which is powered by Runehook.\n- **[Ordinals Explorer](/ordinals/explorer)**: Explore Ordinals inscriptions and BRC-20 tokens rapidly in our Ordinals Explorer.\n\n---\n\n_Need help building with Runehook?_ Reach out to us on the `#chainhook` channel on Discord under **Hiro Developer Tools** section. We also host a weekly office hours on Discord every Monday at 11am ET.\n"
  },
  {
    "title": "Quickstart",
    "description": "Learn how to scan the Bitcoin blockchain for Runes activity.",
    "slug": "/bitcoin/runes/runehook/quickstart",
    "content": "\nimport { ChevronRight, Code, Terminal } from 'lucide-react';\nimport { File, Folder, Files } from 'fumadocs-ui/components/files';\nimport { Step } from 'fumadocs-ui/components/steps';\nimport { SmallCard } from '@/components/card';\n\nIn this quickstart guide, you will set up `runehook` to explore and index Rune activity on the Bitcoin blockchain. You will learn how to install, configure, and run basic commands to scan and stream Rune inscriptions and transfers.\n\n{/* Check out the [Runehook as a service](/bitcoin/runehook/guides/runehook-as-a-service) for a more advanced use case. */}\n\n---\n\n### Prerequisites\n\nBefore starting, ensure you have `runehook` installed. If you haven't already, check out the [installation](/bitcoin/runehook/installation) guide.\n\n---\n\n### Next steps\n\n<Cards className='sm:grid-cols-1'>\n  <SmallCard\n    icon={<Code />}\n    href=\"/bitcoin/runes/api\"\n    title=\"Integrate runes data into your app\"\n    description=\"Use the Runes API to get reliable data for Runes and BRC-20 tokens.\"\n    tag='Runes API'\n  />\n</Cards>\n"
  },
  {
    "title": "Installation",
    "description": "Runehook was developed to be environment-agnostic. Below are the different ways to install and build the Bitcoin Indexer on your machine.",
    "slug": "/bitcoin/runes/runehook/installation",
    "content": "Clone the [Runehook repository](https://github.com/hirosystems/runehook) to your local machine and install via `cargo`.\n\n```terminal\n$ git clone https://github.com/hirosystems/runehook.git\n$ cd runehook\n$ cargo runehook-install\n```"
  },
  {
    "title": "Overview",
    "description": "Explore and verify ordinals and BRC-20 data on Bitcoin.",
    "slug": "/bitcoin/runes/explorer/index",
    "content": "\nimport Link from \"next/link\";\nimport { Button } from \"@/components/ui/button\"\n\nThe Ordinals Explorer lets you explore and verify Bitcoin Ordinals and BRC-20 token data. You can also use a variety of filters to discover inscriptions. We maintain and support the [Ordinals Explorer](https://ordinals.hiro.so) as a service for the community, but you can also run your own instance of the explorer if you so choose.\n\n<div className=\"flex gap-4\">\n  <Button className=\"bg-orange-500 hover:bg-orange-600\">\n    <a href=\"https://ordinals.hiro.so\" target=\"_blank\" className=\"no-underline\">\n      View Ordinals Explorer\n    </a>\n  </Button>\n  <Button variant=\"outline\">\n    <Link\n      href=\"/bitcoin/explorer/guides/build-explorer\"\n      className=\"no-underline\"\n    >\n      Set up your own explorer\n    </Link>\n  </Button>\n</div>\n\n### Related tools\n\n- **[Ordinals API](/bitcoin/ordinals/api)**: Looking for on-chain data without the front end? Leverage the Ordinals API.\n- **[Stacks Explorer](https://explorer.hiro.so)**: Looking for a front end to verify activity on the Stacks blockchain? Try the Stacks Explorer.\n\n---\n\nNeed help building with the Ordinals Explorer? Reach out to us on the `#ordinals` channel on Discord under the [Hiro Developer Tools section](https://stacks.chat/). There’s also a [weekly office hours](https://events.stacks.co/event/HD16484710) on Discord every Thursday at 11am ET.\n"
  },
  {
    "title": "Build Ordinals Explorer",
    "description": "",
    "slug": "/bitcoin/runes/explorer/guides/build-explorer",
    "content": "\nAfter installing and configuring your environment, you can run the Ordinals Explorer locally if you wish by running the followning `npm` command:\n\n`npm run dev`\n\n## Building for production\n\nYou may also build a production version of the Ordinals Explorer. To do that, simply run the following command:\n\n`npm run build`\n\n<Callout>\n  Running `npm run build` also run the default next.js build task.\n</Callout>\n"
  },
  {
    "title": "Overview",
    "description": "The Runes API provides you with fast, reliable data for Bitcoin Runes via an easy-to-use REST interface.",
    "slug": "/bitcoin/runes/api/index",
    "content": "\nThe Runes API is a service that helps you with the complete ingestion of Bitcoin Runes data. Using our endpoints, you can retrieve metadata for a particular rune, trading activity, all runes held by a particular address, and more.\n\nThe Runes API uses REST endpoints and cached responses in order to optimize performance and reduce unnecessary requests. Reliable, consistent runes data, one request away.\n\n## Popular endpoints\n\n<Cards>\n  <Card\n    href=\"/bitcoin/runes/api/etchings/get-etchings\"\n    title=\"Fetch Runes\"\n    description=\"Retrieves a list of etchings.\"\n  />\n  <Card\n    href=\"/bitcoin/runes/api/balances/holders\"\n    title=\"Showcase user portfolios\"\n    description=\"Retrieves a list of Rune holders.\"\n  />\n  <Card\n    href=\"/bitcoin/runes/api/activities/activity\"\n    title=\"Track your favorite Runes\"\n    description=\"Retrieves all activity for a Rune.\"\n  />\n</Cards>\n\n### Related tools\n\n{/* - **[Runehook](/bitcoin/runes/runeshook)**: Want to run your own infra? [Set up your own Runehook](/bitcoin/runes/runeshook/guides/runehook-as-a-service), the indexer that powers the Rune API. */}\n- **[Ordinals API](/bitcoin/ordinals/api)**: Looking for on-chain ordinals data without the front end? Leverage the Ordinals API.\n- **[Ordinals Explorer](https://ordinals.hiro.so/)**: The Ordinals API powers Hiro’s Ordinals Explorer, which lets you rapidly discover inscriptions and verify on-chain activity.\n\n---\n\nNeed help building with Runes API? Reach out to us on the `#ordinals` channel on Discord. Or join us at our weekly office hours on Discord every Monday at 11am ET.\n"
  },
  {
    "title": "Status",
    "description": "Retrieves information about the Rune API status.",
    "slug": "/bitcoin/runes/api/info/index",
    "content": ""
  },
  {
    "title": "Get API Status",
    "description": "Retrieves the status of the API.",
    "slug": "/bitcoin/runes/api/info/status",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get address balances",
    "description": "Retrieves a paginated list of address balances.",
    "slug": "/bitcoin/runes/api/balances/address",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/addresses/{address}/balances', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Balances",
    "description": "Retrieves information about Rune balances.",
    "slug": "/bitcoin/runes/api/balances/index",
    "content": ""
  },
  {
    "title": "Get holder balance",
    "description": "Retrieves holder balance for a specific Rune.",
    "slug": "/bitcoin/runes/api/balances/holder-balance",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings/{etching}/holders/{address}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get rune holders",
    "description": "Retrieves a paginated list of holders for a Rune.",
    "slug": "/bitcoin/runes/api/balances/holders",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings/{etching}/holders', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Activities",
    "description": "Retrieves information about Rune activities.",
    "slug": "/bitcoin/runes/api/activities/index",
    "content": ""
  },
  {
    "title": "Get activity for a transaction",
    "description": "Retrieves a paginated list of rune activity for a transaction.",
    "slug": "/bitcoin/runes/api/activities/for-transaction",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/transactions/{tx_id}/activity', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get activity for an address",
    "description": "Retrieves all Rune activity for a Bitcoin address.",
    "slug": "/bitcoin/runes/api/activities/for-address",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings/{etching}/activity/{address}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get activity for a block",
    "description": "Retrieves a paginated list of rune activity for a block.",
    "slug": "/bitcoin/runes/api/activities/for-block",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/blocks/{block}/activity', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get all activity",
    "description": "Retrieves all activity for a Rune.",
    "slug": "/bitcoin/runes/api/activities/activity",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings/{etching}/activity', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Usage",
    "description": "Create your first project in less than 2 minutes",
    "slug": "/bitcoin/runes/api/usage",
    "content": "\nThe Usage section should focus on practical, hands-on instructions for getting started with the API. This includes:\nAuthentication: How to authenticate with the API (e.g., API keys, OAuth tokens).\nMaking Requests: Basic examples of making requests to the API, including request format, essential headers, and parameters.\nHandling Responses: Information on response structure, understanding status codes, and error handling.\nRate Limits: If applicable, explain any rate limits and best practices for avoiding them.\nThe goal of the \"Usage\" section is to equip developers with the knowledge to make successful API calls and handle responses effectively.\n"
  },
  {
    "title": "Etchings",
    "description": "Retrieves information about Rune etchings.",
    "slug": "/bitcoin/runes/api/etchings/index",
    "content": ""
  },
  {
    "title": "Get etchings",
    "description": "Retrieves a paginated list of rune etchings.",
    "slug": "/bitcoin/runes/api/etchings/get-etchings",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get etching",
    "description": "Retrieves information for a Rune etching.",
    "slug": "/bitcoin/runes/api/etchings/get-etching",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings/{etching}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Overview",
    "description": "Explore and verify ordinals and BRC-20 data on Bitcoin.",
    "slug": "/bitcoin/ordinals/explorer/index",
    "content": "\nimport Link from \"next/link\";\nimport { Button } from \"@/components/ui/button\"\n\nThe Ordinals Explorer lets you explore and verify Bitcoin Ordinals and BRC-20 token data. You can also use a variety of filters to discover inscriptions. We maintain and support the [Ordinals Explorer](https://ordinals.hiro.so) as a service for the community, but you can also run your own instance of the explorer if you so choose.\n\n<div className=\"flex gap-4\">\n  <Button className=\"bg-orange-500 hover:bg-orange-600\">\n    <a href=\"https://ordinals.hiro.so\" target=\"_blank\" className=\"no-underline\">\n      View Ordinals Explorer\n    </a>\n  </Button>\n  <Button variant=\"outline\">\n    <Link\n      href=\"/bitcoin/explorer/guides/build-explorer\"\n      className=\"no-underline\"\n    >\n      Set up your own explorer\n    </Link>\n  </Button>\n</div>\n\n## Related tools\n\n- **[Ordinals API](/bitcoin/ordinals/api)**: Looking for on-chain data without the front end? Leverage the Ordinals API.\n- **[Stacks Explorer](https://explorer.hiro.so)**: Looking for a front end to verify activity on the Stacks blockchain? Try the Stacks Explorer.\n\n---\n\nNeed help building with the Ordinals Explorer? Reach out to us on the `#ordinals` channel on Discord under the [Hiro Developer Tools section](https://stacks.chat/). There’s also a [weekly office hours](https://events.stacks.co/event/HD16484710) on Discord every Thursday at 11am ET.\n"
  },
  {
    "title": "Build Ordinals Explorer",
    "description": "",
    "slug": "/bitcoin/ordinals/explorer/guides/build-explorer",
    "content": "\nAfter installing and configuring your environment, you can run the Ordinals Explorer locally if you wish by running the followning `npm` command:\n\n`npm run dev`\n\n## Building for production\n\nYou may also build a production version of the Ordinals Explorer. To do that, simply run the following command:\n\n`npm run build`\n\n<Callout title=\"Note\" type=\"info\">\n  Running `npm run build` also run the default next.js build task.\n</Callout>\n"
  },
  {
    "title": "Statistics",
    "description": "Retrieves stats on the number of inscriptions per block.",
    "slug": "/bitcoin/ordinals/api/statistics/index",
    "content": ""
  },
  {
    "title": "Get inscription count per block",
    "description": "Retrieves statistics on the number of inscriptions revealed per block.",
    "slug": "/bitcoin/ordinals/api/statistics/get-stats-inscription-count",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/stats/inscriptions', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get BRC-20 token holders",
    "description": "Retrieves a list of holders and their balances for a particular BRC-20 token.",
    "slug": "/bitcoin/ordinals/api/brc20/get-brc20-token-holders",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/brc-20/tokens/{ticker}/holders', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "BRC-20",
    "description": "Retrieves information about BRC-20 tokens.",
    "slug": "/bitcoin/ordinals/api/brc20/index",
    "content": ""
  },
  {
    "title": "Get BRC-20 balances",
    "description": "Retrieves BRC-20 token balances for a Bitcoin address.",
    "slug": "/bitcoin/ordinals/api/brc20/get-brc20-balances",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/brc-20/balances/{address}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get BRC-20 token details",
    "description": "Retrieves information for a BRC-20 token, including supply and holders.",
    "slug": "/bitcoin/ordinals/api/brc20/get-brc20-token-details",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/brc-20/tokens/{ticker}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get BRC-20 tokens",
    "description": "Retrieves information for BRC-20 tokens.",
    "slug": "/bitcoin/ordinals/api/brc20/get-brc20-tokens",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/brc-20/tokens', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get BRC-20 activity",
    "description": "Retrieves BRC-20 activity filtered by ticker, address, operation, or block height.",
    "slug": "/bitcoin/ordinals/api/brc20/get-brc20-activity",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/brc-20/activity', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Inscriptions",
    "description": "Retrieves information about Ordinals inscriptions.",
    "slug": "/bitcoin/ordinals/api/inscriptions/index",
    "content": ""
  },
  {
    "title": "Get inscription transfers",
    "description": "Retrieves all transfers for a single inscription.",
    "slug": "/bitcoin/ordinals/api/inscriptions/get-inscription-transfers",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/inscriptions/{id}/transfers', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get inscriptions",
    "description": "Retrieves a list of inscriptions with options to filter and sort results.",
    "slug": "/bitcoin/ordinals/api/inscriptions/get-inscriptions",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/inscriptions', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get inscription content",
    "description": "Retrieves the content of a single inscription.",
    "slug": "/bitcoin/ordinals/api/inscriptions/get-inscription-content",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/inscriptions/{id}/content', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get transfers per block",
    "description": "Retrieves a list of inscription transfers that ocurred at a specific Bitcoin block.",
    "slug": "/bitcoin/ordinals/api/inscriptions/get-transfers-per-block",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/inscriptions/transfers', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get inscription",
    "description": "Retrieves a single inscription.",
    "slug": "/bitcoin/ordinals/api/inscriptions/get-inscription",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/inscriptions/{id}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Overview",
    "description": "The Ordinals API provides you with fast, reliable data for Bitcoin ordinals and BRC-20 tokens via an easy-to-use REST interface.",
    "slug": "/bitcoin/ordinals/api/index",
    "content": "\nimport { SecondaryCard } from '@/components/card';\n\nThe Ordinals API is a service that helps you with the complete ingestion of ordinals inscription data. Using our endpoints, you can retrieve metadata for a particular inscription, trading activity, all inscriptions held by a particular address, and more.\n\nThe Ordinals API uses REST endpoints and cached responses in order to optimize performance and reduce unnecessary requests. Start integrating ordinals and BRC-20 tokens into your app with one of the most reliable APIs on the market today.\n\n## Popular endpoints\n\n<Cards>\n  <SecondaryCard\n    href=\"/bitcoin/ordinals/api/inscriptions/get-inscription-content\"\n    title=\"Fetch Ordinals content\"\n    description=\"Retrieve all metadata related to individual inscriptions.\"\n  />\n  <SecondaryCard\n    href=\"/bitcoin/ordinals/api/brc20/get-brc20-tokens\"\n    title=\"Integrate BRC-20 tokens\"\n    description=\"Retrieve all metadata related to BRC-20 tokens.\"\n  />\n  <SecondaryCard\n    href=\"/bitcoin/ordinals/api/inscriptions/get-inscriptions\"\n    title=\"Showcase user portfolios\"\n    description=\"Get all inscriptions held by particular addresses.\"\n  />\n  <SecondaryCard\n    href=\"/bitcoin/ordinals/api/satoshis/get-satoshi\"\n    title=\"Retrieve data for a specific satoshi\"\n    description=\"Get all inscription data related to a particular satoshi.\"\n  />\n  <SecondaryCard\n    href=\"/bitcoin/ordinals/api/inscriptions/get-transfers-per-block\"\n    title=\"Graph marketplace activity\"\n    description=\"Pull all transfers from a specific block.\"\n  />\n</Cards>\n\n## Related tools\n\n- **[Bitcoin Indexer](/bitcoin/indexer)**: Want to run your own infra? [Set up your own Bitcoin Indexer](/bitcoin/indexer), the indexer that powers the Ordinals API.\n- **[Ordinals Explorer](https://ordinals.hiro.so/)**: The Ordinals API powers Hiro’s Ordinals Explorer, which lets you rapidly discover inscriptions and verify on-chain activity.\n\n<br />\n\n<Callout title=\"Need help building with the Ordinals API?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#ordinals</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>\n"
  },
  {
    "title": "Status",
    "description": "Retrieves information about the Ordinals API status, including the server version.",
    "slug": "/bitcoin/ordinals/api/info/index",
    "content": ""
  },
  {
    "title": "Get API status",
    "description": "Retrieves the running status of the Ordinals API.",
    "slug": "/bitcoin/ordinals/api/info/status",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Usage",
    "description": "Create your first project in less than 2 minutes",
    "slug": "/bitcoin/ordinals/api/usage",
    "content": "\nThe Usage section should focus on practical, hands-on instructions for getting started with the API. This includes:\nAuthentication: How to authenticate with the API (e.g., API keys, OAuth tokens).\nMaking Requests: Basic examples of making requests to the API, including request format, essential headers, and parameters.\nHandling Responses: Information on response structure, understanding status codes, and error handling.\nRate Limits: If applicable, explain any rate limits and best practices for avoiding them.\nThe goal of the \"Usage\" section is to equip developers with the knowledge to make successful API calls and handle responses effectively.\n"
  },
  {
    "title": "Satoshis",
    "description": "Retrieves ordinal information for satoshis.",
    "slug": "/bitcoin/ordinals/api/satoshis/index",
    "content": ""
  },
  {
    "title": "Get satoshi ordinal",
    "description": "Retrieves ordinal information for a single satoshi.",
    "slug": "/bitcoin/ordinals/api/satoshis/get-satoshi",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/sats/{ordinal}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get satoshi inscriptions",
    "description": "Retrieves all inscriptions associated with a single satoshi.",
    "slug": "/bitcoin/ordinals/api/satoshis/get-satoshi-inscriptions",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/sats/{ordinal}/inscriptions', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Home",
    "description": "",
    "slug": "/bitcoin/index",
    "content": "\nimport { Card, SmallCard } from '@/components/card';\nimport { ImageZoom } from 'fumadocs-ui/components/image-zoom';\nimport { PageFooter } from '@/components/footer';\nimport { Database, Play } from 'lucide-react';\nimport { API, Backend, Chainhook, Newspaper, Ordinals, QuestionIcon, BugIcon, Pulse } from '@/components/ui/icon';\nimport heroImage from '@/public/bitcoin-hero.svg';\n\n<div className='flex flex-col space-y-10'>\n\n<div className='flex space-x-6 items-end'>\n  <ImageZoom\n    alt=\"banner\"\n    src={heroImage}\n    className=\"mt-0 mb-6 first-line:rounded-xl bg-background\"\n    priority\n  />\n\n  <div className='flex flex-col [&_h2]:mt-0 [&_h2]:mb-2 [&_p]:mb-6'>\n\n  ## Build with Bitcoin\n\n  Find all the guides and resources you need to build on Ordinals and Runes.\n\n  </div>\n</div>\n\n<Cards>\n  <Card\n    className='group space-y-1'\n    icon={<Play className='transition-colors duration-500 ease-in-out group-hover:text-primary' />}\n    href=\"/bitcoin/get-started\"\n    title=\"Get Started\"\n    description=\"Get started with our end-to-end tutorials and quickstart guides across all Hiro's ordinals tools.\"\n  />\n  <Card\n    className='group space-y-1'\n    icon={<API className='transition-colors duration-500 ease-in-out group-hover:text-primary' />}\n    href=\"/bitcoin/ordinals/api\"\n    title=\"Ordinals API Reference\"\n    description=\"Explore API endpoints for interacting with Ordinals and meta-protocols.\"\n  />\n</Cards>\n\n<div className='flex flex-col'>\n\n<h4 id=\"explore-bitcoin\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#explore-bitcoin\" className=\"not-prose group text-sm uppercase\">Explore Bitcoin</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<Ordinals />}\n    href=\"/bitcoin/indexer\"\n    title=\"Bitcoin Indexer\"\n    description=\"Use the Bitcoin Indexer to index and query Bitcoin blockchain data.\"\n  />\n  <SmallCard\n    icon={<API />}\n    href=\"/bitcoin/ordinals/api\"\n    title=\"Ordinals API\"\n    description=\"Fetch on-chain data for Ordinals and meta-protocols with our hosted API.\"\n  />\n  <SmallCard\n    icon={<Play />}\n    href=\"https://ordinals.hiro.so/\"\n    title=\"Ordinals Explorer\"\n    description=\"View on-chain data for Ordinals and meta-protocols with our explorer.\"\n  />\n  <SmallCard\n    icon={<API />}\n    href=\"/bitcoin/runes/api\"\n    title=\"Runes API\"\n    description=\"Interact with the Runes protocol from your backend via our hosted API.\"\n  />\n</Cards>\n\n</div>\n\n</div>\n\n<PageFooter />"
  },
  {
    "title": "API keys",
    "description": "For developers who need API requests beyond the standard rate limits.",
    "slug": "/bitcoin/api-keys",
    "content": "\nimport ApiKeysContent from '@/content/_shared/api-keys.mdx';\n\n<ApiKeysContent components={props.components} />\n"
  },
  {
    "title": "Status",
    "description": "Retrieves information about the Rune API status.",
    "slug": "/bitcoin/api/runes/info/index",
    "content": ""
  },
  {
    "title": "Get API Status",
    "description": "Retrieves the status of the API.",
    "slug": "/bitcoin/api/runes/info/status",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get address balances",
    "description": "Retrieves a paginated list of address balances.",
    "slug": "/bitcoin/api/runes/balances/address",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/addresses/{address}/balances', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Balances",
    "description": "Retrieves information about Rune balances.",
    "slug": "/bitcoin/api/runes/balances/index",
    "content": ""
  },
  {
    "title": "Get holder balance",
    "description": "Retrieves holder balance for a specific Rune.",
    "slug": "/bitcoin/api/runes/balances/holder-balance",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings/{etching}/holders/{address}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get rune holders",
    "description": "Retrieves a paginated list of holders for a Rune.",
    "slug": "/bitcoin/api/runes/balances/holders",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings/{etching}/holders', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Activities",
    "description": "Retrieves information about Rune activities.",
    "slug": "/bitcoin/api/runes/activities/index",
    "content": ""
  },
  {
    "title": "Get activity for a transaction",
    "description": "Retrieves a paginated list of rune activity for a transaction.",
    "slug": "/bitcoin/api/runes/activities/for-transaction",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/transactions/{tx_id}/activity', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get activity for an address",
    "description": "Retrieves all Rune activity for a Bitcoin address.",
    "slug": "/bitcoin/api/runes/activities/for-address",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings/{etching}/activity/{address}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get activity for a block",
    "description": "Retrieves a paginated list of rune activity for a block.",
    "slug": "/bitcoin/api/runes/activities/for-block",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/blocks/{block}/activity', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get all activity",
    "description": "Retrieves all activity for a Rune.",
    "slug": "/bitcoin/api/runes/activities/activity",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings/{etching}/activity', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Etchings",
    "description": "Retrieves information about Rune etchings.",
    "slug": "/bitcoin/api/runes/etchings/index",
    "content": ""
  },
  {
    "title": "Get etchings",
    "description": "Retrieves a paginated list of rune etchings.",
    "slug": "/bitcoin/api/runes/etchings/get-etchings",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get etching",
    "description": "Retrieves information for a Rune etching.",
    "slug": "/bitcoin/api/runes/etchings/get-etching",
    "content": "\n<APIPage\n  document=\"./openapi/runes-api.json\"\n  operations={[{ path: '/runes/v1/etchings/{etching}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Statistics",
    "description": "Retrieves stats on the number of inscriptions per block.",
    "slug": "/bitcoin/api/ordinals/statistics/index",
    "content": ""
  },
  {
    "title": "Get inscription count per block",
    "description": "Retrieves statistics on the number of inscriptions revealed per block.",
    "slug": "/bitcoin/api/ordinals/statistics/get-stats-inscription-count",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/stats/inscriptions', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get BRC-20 token holders",
    "description": "Retrieves a list of holders and their balances for a particular BRC-20 token.",
    "slug": "/bitcoin/api/ordinals/brc20/get-brc20-token-holders",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/brc-20/tokens/{ticker}/holders', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "BRC-20",
    "description": "Retrieves information about BRC-20 tokens.",
    "slug": "/bitcoin/api/ordinals/brc20/index",
    "content": ""
  },
  {
    "title": "Get BRC-20 balances",
    "description": "Retrieves BRC-20 token balances for a Bitcoin address.",
    "slug": "/bitcoin/api/ordinals/brc20/get-brc20-balances",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/brc-20/balances/{address}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get BRC-20 token details",
    "description": "Retrieves information for a BRC-20 token, including supply and holders.",
    "slug": "/bitcoin/api/ordinals/brc20/get-brc20-token-details",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/brc-20/tokens/{ticker}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get BRC-20 tokens",
    "description": "Retrieves information for BRC-20 tokens.",
    "slug": "/bitcoin/api/ordinals/brc20/get-brc20-tokens",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/brc-20/tokens', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get BRC-20 activity",
    "description": "Retrieves BRC-20 activity filtered by ticker, address, operation, or block height.",
    "slug": "/bitcoin/api/ordinals/brc20/get-brc20-activity",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/brc-20/activity', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "Inscriptions",
    "description": "Retrieves information about Ordinals inscriptions.",
    "slug": "/bitcoin/api/ordinals/inscriptions/index",
    "content": ""
  },
  {
    "title": "Get inscription transfers",
    "description": "Retrieves all transfers for a single inscription.",
    "slug": "/bitcoin/api/ordinals/inscriptions/get-inscription-transfers",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/inscriptions/{id}/transfers', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get inscriptions",
    "description": "Retrieves a list of inscriptions with options to filter and sort results.",
    "slug": "/bitcoin/api/ordinals/inscriptions/get-inscriptions",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/inscriptions', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get inscription content",
    "description": "Retrieves the content of a single inscription.",
    "slug": "/bitcoin/api/ordinals/inscriptions/get-inscription-content",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/inscriptions/{id}/content', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get transfers per block",
    "description": "Retrieves a list of inscription transfers that ocurred at a specific Bitcoin block.",
    "slug": "/bitcoin/api/ordinals/inscriptions/get-transfers-per-block",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/inscriptions/transfers', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get inscription",
    "description": "Retrieves a single inscription.",
    "slug": "/bitcoin/api/ordinals/inscriptions/get-inscription",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/inscriptions/{id}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Status",
    "description": "Retrieves information about the Ordinals API status, including the server version.",
    "slug": "/bitcoin/api/ordinals/info/index",
    "content": ""
  },
  {
    "title": "Get API status",
    "description": "Retrieves the running status of the Ordinals API.",
    "slug": "/bitcoin/api/ordinals/info/status",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Satoshis",
    "description": "Retrieves ordinal information for satoshis.",
    "slug": "/bitcoin/api/ordinals/satoshis/index",
    "content": ""
  },
  {
    "title": "Get satoshi ordinal",
    "description": "Retrieves ordinal information for a single satoshi.",
    "slug": "/bitcoin/api/ordinals/satoshis/get-satoshi",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/sats/{ordinal}', method: 'get' }]}\n  hasHead={false}\n/>"
  },
  {
    "title": "Get satoshi inscriptions",
    "description": "Retrieves all inscriptions associated with a single satoshi.",
    "slug": "/bitcoin/api/ordinals/satoshis/get-satoshi-inscriptions",
    "content": "\n<APIPage\n  document=\"./openapi/ordinals-api.json\"\n  operations={[{ path: '/ordinals/v1/sats/{ordinal}/inscriptions', method: 'get' }]}\n  hasHead={false}\n/>\n"
  },
  {
    "title": "APIs",
    "description": "The following guides cover ways to use Hiro tools to build apps on Stacks.",
    "slug": "/bitcoin/api/index",
    "content": "\nimport { Database, Ticket } from 'lucide-react';\nimport { Blockchain, BitcoinIcon, Clarinet, Container, DAO, Js, Plant, Shapes, StacksIcon } from '@/components/ui/icon';\nimport { SecondaryCard, SmallCard } from '@/components/card';\n\n<div className='flex flex-col space-y-10'>\n\n<Cards>\n  <SecondaryCard\n    icon={<Database />}\n    href=\"/stacks/chainhook/quickstart\"\n    title=\"Stream custom blockchain events\"\n    description=\"Use Chainhook to filter & stream for contract deployments.\"\n    tag='Chainhook'\n  />\n</Cards>\n\n<div className='flex flex-col'>\n\n<h4 id=\"learn-by-example\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#learn-by-example\" className=\"not-prose group text-sm uppercase\">Learn by example</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<Shapes />}\n    href=\"/guides/build-an-nft-marketplace\"\n    title=\"Build an NFT Marketplace\"\n    description=\"Learn how to create and deploy your own NFT marketplace.\"\n  />\n  {/* <SmallCard\n    icon={<DAO />}\n    href=\"/stacks/clarinet\"\n    title=\"Launch a Decentralized Autonomous Organization (DAO)\"\n    description=\"Discover the steps to creating your own DAO.\"\n  /> */}\n  <SmallCard\n    icon={<Ticket />}\n    href=\"/guides/no-loss-lottery\"\n    title=\"Create a no-loss lottery pool\"\n    description=\"Build a no-loss lottery pool that leverages stacking yield.\"\n  />\n  <SmallCard\n    icon={<Plant />}\n    href=\"/guides/build-a-decentralized-kickstarter\"\n    title=\"Build a decentralized Kickstarter\"\n    description=\"Learn how to create a crowdfunding app, enabling creators to fund their projects without a third party.\"\n  />\n</Cards>\n\n</div>\n\n<div className='flex flex-col'>\n\n<h4 id=\"installation-guides\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#installation-guides\" className=\"not-prose group text-sm uppercase\">Installation guides</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<BitcoinIcon />}\n    href=\"/guides/sync-a-bitcoin-node\"\n    title=\"Sync a Bitcoin node\"\n    description=\"Set up and run a Bitcoin node to run tools like Chainhook as a service.\"\n  />\n  <SmallCard\n    icon={<StacksIcon />}\n    href=\"/guides/sync-a-stacks-node\"\n    title=\"Sync a Stacks node\"\n    description=\"Set up and run a Stacks node to use tools like Chainhook or spin up your own API.\"\n  />\n  <SmallCard\n    icon={<Container />}\n    href=\"/guides/installing-docker\"\n    title=\"Install and run Docker on your machine\"\n    description=\"Essential for running a local development with Clarinet\"\n  />\n</Cards>\n\n</div>\n\n<Callout type=\"tip\">\nFor more, check out our [guides](/guides) section.\n</Callout>\n\n</div>\n"
  },
  {
    "title": "Overview",
    "description": "The Bitcoin Indexer enables you to build ordinals event streams, so you can create accurate, lightweight databases that gracefully handle Bitcoin forks and reorgs.",
    "slug": "/bitcoin/indexer/index",
    "content": "\nimport { SecondaryCard } from '@/components/card';\nimport { Step, Steps } from 'fumadocs-ui/components/steps';\n\nThe Bitcoin Indexer is a reorg-aware indexer that automatically handles chain forks, so you don't need to waste time or resources reindexing your database yourself.\n\nYou can customize what ordinals data you index in order to create lightweight databases for faster query responses and a better user experience.\n\n## Installation\n\n```terminal\n$ git clone https://github.com/hirosystems/bitcoin-indexer.git\n$ cd bitcoin-indexer\n$ cargo bitcoin-indexer-install\n```\n\nAlternatively, you can use Docker images from [Docker Hub](https://hub.docker.com/r/hirosystems/bitcoin-indexer).\n\n## Get started\n\n<Cards>\n  <SecondaryCard\n    href=\"/bitcoin/indexer/quickstart\"\n    title=\"Quickstart\"\n    description=\"Learn how to scan for Bitcoin activity using the Bitcoin Indexer.\"\n  />\n</Cards>\n\n## System Requirements\n\nBefore running the indexer, ensure your system meets these requirements:\n\n- **CPU**: Multi-core support for parallel processing\n- **Memory**: Minimum 16GB RAM\n- **Storage**: SSD or NVMe recommended\n- **OS**: Support for 4096+ open file descriptors\n- **Postgres**: Version 17+ recommended\n\n## Related tools\n\n- **[Ordinals API](/bitcoin/ordinals/api)**: Skip the infrastructure setup and get the ordinals data you need from our Ordinals API, which is powered by the Bitcoin Indexer.\n- **[Ordinals Explorer](https://ordinals.hiro.so/)**: Explore ordinals inscriptions and BRC-20 tokens rapidly in our Ordinals Explorer.\n\n<br />\n\n<Callout title=\"Need help building with the Bitcoin Indexer?\" type=\"help\">\nReach out to us on the <span className=\"font-bold\">#indexer</span> channel on [Discord](https://stacks.chat/) under the Hiro Developer Tools section. There's also a [weekly office hours](https://www.addevent.com/event/kI22007085) call every Wednesday at 1pm ET.\n</Callout>\n"
  },
  {
    "title": "TBD",
    "description": "TBD",
    "slug": "/bitcoin/indexer/guides/run-indexer",
    "content": "\n"
  },
  {
    "title": "Quickstart",
    "description": "Learn how to scan the Bitcoin blockchain for Ordinals activity.",
    "slug": "/bitcoin/indexer/quickstart",
    "content": "\nimport { Steps, Step } from 'fumadocs-ui/components/steps';\n\nIn this quickstart guide, you will set up the Bitcoin Indexer to index Ordinals or Runes activity on the Bitcoin blockchain.\n\n<Steps>\n  <Step title=\"Install Bitcoin Indexer\">\n    Clone the repository and install the indexer:\n    ```terminal\n    $ git clone https://github.com/hirosystems/bitcoin-indexer.git\n    $ cd bitcoin-indexer\n    $ cargo bitcoin-indexer-install\n    ```\n  </Step>\n\n  <Step title=\"Configure the Indexer\">\n    Generate a new configuration file:\n    ```terminal\n    $ bitcoin-indexer config new\n    ```\n    \n    Configure your Postgres database in the generated TOML file:\n    ```toml\n    [ordinals.db]\n    database = \"metaprotocols\"\n    host = \"localhost\"\n    port = 5432\n    username = \"postgres\"\n    password = \"postgres\"\n    ```\n  </Step>\n\n  <Step title=\"Start the Indexer\">\n    Run the following command to start indexing Ordinals activity:\n    ```terminal\n    $ bitcoin-indexer ordinals service start --config-path <path>\n    ```\n    \n    For Runes indexing, use:\n    ```terminal\n    $ bitcoin-indexer runes service start --config-path <path>\n    ```\n  </Step>\n</Steps>\n\n<Callout type=\"info\">\n  A fully synced Bitcoin node is required for indexing to start.\n</Callout>\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/ordinals/explorer\"\n    title=\"Ordinals Explorer\"\n    description=\"Explore the Ordinals Explorer to view inscriptions and transfers.\"\n  />\n  <Card\n    href=\"/bitcoin/ordinals/api\"\n    title=\"Ordinals API\"\n    description=\"Learn how to interact with Ordinals data using our API.\"\n  />\n  <Card\n    href=\"/bitcoin/runes/api\" \n    title=\"Runes API\"\n    description=\"Explore our Runes blockchain API documentation.\"\n  />\n</Cards>"
  },
  {
    "title": "Quickstarts",
    "description": "The following guides cover ways to use Hiro tools to build apps on Stacks.",
    "slug": "/bitcoin/quickstarts/index",
    "content": "\nimport { Database, Ticket } from 'lucide-react';\nimport { Blockchain, BitcoinIcon, Clarinet, Container, DAO, Js, Plant, Shapes, StacksIcon } from '@/components/ui/icon';\nimport { SecondaryCard, SmallCard } from '@/components/card';\n\n<div className='flex flex-col space-y-10'>\n\n<Cards>\n  <SecondaryCard\n    icon={<Clarinet />}\n    href=\"/stacks/clarinet/quickstart\"\n    title=\"Create your first smart contract\"\n    description=\"Build a simple counter contract using Clarinet.\"\n    tag='Clarinet'\n  />\n  <SecondaryCard\n    icon={<Blockchain />}\n    href=\"/stacks/clarinet-js-sdk/quickstart\"\n    title=\"Write unit tests for your smart contracts\"\n    description=\"Learn how run unit tests with Clarinet JS SDK.\"\n    tag='Clarinet JS SDK'\n  />\n  <SecondaryCard\n    icon={<Js />}\n    href=\"/stacks/stacks.js/quickstart\"\n    title=\"Make a contract call with Stacks.js\"\n    description=\"Learn how to integrate smart contracts into your app.\"\n    tag='Stacks.js'\n  />\n  <SecondaryCard\n    icon={<Database />}\n    href=\"/stacks/chainhook/quickstart\"\n    title=\"Stream custom blockchain events\"\n    description=\"Use Chainhook to filter & stream for contract deployments.\"\n    tag='Chainhook'\n  />\n</Cards>\n\n<div className='flex flex-col'>\n\n<h4 id=\"learn-by-example\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#learn-by-example\" className=\"not-prose group text-sm uppercase\">Learn by example</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<Shapes />}\n    href=\"/guides/build-an-nft-marketplace\"\n    title=\"Build an NFT Marketplace\"\n    description=\"Learn how to create and deploy your own NFT marketplace.\"\n  />\n  {/* <SmallCard\n    icon={<DAO />}\n    href=\"/stacks/clarinet\"\n    title=\"Launch a Decentralized Autonomous Organization (DAO)\"\n    description=\"Discover the steps to creating your own DAO.\"\n  /> */}\n  <SmallCard\n    icon={<Ticket />}\n    href=\"/guides/no-loss-lottery\"\n    title=\"Create a no-loss lottery pool\"\n    description=\"Build a no-loss lottery pool that leverages stacking yield.\"\n  />\n  <SmallCard\n    icon={<Plant />}\n    href=\"/guides/build-a-decentralized-kickstarter\"\n    title=\"Build a decentralized Kickstarter\"\n    description=\"Learn how to create a crowdfunding app, enabling creators to fund their projects without a third party.\"\n  />\n</Cards>\n\n</div>\n\n<div className='flex flex-col'>\n\n<h4 id=\"installation-guides\" className=\"text-[#595650] dark:text-[#8c877d] scroll-m-20\">\n  <a href=\"#installation-guides\" className=\"not-prose group text-sm uppercase\">Installation guides</a>\n</h4>\n\n---\n\n<Cards>\n  <SmallCard\n    icon={<BitcoinIcon />}\n    href=\"/guides/sync-a-bitcoin-node\"\n    title=\"Sync a Bitcoin node\"\n    description=\"Set up and run a Bitcoin node to run tools like Chainhook as a service.\"\n  />\n  <SmallCard\n    icon={<StacksIcon />}\n    href=\"/guides/sync-a-stacks-node\"\n    title=\"Sync a Stacks node\"\n    description=\"Set up and run a Stacks node to use tools like Chainhook or spin up your own API.\"\n  />\n  <SmallCard\n    icon={<Container />}\n    href=\"/guides/installing-docker\"\n    title=\"Install and run Docker on your machine\"\n    description=\"Essential for running a local development with Clarinet\"\n  />\n</Cards>\n\n</div>\n\n<Callout type=\"tip\">\nFor more, check out our [guides](/guides) section.\n</Callout>\n\n</div>\n"
  },
  {
    "title": "Contributors guide",
    "description": "Learn how to contribute to Hiro's documentation and content.",
    "slug": "/guides/contributors-guide",
    "content": "\nimport ContributorsGuideContent from '@/content/_shared/contributors-guide.mdx';\n\n<ContributorsGuideContent components={props.components} />\n"
  },
  {
    "title": "Rate limiting",
    "description": "Understand the rate limits for Hiro APIs and the STX Faucet.",
    "slug": "/guides/rate-limiting",
    "content": "\nimport RateLimitingContent from '@/content/_shared/rate-limiting.mdx';\n\n<RateLimitingContent components={props.components} />\n"
  },
  {
    "title": "Home",
    "description": "",
    "slug": "/guides/index",
    "content": "\nimport Link from \"fumadocs-core/link\";\nimport { ImageZoom } from 'fumadocs-ui/components/image-zoom';\nimport { SecondaryCard } from \"@/components/card\"\nimport guidesImage from '@/public/guides.svg';\nimport data from '@/lib/all-guides.json';\n\n<div className='flex flex-col space-y-10'>\n  <div className='flex space-x-6 items-end'>\n    <ImageZoom\n      alt=\"banner\"\n      src={guidesImage}\n      className=\"mt-0 mb-6 first-line:rounded-xl bg-background\"\n      priority\n    />\n  </div>\n\n  <Cards>\n    {data.guides.map(guide => {\n      return (\n        <SecondaryCard\n          key={guide.title}\n          href={guide.href}\n          title={guide.title}\n          description={guide.description}\n        />\n      )\n    })}\n  </Cards>\n</div>"
  },
  {
    "title": "How to sync a Stacks node",
    "description": "Learn how to sync a Stacks node for running a local devnet or mainnet.",
    "slug": "/guides/sync-a-stacks-node",
    "content": "\nimport { Code, Terminal } from 'lucide-react';\nimport { SmallCard } from '@/components/card';\nimport { InlineCode } from '@/components/inline-code';\n\nRunning a Stacks node is crucial for developers aiming to interact directly with the Stacks blockchain. It allows for the verification of transactions, ensures decentralized operations, and enhances blockchain security.\n\nIn this guide, you will learn how to:\n\n1. [Clone the Stacks blockchain Docker repository](#clone-the-stacks-blockchain-docker-repository).\n2. [Start the service](#start-the-service).\n3. [Monitor the node's synchronization process](#monitor-the-nodes-synchronization-process).\n\n---\n\n## Clone the Stacks blockchain Docker repository\n\nClone the Stacks blockchain Docker repository from GitHub:\n\n```terminal\n$ git clone https://github.com/blockstack/stacks-blockchain-docker.git\n$ cd stacks-blockchain-docker\n```\n\n## Start the service\n\nInside of the `stacks-blockchain-docker` directory, run the following command to start the Stacks node:\n\n```terminal\n$ ./manage.sh -n <network> -a start\n```\n\nThe `<network>` placeholder used below can be replaced with one of:\n\n- `mainnet`\n- `testnet`\n- `mocknet`\n\n## Monitor the node's synchronization process\n\nTo follow the logs for the Stacks node, run the following command:\n\n```terminal\n$ ./manage.sh -n <network> -a logs\n```\n\nFor networks other than `mocknet`, downloading the initial headers can take several minutes. Until the headers are downloaded, the `/v2/info` endpoints won't return any data.\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/chainhook/guides/chainhook-as-a-service\"\n    title=\"Run Chainhook as a service\"\n    description=\"Learn how to use Chainhook to build your own custom API.\"\n  />\n  <Card\n    href=\"/guides/sync-a-bitcoin-node\"\n    title=\"Sync a Bitcoin node\"\n    description=\"Learn how to sync a Bitcoin node for running Chainhook as a service.\"\n  />\n</Cards>\n"
  },
  {
    "title": "How to install Docker",
    "description": "Install Docker to run a local devnet.",
    "slug": "/guides/installing-docker",
    "content": "\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\n<Tabs id=\"docker\" items={['macOS', 'Windows']}>\n  <Tab value=\"macOS\">\n    1. Go to the [Docker Desktop for Mac](https://www.docker.com/products/docker-desktop/) page.\n    2. Download the .dmg file.\n    3. Open the downloaded .dmg file.\n    4. Drag the Docker icon to the Applications folder.\n    5. Open Docker from the Applications folder.\n    6. Grant the necessary permissions if prompted.\n    7. Docker Desktop icon will appear in the menu bar indicating that Docker is running.\n  \n    To verify installation, run `docker --version` in your terminal. You should see the Docker version information.\n  </Tab>\n  \n  <Tab value=\"Windows\">\n    1. Go to the [Docker Desktop for Windows](https://www.docker.com/products/docker-desktop/) page.\n    2. Download the executable.\n    3. Run the downloaded executable.\n    4. Follow the installation wizard steps (you may need to restart your computer).\n    5. Ensure the WSL 2 (Windows Subsystem for Linux) backend is checked during installation, if applicable.\n    6. Open Docker Desktop from the Start menu.\n    7. Grant the necessary permissions if prompted.\n    8. Docker icon will appear in the system tray indicating Docker is running.\n\n    To verify installation, run `docker --version` in your terminal. You should see the Docker version information.\n  \n    <Callout title=\"Windows installation\">\n      You might need to install additional Windows components like Hyper-V or WSL 2.\n    </Callout>\n  </Tab>\n</Tabs>\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/guides/sync-a-bitcoin-node\"\n    title=\"Sync a Bitcoin node\"\n    description=\"Learn how to sync a Bitcoin node for running Chainhook as a service.\"\n  />\n  <Card\n    href=\"/guides/sync-a-stacks-node\"\n    title=\"Sync a Stacks node\"\n    description=\"Learn how to sync a Stacks node for running a local devnet.\"\n  />\n</Cards>"
  },
  {
    "title": "Build a decentralized Kickstarter",
    "description": "Learn how to create a crowdfunding app, enabling creators to fund their projects without a third party.",
    "slug": "/guides/build-a-decentralized-kickstarter",
    "content": "\nimport { Code, Terminal } from 'lucide-react';\nimport { SmallCard } from '@/components/card';\n\nIn this guide, you will learn how to create an NFT marketplace that allows users to list NFTs for sale. Users can specify the following details for their listings:\n- The NFT token to sell.\n- Listing expiry in block height.\n- The payment asset, either STX or a SIP010 fungible token.\n- The NFT price in the chosen payment asset.\n- An optional intended taker. If set, only that principal will be able to fulfil the listing.\n\nThis marketplace leverages the following Clarity traits:\n- `nft-trait` for handling NFTs.\n- `ft-trait` for handling fungible tokens.\n\nOver the course of this guide, you will learn how to:\n1. Define and handle errors.\n2. Create and manage NFT listings.\n3. Whitelist asset contracts.\n4. Fulfil NFT purchases.\n\n---\n\n## Define and handle errors\n\nFirst, define constants for various errors that may occur during listing, cancelling, or fulfilling NFT transactions. This helps in maintaining clean and readable code.\n\n```clarity\n;; Define listing errors\n(define-constant ERR_EXPIRY_IN_PAST (err u1000))\n(define-constant ERR_PRICE_ZERO (err u1001))\n\n;; Define cancelling and fulfilling errors\n(define-constant ERR_UNKNOWN_LISTING (err u2000))\n(define-constant ERR_UNAUTHORISED (err u2001))\n(define-constant ERR_LISTING_EXPIRED (err u2002))\n(define-constant ERR_NFT_ASSET_MISMATCH (err u2003))\n(define-constant ERR_PAYMENT_ASSET_MISMATCH (err u2004))\n(define-constant ERR_MAKER_TAKER_EQUAL (err u2005))\n(define-constant ERR_UNINTENDED_TAKER (err u2006))\n(define-constant ERR_ASSET_CONTRACT_NOT_WHITELISTED (err u2007))\n(define-constant ERR_PAYMENT_CONTRACT_NOT_WHITELISTED (err u2008))\n```\n\n## Create and manage NFT listings\n\n### Define data structures\n\nCreate a map data structure for the asset listings and a data variable for unique IDs.\n\n```clarity\n;; Define a map data structure for the asset listings\n(define-map listings\n  uint\n  {\n    maker: principal,\n    taker: (optional principal),\n    token-id: uint,\n    nft-asset-contract: principal,\n    expiry: uint,\n    price: uint,\n    payment-asset-contract: (optional principal)\n  }\n)\n\n;; Used for unique IDs for each listing\n(define-data-var listing-nonce uint u0)\n```\n\n### List an asset\n\nCreate a public function to list an asset along with its contract. This function verifies the contract, checks expiry and price, and transfers the NFT ownership to the marketplace.\n\n```clarity\n(define-public (list-asset\n  (nft-asset-contract <nft-trait>)\n  (nft-asset {\n    taker: (optional principal),\n    token-id: uint,\n    expiry: uint,\n    price: uint,\n    payment-asset-contract: (optional principal)\n  })\n)\n  (let ((listing-id (var-get listing-nonce)))\n    ;; Verify that the contract of this asset is whitelisted\n    (asserts! (is-whitelisted (contract-of nft-asset-contract)) ERR_ASSET_CONTRACT_NOT_WHITELISTED)\n    ;; Verify that the asset is not expired\n    (asserts! (> (get expiry nft-asset) block-height) ERR_EXPIRY_IN_PAST)\n    ;; Verify that the asset price is greater than zero\n    (asserts! (> (get price nft-asset) u0) ERR_PRICE_ZERO)\n    ;; Verify that the contract of the payment is whitelisted\n    (asserts! (match (get payment-asset-contract nft-asset)\n      payment-asset\n      (is-whitelisted payment-asset)\n      true\n    ) ERR_PAYMENT_CONTRACT_NOT_WHITELISTED)\n    ;; Transfer the NFT ownership to this contract's principal\n    (try! (transfer-nft\n      nft-asset-contract\n      (get token-id nft-asset)\n      tx-sender\n      (as-contract tx-sender)\n    ))\n    ;; List the NFT in the listings map\n    (map-set listings listing-id (merge\n      { maker: tx-sender, nft-asset-contract: (contract-of nft-asset-contract) }\n      nft-asset\n    ))\n    ;; Increment the nonce to use for the next unique listing ID\n    (var-set listing-nonce (+ listing-id u1))\n    ;; Return the created listing ID\n    (ok listing-id)\n  )\n)\n```\n\n### Retrieve an asset\n\nCreate a read-only function to retrieve an asset, or listing, by its ID.\n\n```clarity\n(define-read-only (get-listing (listing-id uint))\n  (map-get? listings listing-id)\n)\n```\n\n### Cancel a listing\n\nCreate a public function to cancel a listing. Only the NFT's creator can cancel the listing, and it must use the same asset contract that the NFT uses.\n\n```clarity\n(define-public (cancel-listing (listing-id uint) (nft-asset-contract <nft-trait>))\n  (let (\n    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))\n    (maker (get maker listing))\n  )\n    ;; Verify that the caller of the function is the creator of the NFT to be cancelled\n    (asserts! (is-eq maker tx-sender) ERR_UNAUTHORISED)\n    ;; Verify that the asset contract to use is the same one that the NFT uses\n    (asserts! (is-eq\n      (get nft-asset-contract listing)\n      (contract-of nft-asset-contract)\n    ) ERR_NFT_ASSET_MISMATCH)\n    ;; Delete the listing\n    (map-delete listings listing-id)\n    ;; Transfer the NFT from this contract's principal back to the creator's principal\n    (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender maker))\n  )\n)\n```\n\n## Whitelist asset contracts\n\n### Whitelist contracts\n\nThe marketplace requires any contracts used for assets or payments to be whitelisted by the contract owner. Create a map to store whitelisted asset contracts and a function to check if a contract is whitelisted.\n\n```clarity\n(define-map whitelisted-asset-contracts principal bool)\n\n(define-read-only (is-whitelisted (asset-contract principal))\n  (default-to false (map-get? whitelisted-asset-contracts asset-contract))\n)\n```\n\n### Set whitelisted contracts\n\nOnly the contract owner can whitelist an asset contract. Create a public function to set whitelisted asset contracts.\n\n```clarity\n(define-public (set-whitelisted (asset-contract principal) (whitelisted bool))\n  (begin\n    (asserts! (is-eq contract-owner tx-sender) ERR_UNAUTHORISED)\n    (ok (map-set whitelisted-asset-contracts asset-contract whitelisted))\n  )\n)\n```\n\n## Fulfill NFT purchases\n\n### Fulfill listing with STX\n\nCreate a public function to purchase a listing using STX as payment.\n\n```clarity\n(define-public (fulfil-listing-stx (listing-id uint) (nft-asset-contract <nft-trait>))\n  (let (\n    ;; Verify the given listing ID exists\n    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))\n    ;; Set the NFT's taker to the purchaser (caller of the function)\n    (taker tx-sender)\n  )\n    ;; Validate that the purchase can be fulfilled\n    (try! (assert-can-fulfil (contract-of nft-asset-contract) none listing))\n    ;; Transfer the NFT to the purchaser (caller of the function)\n    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))\n    ;; Transfer the STX payment from the purchaser to the creator of the NFT\n    (try! (stx-transfer? (get price listing) taker (get maker listing)))\n    ;; Remove the NFT from the marketplace listings\n    (map-delete listings listing-id)\n    ;; Return the listing ID that was just purchased\n    (ok listing-id)\n  )\n)\n```\n\n### Fulfill listing with SIP-010\n\nCreate a public function to purchase a listing using another fungible token that follows the SIP-010 standard as payment.\n\n```clarity\n(define-public (fulfil-listing-ft\n  (listing-id uint)\n  (nft-asset-contract <nft-trait>)\n  (payment-asset-contract <ft-trait>)\n)\n  (let (\n    ;; Verify the given listing ID exists\n    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))\n    ;; Set the NFT's taker to the purchaser (caller of the function)\n    (taker tx-sender)\n  )\n    ;; Validate that the purchase can be fulfilled\n    (try! (assert-can-fulfil\n      (contract-of nft-asset-contract)\n      (some (contract-of payment-asset-contract))\n      listing\n    ))\n    ;; Transfer the NFT to the purchaser (caller of the function)\n    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))\n    ;; Transfer the tokens as payment from the purchaser to the creator of the NFT\n    (try! (transfer-ft payment-asset-contract (get price listing) taker (get maker listing)))\n    ;; Remove the NFT from the marketplace listings\n    (map-delete listings listing-id)\n    ;; Return the listing ID that was just purchased\n    (ok listing-id)\n  )\n)\n```\n\n### Validate purchase can be fulfilled\n\nCreate a private function to validate that a purchase can be fulfilled. This function checks the listing's expiry, the NFT's contract, and the payment's contract.\n\n```clarity\n(define-private (assert-can-fulfil\n  (nft-asset-contract principal)\n  (payment-asset-contract (optional principal))\n  (listing {\n    maker: principal,\n    taker: (optional principal),\n    token-id: uint,\n    nft-asset-contract: principal,\n    expiry: uint,\n    price: uint,\n    payment-asset-contract: (optional principal)\n  })\n)\n  (begin\n    ;; Verify that the buyer is not the same as the NFT creator\n    (asserts! (not (is-eq (get maker listing) tx-sender)) ERR_MAKER_TAKER_EQUAL)\n    ;; Verify the buyer has been set in the listing metadata as its `taker`\n    (asserts!\n      (match (get taker listing) intended-taker (is-eq intended-taker tx-sender) true)\n      ERR_UNINTENDED_TAKER\n    )\n    ;; Verify the listing for purchase is not expired\n    (asserts! (< block-height (get expiry listing)) ERR_LISTING_EXPIRED)\n    ;; Verify the asset contract used to purchase the NFT is the same as the one set on the NFT\n    (asserts! (is-eq (get nft-asset-contract listing) nft-asset-contract) ERR_NFT_ASSET_MISMATCH)\n    ;; Verify the payment contract used to purchase the NFT is the same as the one set on the NFT\n    (asserts!\n      (is-eq (get payment-asset-contract listing) payment-asset-contract)\n      ERR_PAYMENT_ASSET_MISMATCH\n    )\n    (ok true)\n  )\n)\n```\n\nBy following this guide, you have created a basic NFT marketplace that allows users to list, buy, and sell NFTs using either STX or fungible tokens. This implementation includes essential functionalities such as whitelisting contracts, validating transactions, and handling errors.\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/connect/guides/authenticate-users\"\n    title=\"Authenticate users\"\n    description=\"Learn how to authenticate users using the Connect package in Stacks.js.\"\n  />\n  <Card\n    href=\"/stacks/connect/guides/broadcast-transactions\"\n    title=\"Broadcast transactions\"\n    description=\"Learn how to sign and broadcast transactions.\"\n  />\n</Cards>"
  },
  {
    "title": "API keys",
    "description": "For developers who need API requests beyond the standard rate limits.",
    "slug": "/guides/api-keys",
    "content": "\nimport ApiKeysContent from '@/content/_shared/api-keys.mdx';\n\n<ApiKeysContent components={props.components} />\n"
  },
  {
    "title": "Build an NFT marketplace",
    "description": "Learn how to create an NFT marketplace that allows users to list NFTs for sale and purchase them using Clarity.",
    "slug": "/guides/build-an-nft-marketplace",
    "content": "\nimport { Code, Terminal } from 'lucide-react';\nimport { SmallCard } from '@/components/card';\n\nIn this guide, you will learn how to create an NFT marketplace that allows users to list NFTs for sale. Users can specify the following details for their listings:\n- The NFT token to sell.\n- Listing expiry in block height.\n- The payment asset, either STX or a SIP010 fungible token.\n- The NFT price in the chosen payment asset.\n- An optional intended taker. If set, only that principal will be able to fulfil the listing.\n\nThis marketplace leverages the following Clarity traits:\n- `nft-trait` for handling NFTs.\n- `ft-trait` for handling fungible tokens.\n\nOver the course of this guide, you will learn how to:\n1. Define and handle errors.\n2. Create and manage NFT listings.\n3. Whitelist asset contracts.\n4. Fulfil NFT purchases.\n\n---\n\n## Define and handle errors\n\nFirst, define constants for various errors that may occur during listing, cancelling, or fulfilling NFT transactions. This helps in maintaining clean and readable code.\n\n```clarity\n;; Define listing errors\n(define-constant ERR_EXPIRY_IN_PAST (err u1000))\n(define-constant ERR_PRICE_ZERO (err u1001))\n\n;; Define cancelling and fulfilling errors\n(define-constant ERR_UNKNOWN_LISTING (err u2000))\n(define-constant ERR_UNAUTHORISED (err u2001))\n(define-constant ERR_LISTING_EXPIRED (err u2002))\n(define-constant ERR_NFT_ASSET_MISMATCH (err u2003))\n(define-constant ERR_PAYMENT_ASSET_MISMATCH (err u2004))\n(define-constant ERR_MAKER_TAKER_EQUAL (err u2005))\n(define-constant ERR_UNINTENDED_TAKER (err u2006))\n(define-constant ERR_ASSET_CONTRACT_NOT_WHITELISTED (err u2007))\n(define-constant ERR_PAYMENT_CONTRACT_NOT_WHITELISTED (err u2008))\n```\n\n## Create and manage NFT listings\n\n### Define data structures\n\nCreate a map data structure for the asset listings and a data variable for unique IDs.\n\n```clarity\n;; Define a map data structure for the asset listings\n(define-map listings\n  uint\n  {\n    maker: principal,\n    taker: (optional principal),\n    token-id: uint,\n    nft-asset-contract: principal,\n    expiry: uint,\n    price: uint,\n    payment-asset-contract: (optional principal)\n  }\n)\n\n;; Used for unique IDs for each listing\n(define-data-var listing-nonce uint u0)\n```\n\n### List an asset\n\nCreate a public function to list an asset along with its contract. This function verifies the contract, checks expiry and price, and transfers the NFT ownership to the marketplace.\n\n```clarity\n(define-public (list-asset\n  (nft-asset-contract <nft-trait>)\n  (nft-asset {\n    taker: (optional principal),\n    token-id: uint,\n    expiry: uint,\n    price: uint,\n    payment-asset-contract: (optional principal)\n  })\n)\n  (let ((listing-id (var-get listing-nonce)))\n    ;; Verify that the contract of this asset is whitelisted\n    (asserts! (is-whitelisted (contract-of nft-asset-contract)) ERR_ASSET_CONTRACT_NOT_WHITELISTED)\n    ;; Verify that the asset is not expired\n    (asserts! (> (get expiry nft-asset) block-height) ERR_EXPIRY_IN_PAST)\n    ;; Verify that the asset price is greater than zero\n    (asserts! (> (get price nft-asset) u0) ERR_PRICE_ZERO)\n    ;; Verify that the contract of the payment is whitelisted\n    (asserts! (match (get payment-asset-contract nft-asset)\n      payment-asset\n      (is-whitelisted payment-asset)\n      true\n    ) ERR_PAYMENT_CONTRACT_NOT_WHITELISTED)\n    ;; Transfer the NFT ownership to this contract's principal\n    (try! (transfer-nft\n      nft-asset-contract\n      (get token-id nft-asset)\n      tx-sender\n      (as-contract tx-sender)\n    ))\n    ;; List the NFT in the listings map\n    (map-set listings listing-id (merge\n      { maker: tx-sender, nft-asset-contract: (contract-of nft-asset-contract) }\n      nft-asset\n    ))\n    ;; Increment the nonce to use for the next unique listing ID\n    (var-set listing-nonce (+ listing-id u1))\n    ;; Return the created listing ID\n    (ok listing-id)\n  )\n)\n```\n\n### Retrieve an asset\n\nCreate a read-only function to retrieve an asset, or listing, by its ID.\n\n```clarity\n(define-read-only (get-listing (listing-id uint))\n  (map-get? listings listing-id)\n)\n```\n\n### Cancel a listing\n\nCreate a public function to cancel a listing. Only the NFT's creator can cancel the listing, and it must use the same asset contract that the NFT uses.\n\n```clarity\n(define-public (cancel-listing (listing-id uint) (nft-asset-contract <nft-trait>))\n  (let (\n    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))\n    (maker (get maker listing))\n  )\n    ;; Verify that the caller of the function is the creator of the NFT to be cancelled\n    (asserts! (is-eq maker tx-sender) ERR_UNAUTHORISED)\n    ;; Verify that the asset contract to use is the same one that the NFT uses\n    (asserts! (is-eq\n      (get nft-asset-contract listing)\n      (contract-of nft-asset-contract)\n    ) ERR_NFT_ASSET_MISMATCH)\n    ;; Delete the listing\n    (map-delete listings listing-id)\n    ;; Transfer the NFT from this contract's principal back to the creator's principal\n    (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender maker))\n  )\n)\n```\n\n## Whitelist asset contracts\n\n### Whitelist contracts\n\nThe marketplace requires any contracts used for assets or payments to be whitelisted by the contract owner. Create a map to store whitelisted asset contracts and a function to check if a contract is whitelisted.\n\n```clarity\n(define-map whitelisted-asset-contracts principal bool)\n\n(define-read-only (is-whitelisted (asset-contract principal))\n  (default-to false (map-get? whitelisted-asset-contracts asset-contract))\n)\n```\n\n### Set whitelisted contracts\n\nOnly the contract owner can whitelist an asset contract. Create a public function to set whitelisted asset contracts.\n\n```clarity\n(define-public (set-whitelisted (asset-contract principal) (whitelisted bool))\n  (begin\n    (asserts! (is-eq contract-owner tx-sender) ERR_UNAUTHORISED)\n    (ok (map-set whitelisted-asset-contracts asset-contract whitelisted))\n  )\n)\n```\n\n## Fulfill NFT purchases\n\n### Fulfill listing with STX\n\nCreate a public function to purchase a listing using STX as payment.\n\n```clarity\n(define-public (fulfil-listing-stx (listing-id uint) (nft-asset-contract <nft-trait>))\n  (let (\n    ;; Verify the given listing ID exists\n    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))\n    ;; Set the NFT's taker to the purchaser (caller of the function)\n    (taker tx-sender)\n  )\n    ;; Validate that the purchase can be fulfilled\n    (try! (assert-can-fulfil (contract-of nft-asset-contract) none listing))\n    ;; Transfer the NFT to the purchaser (caller of the function)\n    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))\n    ;; Transfer the STX payment from the purchaser to the creator of the NFT\n    (try! (stx-transfer? (get price listing) taker (get maker listing)))\n    ;; Remove the NFT from the marketplace listings\n    (map-delete listings listing-id)\n    ;; Return the listing ID that was just purchased\n    (ok listing-id)\n  )\n)\n```\n\n### Fulfill listing with SIP-010\n\nCreate a public function to purchase a listing using another fungible token that follows the SIP-010 standard as payment.\n\n```clarity\n(define-public (fulfil-listing-ft\n  (listing-id uint)\n  (nft-asset-contract <nft-trait>)\n  (payment-asset-contract <ft-trait>)\n)\n  (let (\n    ;; Verify the given listing ID exists\n    (listing (unwrap! (map-get? listings listing-id) ERR_UNKNOWN_LISTING))\n    ;; Set the NFT's taker to the purchaser (caller of the function)\n    (taker tx-sender)\n  )\n    ;; Validate that the purchase can be fulfilled\n    (try! (assert-can-fulfil\n      (contract-of nft-asset-contract)\n      (some (contract-of payment-asset-contract))\n      listing\n    ))\n    ;; Transfer the NFT to the purchaser (caller of the function)\n    (try! (as-contract (transfer-nft nft-asset-contract (get token-id listing) tx-sender taker)))\n    ;; Transfer the tokens as payment from the purchaser to the creator of the NFT\n    (try! (transfer-ft payment-asset-contract (get price listing) taker (get maker listing)))\n    ;; Remove the NFT from the marketplace listings\n    (map-delete listings listing-id)\n    ;; Return the listing ID that was just purchased\n    (ok listing-id)\n  )\n)\n```\n\n### Validate purchase can be fulfilled\n\nCreate a private function to validate that a purchase can be fulfilled. This function checks the listing's expiry, the NFT's contract, and the payment's contract.\n\n```clarity\n(define-private (assert-can-fulfil\n  (nft-asset-contract principal)\n  (payment-asset-contract (optional principal))\n  (listing {\n    maker: principal,\n    taker: (optional principal),\n    token-id: uint,\n    nft-asset-contract: principal,\n    expiry: uint,\n    price: uint,\n    payment-asset-contract: (optional principal)\n  })\n)\n  (begin\n    ;; Verify that the buyer is not the same as the NFT creator\n    (asserts! (not (is-eq (get maker listing) tx-sender)) ERR_MAKER_TAKER_EQUAL)\n    ;; Verify the buyer has been set in the listing metadata as its `taker`\n    (asserts!\n      (match (get taker listing) intended-taker (is-eq intended-taker tx-sender) true)\n      ERR_UNINTENDED_TAKER\n    )\n    ;; Verify the listing for purchase is not expired\n    (asserts! (< block-height (get expiry listing)) ERR_LISTING_EXPIRED)\n    ;; Verify the asset contract used to purchase the NFT is the same as the one set on the NFT\n    (asserts! (is-eq (get nft-asset-contract listing) nft-asset-contract) ERR_NFT_ASSET_MISMATCH)\n    ;; Verify the payment contract used to purchase the NFT is the same as the one set on the NFT\n    (asserts!\n      (is-eq (get payment-asset-contract listing) payment-asset-contract)\n      ERR_PAYMENT_ASSET_MISMATCH\n    )\n    (ok true)\n  )\n)\n```\n\nBy following this guide, you have created a basic NFT marketplace that allows users to list, buy, and sell NFTs using either STX or fungible tokens. This implementation includes essential functionalities such as whitelisting contracts, validating transactions, and handling errors.\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/connect/guides/authenticate-users\"\n    title=\"Authenticate users\"\n    description=\"Learn how to authenticate users using the Connect package in Stacks.js.\"\n  />\n  <Card\n    href=\"/stacks/connect/guides/broadcast-transactions\"\n    title=\"Broadcast transactions\"\n    description=\"Learn how to sign and broadcast transactions.\"\n  />\n</Cards>"
  },
  {
    "title": "Using Clarity values",
    "description": "Learn how to use Clarity values in your Clarity smart contracts.",
    "slug": "/guides/using-clarity-values",
    "content": "\nSome endpoints, like the [read-only function contract call](https://docs.hiro.so/api#operation/call_read_only_function), require input to a serialized [Clarity value](https://docs.stacks.co/docs/clarity/). Other endpoints return serialized values that need to be deserialized.\n\nThe example shown below illustrates Clarity value usage in combination with the API.\n\nThe `@stacks/transactions` library supports typed contract calls and makes [response value utilization much simpler](https://docs.stacks.co/docs/clarity/).\n\n```ts\nimport {\n  Configuration,\n  SmartContractsApiInterface,\n  SmartContractsApi,\n  ReadOnlyFunctionSuccessResponse,\n} from '@stacks/blockchain-api-client';\nimport { uintCV, UIntCV, cvToHex, hexToCV, ClarityType } from '@stacks/transactions';\n\n(async () => {\n  const apiConfig: Configuration = new Configuration({\n    fetchApi: fetch,\n    // for mainnet, replace `testnet` with `mainnet`\n    basePath: 'https://api.testnet.hiro.so', // defaults to http://localhost:3999\n  });\n\n  const contractsApi: SmartContractsApiInterface = new SmartContractsApi(apiConfig);\n\n  const principal: string = 'ST000000000000000000002AMW42H';\n\n  // use most recent from: https://api.<mainnet/testnet>.hiro.so/v2/pox\n  const rewardCycle: UIntCV = uintCV(22);\n\n  // call a read-only function\n  const fnCall: ReadOnlyFunctionSuccessResponse = await contractsApi.callReadOnlyFunction({\n    contractAddress: principal,\n    contractName: 'pox',\n    functionName: 'is-pox-active',\n    readOnlyFunctionArgs: {\n      sender: principal,\n      arguments: [cvToHex(rewardCycle)],\n    },\n  });\n\n  console.log({\n    status: fnCall.okay,\n    result: fnCall.result,\n    representation: hexToCV(fnCall.result).type === ClarityType.BoolTrue,\n  });\n})().catch(console.error);\n```"
  },
  {
    "title": "How to sync a Bitcoin node",
    "description": "Learn how to sync a Bitcoin node for building Bitcoin applications.",
    "slug": "/guides/sync-a-bitcoin-node",
    "content": "\nimport { InlineCode } from '@/components/inline-code';\nimport { Accordion, Accordions } from 'fumadocs-ui/components/accordion';\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\nSyncing a Bitcoin node is often one of the first steps a developer takes when building a Bitcoin application. It's a great introduction to the Bitcoin developer ecosystem, and if you're relying on on-chain data, there's no safer way to get that data than doing it yourself.\n\nIn this guide, you will learn how to:\n\n1. Download Bitcoin Core daemon on your machine\n2. Configure `bitcoind`\n3. Start syncing your node\n4. Properly shutdown and restart your node\n\n<Callout title=\"Requirements\" type=\"warn\">\nTo get started, we first need to download `bitcoind`. In our example, we'll be using version 25.0. You can select a software version compatible with your device [from this list](https://bitcoincore.org/bin/bitcoin-core-25.0). \n</Callout>\n\n---\n\n## Configure <InlineCode>bitcoind</InlineCode>\n\nOnce your download is complete, make note of your path to the `bitcoind` executable.\n\n<Callout title=\"Note\">\nWhen you sync your node, we'll be running the program at `/bitcoin-25.0/bin/bitcoin`, which is where the `bitcoind` executable is located.\n</Callout>\n\nNext up is a couple configuration steps.\n\n1. Select or create a directory to store your Bitcoin data.\n2. Update the `bitcoin.conf` file to include the path to your Bitcoin data directory.\n\nThe Bitcoin chainstate is pretty large, and you need a place to store it. In this example, we are going to set up a directory called `bitcoin-data` on an external hard drive that we have mounted at `/Volumes/SSD`.\n\n<Callout title=\"Note\">\n  This folder, `bitcoin-data`, can be named whatever you like, and can exist locally or in an external hard drive.\n  \n  The most important thing is that it should exist in a place that has enough storage to hold all the Bitcoin data we will be receiving once it starts to sync.\n</Callout>\n\nNow navigate to your `bitcoin.conf` file, which is located in your `/path/to/bitcoin` directory and update the `datadir` field with your directory. \n\nIn this example, it would look like this:\n\n```bash bitcoin.conf\ndatadir=/Volumes/SSD/bitcoin-data/\n```\n\n<Accordions>\n<Accordion title=\"Example bitcoin.conf\">\nYou can override the default configuration with the following, including the path to where you will be storing all of the Bitcoin data once it starts syncing:\n\n```bash\ndatadir=/your-path-to/bitcoin-data/\nserver=1\nrpcuser=devnet\nrpcpassword=devnet\nrpcport=8332\nrpcallowip=0.0.0.0/0\nrpcallowip=::/0\ntxindex=1\nlisten=1\ndiscover=0\ndns=0\ndnsseed=0\nlistenonion=0\nrpcserialversion=1\ndisablewallet=0\nfallbackfee=0.00001\nrpcthreads=8\nblocksonly=1\ndbcache=4096\n\n# Start zeromq\nzmqpubhashblock=tcp://0.0.0.0:18543\n```\n</Accordion>\n</Accordions>\n\nIf you plan to use your node to receive transactions, you will need to make note of the `username` and `password` fields for your node.\n\n<Callout title=\"Note\">\nIn the example `bitcoin.conf` above, `devnet` is listed as the default `username` and `password`.\n</Callout>\n\n## Run the node\n\nWith a finished `bitcoin.conf` file, it's time to start up your node.\n\nThis takes the form of `path/to/bitcoind -conf=path/to/bitcoin.conf`, which in this example looks like:\n\n```terminal\n$ /Volumes/SSD/bitcoin-25.0/bin/bitcoind -conf=/Volumes/SSD/bitcoin-25.0/bitcoin.conf\n```\n\nAfter running this command, you will see `zmq_url` entries in your console's stdout, displaying ZeroMQ logs from your Bitcoin node. Congrats! You're now syncing!\n\n<Callout title=\"Note\">\nIt might take anywhere from a few hours to a few days to run and fully sync, depending on if it's your first time syncing a node.\n</Callout>\n\n## Proper shutdown and restart procedure\n\n1. Shutting down your node\n2. Restarting your node\n\nTo shut down your node safely, use the `bitcoin-cli` executable, located inside of the `bin` directory, and run the `stop` command:\n\n```terminal\n$ /path/to/bitcoin-cli \\\n  --conf=/path/to/bitcoin.conf \\\n  --rpcuser={{your-rpc-username}} \\\n  --rpcpassword={{your-rpc-password}} stop\n```\n\nTo start your node back up, all you need to do is refer to the previous steps from above by running `path/to/bitcoind -conf=path/to/bitcoin.conf`.\n\n<Callout title=\"How to eject an external hard drive\">\n  <Tabs items={[\"macOS\",\"Windows\"]}>\n    <Tab value={\"macOS\"}>\n      1. Go to the Finder, then the sidebar, and select the disk you want to eject under “Devices”. Click on the eject icon next to the name.\n      2. Wait for a confirmation message saying it's safe to eject the device before you unplug the drive.\n    </Tab>\n\n    <Tab value={\"Windows\"}>\n      1. Open File Explorer, select the drive from the list under “This PC” (PC > Devices and Drives), and click the “Eject” button.\n      2. Wait for a confirmation message saying it's safe to eject the device before you unplug the drive.\n    </Tab>\n  </Tabs>\n</Callout>\n\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/chainhook/guides/chainhook-as-a-service\"\n    title=\"Run Chainhook as a service\"\n    description=\"Learn how to use Chainhook to build your own custom API.\"\n  />\n  <Card\n    href=\"/guides/sync-a-stacks-node\"\n    title=\"Sync a Stacks node\"\n    description=\"Learn how to sync a Stacks node for running a local devnet.\"\n  />\n</Cards>\n"
  },
  {
    "title": "Build a no-loss lottery pool",
    "description": "Learn how to create a no-loss lottery pool that leverages stacking yield.",
    "slug": "/guides/no-loss-lottery",
    "content": "\nimport { Code, Terminal } from 'lucide-react';\n\nA no-loss lottery contract offers a unique way for participants to stack their assets and potentially earn a larger reward without the risk of losing their initial deposit.\n\nThis contract ensures that participants can stack their assets in a yield-generating pool, receive an NFT ticket, and have a chance to win additional rewards while retaining their original investment.\n\nIn this guide, you will learn how to:\n\n1. Define constants and data variables\n2. Create and manage participants and tickets\n3. Implement the lottery functionality\n4. Handle the selection of winners\n5. Claim and distribute rewards\n\n<Callout title=\"Note\">\nThis example uses the CityCoins protocol for the stacking yield mechanism, but leveraging a Stacking pool using Proof of Transfer (PoX4) can also be used.\n</Callout>\n\n---\n\n## Define constants and data variables\n\nFirst, define some constants and data variables to manage the state of your contract. Constants are used for fixed values, and data variables store the state that can change during the contract execution.\n\n```clarity\n(define-constant OWNER tx-sender)\n(define-constant ERR_UNAUTHORIZED (err u101000))\n\n(define-data-var lotteryPool uint u0)\n(define-data-var totalYield uint u0)\n(define-data-var ticketCounter uint u0)\n```\n\nThe `OWNER` constant defines the contract owner with administrative privileges, while `ERR_UNAUTHORIZED` handles unauthorized access attempts.\n\nKey data variables include `lotteryPool` for tracking stacked assets, `totalYield` for accumulated earnings, and `ticketCounter` for managing issued tickets.\n\n## Create and manage participants and tickets\n\nNext, define an NFT to represent a ticket and a map to store participant information.\n\n```clarity\n(define-map Participants\n  { participant: principal }\n  { ticketId: uint, amount: uint, cycle: uint, ticketExpirationAtCycle: uint, isWinner: bool }\n)\n\n(define-map Tickets\n  { ticketId: uint }\n  { owner: principal }\n)\n\n(define-non-fungible-token LotteryTicket uint)\n```\n\nThe `Participants` map links participants to their ticket details, while the `Tickets` map associates tickets with their owners.\n\nThe `LotteryTicket` defines an NFT for the lottery tickets, crucial for managing entries.\n\n## Implement the lottery functionality\n\nNow, it's time to implement the core function of the contract, where participants can enter the lottery by depositing their assets.\n\n```clarity\n(define-public (roll-the-dice (cityName (string-ascii 10)) (amount uint) (lockPeriod (optional uint)))\n  (let\n    (\n      (ticketId (+ (var-get ticketCounter) u1))\n      (actualLockPeriod (default-to u1 lockPeriod))\n      (rewardCycle (+ (contract-call? 'SP8A9HZ3PKST0S42VM9523Z9NV42SZ026V4K39WH.ccd007-citycoin-stacking get-current-reward-cycle) u1))\n    )\n\n    (begin\n      (try! (contract-call? 'SP1H1733V5MZ3SZ9XRW9FKYGEZT0JDGEB8Y634C7R.miamicoin-token-v2 transfer amount tx-sender (as-contract tx-sender) none))\n      (try! (nft-mint? LotteryTicket ticketId tx-sender))\n      (map-insert Participants { participant: tx-sender } { ticketId: ticketId, amount: amount, cycle: rewardCycle, ticketExpirationAtCycle: (+ rewardCycle actualLockPeriod), isWinner: false })\n      (map-set Tickets { ticketId: ticketId } { owner: tx-sender })\n      (var-set lotteryPool (+ (var-get lotteryPool) amount))\n      (var-set ticketCounter (+ (var-get ticketCounter) u1))\n      (ok ticketId)\n    )\n  )\n)\n```\n\nThe `roll-the-dice` function enables participants to join the lottery by depositing assets, specifying the city (`cityName`), the deposit amount (`amount`), and the lock period (`lockPeriod`).\n\nThis function is crucial for managing lottery entries and ensuring assets are properly locked for the specified duration.\n\nWhen a participant calls this function, the following steps occur:\n\n1. **Generate ticket and determine lock period**: A new ticket ID is generated, and the lock period is set (defaulting to 1 if not specified).\n2. **Transfer assets and mint NFT ticket**: The specified amount of assets is transferred from the participant to the contract, and an NFT representing the lottery ticket is minted and assigned to the participant.\n3. **Update participant and ticket data**: The participant's information, including ticket ID, amount, cycle, and expiration, is stored, and the ticket's ownership information is updated.\n4. **Update lottery pool and return ticket ID**: The total amount in the lottery pool is updated, the ticket counter is incremented, and the function returns the newly generated ticket ID to the participant.\n\nThis streamlined process ensures that each participant's entry is properly recorded and their assets are securely managed within the lottery system.\n\n## Handling the selection of winners\n\nNow, implement the function to select a winner randomly from the participants.\n\n```clarity\n(define-private (select-winner)\n  (match (contract-call? 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.citycoin-vrf-v2 get-save-rnd (- block-height u1)) randomTicketNumber\n    (let\n      (\n        (ticketCount (var-get ticketCounter))\n        (winningTicketId (mod randomTicketNumber ticketCount))\n        (winner (unwrap! (get-ticket winningTicketId) (err u404)))\n        (owner (get owner winner))\n        (participant (unwrap! (get-participant owner) (err u404)))\n      )\n      (map-set Participants { participant: owner }\n        { ticketId: winningTicketId, amount: (get amount participant), cycle: (get cycle participant), ticketExpirationAtCycle: (get ticketExpirationAtCycle participant), isWinner: true })\n      (ok owner)\n    )\n    selectionError (err selectionError)\n  )\n)\n```\nThe `select-winner` function randomly selects a winner using a number from the VRF contract (`get-save-rnd`) and updates their status with `unwrap!`. This ensures a fair and transparent winner selection process.\n\nWhen this function is called, the following steps occur:\n\n1. **Fetch random number**: A random number is obtained from the VRF contract by calling `get-save-rnd` with the previous block height.\n2. **Determine winning ticket**: The winning ticket ID is calculated by taking the modulus of the random number with the total number of tickets (`ticketCounter`).\n3. **Retrieve winner information**: The winner's ticket and participant information are retrieved using the calculated ticket ID.\n4. **Update winner status**: The participant's status is updated to indicate they are a winner by setting `isWinner` to `true` in the `Participants` map.\n\nThis process ensures that the winner is selected fairly and their status is accurately updated in the system.\n\n## Claim and distribute rewards\n\nLastly, implement the function to claim and distribute rewards to the winners.\n\n```clarity\n(define-public (claim-rewards (cityName (string-ascii 10)) (cycle uint))\n  (let\n    (\n      (cityId (unwrap-panic (contract-call? 'SP8A9HZ3PKST0S42VM9523Z9NV42SZ026V4K39WH.ccd004-city-registry get-city-id cityName)))\n      (cycleAmount (contract-call? 'SP8A9HZ3PKST0S42VM9523Z9NV42SZ026V4K39WH.ccd002-treasury-mia-stacking get-balance-stx))\n    )\n    (if (is-eq cityName \"mia\")\n      (try! (contract-call? 'SP8A9HZ3PKST0S42VM9523Z9NV42SZ026V4K39WH.ccd011-stacking-payouts send-stacking-reward-mia cycle cycleAmount))\n      (try! (contract-call? 'SP8A9HZ3PKST0S42VM9523Z9NV42SZ026V4K39WH.ccd011-stacking-payouts send-stacking-reward-nyc cycle cycleAmount))\n    )\n    (as-contract (contract-call? 'SP8A9HZ3PKST0S42VM9523Z9NV42SZ026V4K39WH.ccd007-citycoin-stacking claim-stacking-reward cityName cycle))\n  )\n)\n\n(define-public (distribute-rewards)\n  (select-winner)\n)\n```\n\nThe `claim-rewards` function enables participants to claim their staking rewards, while the `distribute-rewards` function calls `select-winner` to randomly select and reward winners, ensuring a fair distribution process.\n\nWhen the `claim-rewards` function is called, the following steps occur:\n\n1. **Retrieve city ID and balance**: The city ID is retrieved using the `get-city-id` function, and the balance for the specified cycle is obtained from the treasury contract.\n2. **Send stacking rewards**: Depending on the city (`mia` or `nyc`), the appropriate stacking reward function is called to send the rewards for the specified cycle.\n3. **Claim stacking reward**: The contract claims the stacking reward for the specified city and cycle.\n\nWhen the `distribute-rewards` function is called, it performs the following step:\n\n1. **Select winner**: The `select-winner` function is called to randomly select a winner from the participants and update their status.\n\nThis process ensures that participants can claim their rewards and that winners are selected and rewarded fairly.\n\n## Testing the contract\n\nTo test the contracts, use the following steps inside of `clarinet console`:\n\n```terminal\n$ ::advance_chain_tip 700000\n$ ::set_tx_sender\n$ (contract-call? 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.no-loss-lottery-pool roll-the-dice \"mia\" u500 none)\n$ ::advance_chain_tip 2000\n$ (contract-call? 'SP8A9HZ3PKST0S42VM9523Z9NV42SZ026V4K39WH.ccd002-treasury-mia-stacking deposit-stx u5000000000)\n$ (contract-call? 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.no-loss-lottery-pool claim \"mia\" u17)\n```\n\nTo bootstrap the CityCoins contracts, follow these steps:\n\n```clarity\n(contract-call? 'SP8A9HZ3PKST0S42VM9523Z9NV42SZ026V4K39WH.ccd004-city-registry get-or-create-city-id \"mia\")\n(contract-call? 'SP8A9HZ3PKST0S42VM9523Z9NV42SZ026V4K39WH.ccd004-city-registry get-or-create-city-id \"nyc\")\n(contract-call? 'SP8A9HZ3PKST0S42VM9523Z9NV42SZ026V4K39WH.ccd002-treasury-mia-stacking set-allowed 'SP1H1733V5MZ3SZ9XRW9FKYGEZT0JDGEB8Y634C7R.miamicoin-token-v2 true)\n(contract-call? 'SP8A9HZ3PKST0S42VM9523Z9NV42SZ026V4K39WH.ccd002-treasury-nyc-stacking set-allowed 'SPSCWDV3RKV5ZRN1FQD84YE1NQFEDJ9R1F4DYQ11.newyorkcitycoin-token-v2 true)\n```\n---\n\n## Next steps\n\n<Cards>\n  <Card\n    href=\"/stacks/clarinet/guides/create-a-new-project\"\n    title=\"Create a new project\"\n    description=\"Learn how to create a new Clarinet project.\"\n  />\n  <Card\n    href=\"/stacks/clarinet/guides/deploy-a-contract\"\n    title=\"Deploy a contract\"\n    description=\"Learn how to deploy a contract to a Clarinet network.\"\n  />\n</Cards>\n"
  },
  {
    "title": "DocsKit",
    "description": "DocsKit usage",
    "slug": "/guides/docskit",
    "content": "\n## Features\n\nDocsKit features:\n\n- adds [flags](#flags) and [annotations](#annotations) to codeblocks\n- includes a special syntax for [inline code](#inline-code)\n- adds three components that can be used in MDX: [_`<CodeTabs />`_](#codetabs), [_`<WithNotes />`_](#withnotes), and [_`<TerminalPicker />`_](#terminal-picker)\n- adds a [language switcher](#language-switcher) (which is another usage of _`<CodeTabs />`_)\n- codeblocks with language [`terminal`](#terminal) or [`package-install`](#package-install) are rendered with a different component\n\n## Flags\n\n````txt flags-example.md\n# !mark[/-wn/]\n```js index.js -wn\n```\n````\n\n- `-n` add line numbers\n- `-c` add copy button\n- `-w` word wrap\n- `-a` animate (for tabs)\n\n## Annotations\n\n````txt annotations-example.md\n```js\nconst x = 1;\n# !mark[/!mark/]\n// !mark(1:2)\nconst y = 2;\nconst z = 3;\n```\n````\n\n- `!mark` - highlight a line, a range of lines, or a regex\n- `!diff` - highlight added or removed lines\n- `!collapse` - collapse a range of lines\n- `!fold` - fold a regex pattern inline\n- `!link` - add a link\n- `!tooltip` - add a tooltip\n- `!callout` - add a callout\n\nLearn more about using annotations from Code Hike docs:\n\n- [Annotation comments](https://codehike.org/docs/concepts/annotations#annotation-comments)\n- [Using regular expressions](https://codehike.org/docs/concepts/annotations#using-regular-expressions-instead-of-ranges)\n\n## Mark\n\nYou can use it for one line (`!mark`), a range of lines (`!mark(1:3)`), a range of columns (`!mark[5:10]`), or a regex pattern (`!mark[/pattern/]`).\n\nYou can provide any valid CSS color, for example: `!mark(1:3) red` or `!mark(1:3) hsl(var(--hiro))`.\n\n```clarity\n;; !mark[/Counters/mg]\n(define-map Counters principal uint)\n\n;; !mark(1:3)\n(define-public (count-up)\n  (ok (map-set Counters tx-sender (+ (get-count tx-sender) u1)))\n)\n\n;; !mark hsl(var(--hiro))\n(define-read-only (get-count (who principal))\n  (default-to u0 (map-get? Counters who))\n)\n```\n\n## Diff\n\n```js\nfunction lorem(ipsum, dolor = 1) {\n  const sit = 10;\n  // !diff -\n  dolor = ipsum - sit;\n  // !diff +\n  dolor = sit - amet(dolor);\n  return sit ? consectetur(ipsum) : [];\n}\n```\n\n## Collapse\n\n```jsonc sample-alert-payload.json -cwn\n{\n  \"nonce\": 5,\n  \"fee_rate\": \"250\",\n  \"sponsored\": false,\n  \"post_condition_mode\": \"deny\",\n  // !collapse(1:9) collapsed\n  \"post_conditions\": [\n    {\n      \"type\": \"stx\",\n      \"condition_code\": \"sent_equal_to\",\n      \"amount\": \"3000000\",\n      \"principal\": {\n        \"type_id\": \"principal_standard\",\n      },\n    },\n  ],\n  \"anchor_mode\": \"any\",\n  \"tx_status\": \"pending\",\n  \"receipt_time\": 1726104636,\n  \"tx_type\": \"contract_call\",\n  // !collapse(1:11) collapsed\n  \"contract_call\": {\n    \"function_name\": \"donate\",\n    \"function_signature\": \"(define-public (donate (amount uint)))\",\n    \"function_args\": [\n      {\n        \"hex\": \"0x01000000000000000000000000002dc6c0\",\n        \"repr\": \"u3000000\",\n        \"name\": \"amount\",\n        \"type\": \"uint\",\n      },\n    ],\n  },\n}\n```\n\n## Fold\n\n```jsx\n// !fold[/className=\"(.*?)\"/gm]\nfunction Foo() {\n  return (\n    <div className=\"bg-red-200 opacity-50\">\n      <span className=\"block\">hey</span>\n    </div>\n  );\n}\n```\n\n## Link\n\n```js\n// !link[/foo/mg] https://example.com\n// !link[/bar/mg] https://example.com\nimport { foo, bar } from \"baz\";\n\nconst x = foo(10);\nconst y = bar(x);\n```\n\n## CodeTabs\n\n````txt tabs-example.md\n# !mark[/!!/mg]\n<CodeTabs flags=\"ac\">\n\n```ts !! index.ts\n\n```\n\n```css !! styles.css\n\n```\n</CodeTabs>\n````\n\nNote: the codeblocks inside the _`<CodeTabs />`_ component should have the `!!` decoration and a title.\n\nYou can pass flags to the _`<CodeTabs />`_ component to apply them to all codeblocks inside it. The `a` flag will animate the transition between tabs.\n\nExample:\n\n<CodeTabs flags=\"ac\">\n\n```clarity !! one.clar\n;; !mark[/increment/mg]\n(define-data-var count uint u0)\n\n(define-public (increment)\n  (begin\n    (var-set count (+ (var-get count) u1))\n    (ok (var-get count)) ;; !mark\n  )\n)\n```\n\n```solidity !! two.sol\n// !mark[/add/mg]\nuint256 constant TOO_BIG = 10;\nuint256 count = 0;\n\nfunction add(uint256 amount) public returns (uint256) {\n    uint256 newCount = count + amount;\n    if (newCount <= TOO_BIG) {\n        count = newCount;\n        return count;\n    }\n    revert(\"Amount too large\"); // !mark\n}\n```\n\n</CodeTabs>\n\n### Language switcher\n\nTo switch between languages, use the _`<CodeTabs />`_ component with the `storage` prop. The `storage` prop is used to store the selected language in the local storage and sync all the _`<CodeTabs storage=\"some-id\" />`_ using the same `storage` key.\n\n<CodeTabs flags=\"ac\" storage=\"ts\">\n\n```ts !! TypeScript\n(async () => {\n  const apiConfig: Configuration = new Configuration({\n    fetchApi: fetch,\n    // for mainnet, replace `testnet` with `mainnet`\n    basePath: \"https://api.testnet.hiro.so\",\n  });\n})().catch(console.error);\n```\n\n```js !! JavaScript\n(async () => {\n  const apiConfig = new Configuration({\n    fetchApi: fetch,\n    // for mainnet, replace `testnet` with `mainnet`\n    basePath: \"https://api.testnet.hiro.so\",\n  });\n})().catch(console.error);\n```\n\n</CodeTabs>\n\n## WithNotes\n\nFor `!callout` and `!tooltip` annotations, you can use the _`<WithNotes />`_ to define the content you want to show.\n\n### Callouts\n\n<WithNotes>\n\n```js index.js\n// !callout[/ipsum/] description\nimport lorem from \"ipsum\";\n\n// !callout[/sit/] inspect\nconst sit = lorem({ a: 1, b: 2 });\n```\n\n```js !inspect\nsit = [\n  { name: \"a\", value: 1 },\n  { name: \"b\", value: 2 },\n];\n```\n\n## !description\n\nThe default export of the `ipsum` package is a function that **returns an array**.\n\nKind of like _`Object.entries(x)`_ but different.\n\n</WithNotes>\n\n### Tooltips\n\n<WithNotes>\n\n```js demo.js\n// !tooltip[/lorem/] install\nimport { read, write } from \"lorem\";\n\n// !tooltip[/data.json/] data\nvar data = read(\"data.json\");\n\n// !tooltip[/test-123/] apikey\nwrite({ x: 1 }, { apiKey: \"test-123\" });\n```\n\nWe can also use tooltips [here](tooltip \"install\") in [prose](tooltip \"data\") text.\n\n```json !data data.json\n{\n  \"lorem\": \"ipsum dolor sit amet\",\n  \"foo\": [4, 8, 15, 16]\n}\n```\n\n## !install\n\nThis is a **fake library**. You can install it with:\n\n```terminal\n$ npm install lorem\n```\n\nIt lets you read and write data.\n\n## !apikey\n\nThis is a public sample test mode [API key](https://example.com). Don’t submit any personally information using this key.\n\nReplace this with your secret key found on the [API Keys page](https://example.com) in the dashboard.\n\n</WithNotes>\n\n## Inline code\n\nTo use inline codeyou need to use a special syntax: ``_`code`_``.\n\nThis syntax also allows you to specify the language for inline code ``_clarity`(contract-call? .counter count-up)`_`` renders: _clarity`(contract-call? .counter count-up)`_\n\n## Terminal\n\nTo use the terminal component, set the language of a codeblock to `terminal`, and start each command with `$`.\n\n```terminal\n$ tar -xf clarinet-linux-x64.tar.gz\n$ chmod +x ./clarinet\n$ mv ./clarinet /usr/local/bin\n```\n\nThe lines that don't start with `$` are rendered as collapsed output. The output can use ANSI colors and styles.\n\n```terminal\n$ npx create-next-app@latest\ncreate-next-app@14.2.13\n\u001b[32m✔\u001b[0m \u001b[1mWhat is your project?\u001b[0m \u001b[90m…\u001b[0m my-app\n$ npm run dev\n```\n\n### Terminal Picker\n\n<TerminalPicker>\n\n```terminal !! macOS\n$ brew install clarinet\n```\n\n```terminal !! Windows\n$ winget install clarinet\n```\n\n```terminal !! Cargo\n$ sudo apt install build-essential pkg-config libssl-dev\n```\n\n</TerminalPicker>\n\n### Package Install\n\nYou can use `package-install` as a language to get a picker for JS package managers.\n\n```package-install\n@stacks/connect\n```\n\n### Opting out of the terminal component\n\nTo use features from the normal codeblock component, you can still use languages like `sh` or `bash` or even `txt`.\n\n```sh Terminal -w\n# !tooltip[/v0.27.0/] You can change the v0.27.0 version that is available on the releases page.\n$ wget -nv download/v0.27.0/clarinet-linux-x64-glibc.tar.gz -O clarinet-linux-x64.tar.gz\n```\n"
  }
]