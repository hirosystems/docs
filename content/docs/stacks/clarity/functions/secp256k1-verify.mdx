---
title: secp256k1-verify
description: Verifying a signature against a message hash and public key in Clarity smart contracts.
---

## Function Signature

```clarity
(secp256k1-verify message-hash signature public-key)
```

- Input: `(buff 32), (buff 64) | (buff 65), (buff 33)`
- Output: `bool`

## Why it matters

The `secp256k1-verify` function is crucial for:

1. Verifying the authenticity of a message by checking the signature against the public key.
2. Implementing cryptographic verification in smart contracts.
3. Ensuring data integrity by validating signatures.
4. Simplifying the process of handling cryptographic operations in smart contracts.

## When to use it

Use `secp256k1-verify` when you need to:

- Verify the authenticity of a message by checking the signature against the public key.
- Implement cryptographic verification in your smart contract.
- Validate signatures to ensure data integrity.
- Handle cryptographic operations.

## Best Practices

- Ensure the `message-hash`, `signature`, and `public-key` are correctly formatted and valid.
- Use meaningful variable names for better readability.
- Combine with other cryptographic functions for comprehensive security management.
- Handle the possible error cases to ensure robust contract behavior.

## Practical Example: Verifying a Signature

Let's implement a function that verifies a signature against a message hash and public key:

```clarity
(define-public (verify-signature (message-hash (buff 32)) (signature (buff 65)) (public-key (buff 33)))
  (secp256k1-verify message-hash signature public-key)
)

;; Usage
(verify-signature 0xde5b9eb9e7c5592930eb2e30a01369c36586d872082ed8181ee83d2a0ec20f04 0x8738487ebe69b93d8e51583be8eee50bb4213fc49c767d329632730cc193b873554428fc936ca3569afc15f1c9365f6591d6251a89fee9c9ac661116824d3a1301 0x03adb8de4bfb65db2cfd6120d55c6526ae9c52e675db7e47308636534ba7786110) 
;; Returns true
```

This example demonstrates:
1. Using `secp256k1-verify` to verify a signature against a message hash and public key.
2. Implementing a public function to handle the signature verification.
3. Handling both successful and error cases.

## Common Pitfalls

1. Using `secp256k1-verify` with incorrectly formatted or invalid `message-hash`, `signature`, or `public-key`, causing the operation to fail.
2. Assuming the verification will always succeed, leading to unhandled error cases.
3. Not handling all possible conditions, resulting in incomplete cryptographic verification.
4. Overlooking the need for proper error handling and validation.

## Related Functions

- `secp256k1-recover?`: Recovers the public key from a message hash and signature.
- `sha256`: Computes the SHA-256 hash of the input.
- `hash160`: Computes the RIPEMD-160 hash of the SHA-256 hash of the input.

## Conclusion

The `secp256k1-verify` function is a fundamental tool for verifying signatures against message hashes and public keys in Clarity smart contracts. It allows developers to ensure data integrity and simplify cryptographic operations. When used effectively, `secp256k1-verify` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle cryptographic verification.
