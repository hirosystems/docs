---
title: unwrap-err!
description: Unpacking error responses in Clarity smart contracts.
---

## Function Signature

```clarity
(unwrap-err! response-input thrown-value)
```

- Input: `(response A B), C`
- Output: `B`

## Why it matters

The `unwrap-err!` function is crucial for:

1. Unpacking error responses to access their inner values.
2. Implementing logic that requires handling error responses.
3. Ensuring data integrity by validating the error unpacking process.
4. Simplifying the process of handling error responses in smart contracts.

## When to use it

Use `unwrap-err!` when you need to:

- Unpack error responses to access their inner values.
- Implement logic that requires handling error responses.
- Validate the error unpacking process to ensure data integrity.
- Handle error responses in your smart contract.

## Best Practices

- Ensure the input value is a response type.
- Use meaningful variable names for better readability.
- Combine with other error handling functions for comprehensive error management.
- Handle the possible error cases to ensure robust contract behavior.

## Practical Example: Unpacking an Error Response

Let's implement a function that processes an error response using `unwrap-err!`:

```clarity
(define-public (process-error-response (input (response int int)))
  (let
    (
      (errorValue (unwrap-err! input (err "No error found")))
    )
    (ok errorValue)
  )
)

;; Usage
(process-error-response (err 42)) ;; Returns (ok 42)
(process-error-response (ok 1)) ;; Returns (err "No error found")
```

This example demonstrates:
1. Using `unwrap-err!` to unpack an error response.
2. Implementing a public function to handle the error unpacking process.
3. Handling both successful and error cases.

## Common Pitfalls

1. Using `unwrap-err!` with values that are not response types, causing runtime errors.
2. Assuming the error unpacking will always succeed, leading to unhandled error cases.
3. Not handling all possible conditions, resulting in incomplete error management.
4. Overlooking the need for proper error handling and validation.

## Related Functions

- `unwrap!`: Unpacks optional and response types, returning a thrown value if unpacking fails.
- `unwrap-panic`: Unpacks optional and response types, throwing a runtime error if unpacking fails.
- `try!`: Unpacks optional and response types, returning `none` or the `err` value if unpacking fails.

## Conclusion

The `unwrap-err!` function is a fundamental tool for unpacking error responses in Clarity smart contracts. It allows developers to implement logic that requires handling error responses, ensuring data integrity and simplifying the error unpacking process. When used effectively, `unwrap-err!` enhances the reliability and maintainability of your smart contract code by providing a clear and concise way to handle error responses.
