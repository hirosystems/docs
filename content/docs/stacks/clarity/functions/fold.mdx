---
title: fold
description: Reducing a sequence to a single value in Clarity smart contracts.
---

## Function Signature

```clarity
(fold <function> <sequence> <initial-value>)
```

- Input: 
  - `<function>`: A function that takes two arguments and returns a single value
  - `<sequence>`: A list, buffer, or string to iterate over
  - `<initial-value>`: The starting value for the accumulation
- Output: The final accumulated value

## Why it matters

The `fold` function is crucial for:

1. Aggregating values from a sequence into a single result.
2. Performing complex computations on list elements.
3. Transforming data structures efficiently.
4. Implementing recursive-like operations without explicit recursion.

## When to use it

Use `fold` when you need to:

- Calculate a sum, product, or other aggregate value from a list.
- Transform a list into a single value or different data structure.
- Apply a function to each element of a sequence while maintaining state.
- Implement algorithms that would typically require recursion.

## Best Practices

- Ensure the function passed to `fold` is commutative if the order of operations doesn't matter.
- Use meaningful initial values that make sense for your aggregation.
- Consider using `fold` instead of explicit loops for cleaner, more functional code.
- Be mindful of the performance implications when folding over large sequences.

## Practical Example: Summing a List of Numbers

Let's implement a function that sums all numbers in a list:

```clarity
(define-read-only (sum-list (numbers (list 10 uint)))
  (fold + numbers u0)
)

;; Usage
(sum-list (list u1 u2 u3 u4 u5)) ;; Returns u15
```

This example demonstrates:
1. Using `fold` with the built-in `+` function to sum numbers.
2. Starting with an initial value of `u0`.
3. Applying the operation to each element in the list.

## Common Pitfalls

1. Using an initial value of the wrong type or that doesn't make sense for the operation.
2. Forgetting that `fold` processes elements from left to right, which matters for non-commutative operations.
3. Overusing `fold` for operations that might be more clearly expressed with other functions like `map` or `filter`.

## Related Functions

- `map`: Applies a function to each element in a sequence, returning a new sequence.
- `filter`: Selects elements from a sequence based on a predicate function.
- `reduce`: Similar to `fold` in other languages, but Clarity uses `fold` for this operation.

## Conclusion

The `fold` function is a powerful tool for aggregating and transforming data in Clarity smart contracts. It allows developers to express complex computations on sequences in a concise and functional manner. When used effectively, `fold` can simplify code, improve readability, and provide an efficient way to process collections of data within smart contracts.
