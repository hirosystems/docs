---
title: Get account transaction with transfers
description: Retrieves transaction details for a specific transaction including STX transfers for each transaction.
toc: false
---

import { 
  API,
  APIExample,
  APIInfo,
  APIPlayground,
  ExampleResponse,
  Property,
  Request,
  Requests,
  Response,
  Responses,
  ResponseTypes,
  Root,
  TypeScriptResponse
} from 'fumadocs-openapi/ui';

<Root baseUrl="https://api.hiro.so">

<API>

<APIInfo method={"GET"} route={"/extended/v1/address/{principal}/{tx_id}/with_transfers"}>

## Get account transaction information for specific transaction

**NOTE:** This endpoint is deprecated in favor of [Get events for an address transaction](/api/get-address-transaction-events).

        Retrieves transaction details for a given Transaction Id `tx_id`, for a given account or contract Identifier.

### Path Parameters

<Property name={"principal"} type={"Any properties in STX Address, Smart Contract ID"} required={true} deprecated={false}>

</Property>

<Property name={"tx_id"} type={"string"} required={true} deprecated={false}>

Transaction ID

</Property>

| Status code | Description |
| ----------- | ----------- |
| `200` | Transaction with STX transfers for a given address |
| `4XX` | Default Response |

<APIPlayground authorization={undefined} method={"GET"} route={"/extended/v1/address/{principal}/{tx_id}/with_transfers"} path={[{"name":"principal","type":"switcher","items":{"STX Address":{"type":"ref","isRequired":true,"schema":"0"},"Smart Contract ID":{"type":"ref","isRequired":true,"schema":"1"}},"isRequired":true},{"name":"tx_id","type":"string","defaultValue":"","isRequired":true}]} query={[]} header={[]} body={undefined} schemas={{"0":{"type":"string","defaultValue":"","isRequired":false,"description":"STX Address"},"1":{"type":"string","defaultValue":"","isRequired":false,"description":"Smart Contract ID"}}}>

</APIPlayground>

</APIInfo>

<APIExample>

<Requests items={["cURL","JavaScript"]}>

<Request value={"cURL"}>

```bash
curl -X GET "https://api.hiro.so//extended/v1/address/SP318Q55DEKHRXJK696033DQN5C54D9K2EE6DHRWP/string/with_transfers"
```

</Request>

<Request value={"JavaScript"}>

```js
fetch("https://api.hiro.so//extended/v1/address/SP318Q55DEKHRXJK696033DQN5C54D9K2EE6DHRWP/string/with_transfers", {
  method: "GET"
});
```

</Request>

</Requests>

<Responses items={["200","4XX"]}>

<Response value={"200"}>

Transaction with STX transfers for a given address

<ResponseTypes>

<ExampleResponse>

```json
{
  "tx": {
    "tx_id": "string",
    "nonce": 0,
    "fee_rate": "string",
    "sender_address": "string",
    "sponsor_nonce": 0,
    "sponsored": true,
    "sponsor_address": "string",
    "post_condition_mode": "allow",
    "post_conditions": [
      {
        "principal": {
          "type_id": "principal_origin"
        },
        "condition_code": "sent_equal_to",
        "amount": "string",
        "type": "stx"
      }
    ],
    "anchor_mode": "on_chain_only",
    "block_hash": "string",
    "block_height": 0,
    "block_time": 0,
    "block_time_iso": "string",
    "burn_block_time": 0,
    "burn_block_height": 0,
    "burn_block_time_iso": "string",
    "parent_burn_block_time": 0,
    "parent_burn_block_time_iso": "string",
    "canonical": true,
    "tx_index": 0,
    "tx_status": "success",
    "tx_result": {
      "hex": "string",
      "repr": "string"
    },
    "event_count": 0,
    "parent_block_hash": "string",
    "is_unanchored": true,
    "microblock_hash": "string",
    "microblock_sequence": 0,
    "microblock_canonical": true,
    "execution_cost_read_count": 0,
    "execution_cost_read_length": 0,
    "execution_cost_runtime": 0,
    "execution_cost_write_count": 0,
    "execution_cost_write_length": 0,
    "events": [
      {
        "event_index": 0,
        "event_type": "smart_contract_log",
        "tx_id": "string",
        "contract_log": {
          "contract_id": "string",
          "topic": "string",
          "value": {
            "hex": "string",
            "repr": "string"
          }
        }
      }
    ],
    "tx_type": "token_transfer",
    "token_transfer": {
      "recipient_address": "string",
      "amount": "string",
      "memo": "string"
    }
  },
  "stx_sent": "string",
  "stx_received": "string",
  "stx_transfers": [
    {
      "amount": "string",
      "sender": "string",
      "recipient": "string"
    }
  ],
  "ft_transfers": [
    {
      "amount": "string",
      "asset_identifier": "string",
      "sender": "string",
      "recipient": "string"
    }
  ],
  "nft_transfers": [
    {
      "value": {
        "hex": "string",
        "repr": "string"
      },
      "asset_identifier": "string",
      "sender": "string",
      "recipient": "string"
    }
  ]
}
```

</ExampleResponse>

<TypeScriptResponse>

```ts
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type SmartContractLogTransactionEvent = AbstractTransactionEvent & {
  event_type: "smart_contract_log";
  tx_id: string;
  contract_log: {
    contract_id: string;
    topic: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxLockTransactionEvent = AbstractTransactionEvent1 & {
  event_type: "stx_lock";
  tx_id: string;
  stx_lock_event: {
    locked_amount: string;
    unlock_height: number;
    locked_address: string;
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxAssetTransactionEvent = AbstractTransactionEvent2 & {
  event_type: "stx_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    sender: string;
    recipient: string;
    amount: string;
    memo?: string;
  };
};
export type FungibleTokenAssetTransactionEvent = AbstractTransactionEvent3 & {
  event_type: "fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    amount: string;
  };
};
export type NonFungibleTokenAssetTransactionEvent = AbstractTransactionEvent4 & {
  event_type: "non_fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type SmartContractLogTransactionEvent1 = AbstractTransactionEvent5 & {
  event_type: "smart_contract_log";
  tx_id: string;
  contract_log: {
    contract_id: string;
    topic: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxLockTransactionEvent1 = AbstractTransactionEvent6 & {
  event_type: "stx_lock";
  tx_id: string;
  stx_lock_event: {
    locked_amount: string;
    unlock_height: number;
    locked_address: string;
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxAssetTransactionEvent1 = AbstractTransactionEvent7 & {
  event_type: "stx_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    sender: string;
    recipient: string;
    amount: string;
    memo?: string;
  };
};
export type FungibleTokenAssetTransactionEvent1 = AbstractTransactionEvent8 & {
  event_type: "fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    amount: string;
  };
};
export type NonFungibleTokenAssetTransactionEvent1 = AbstractTransactionEvent9 & {
  event_type: "non_fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type SmartContractLogTransactionEvent2 = AbstractTransactionEvent10 & {
  event_type: "smart_contract_log";
  tx_id: string;
  contract_log: {
    contract_id: string;
    topic: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxLockTransactionEvent2 = AbstractTransactionEvent11 & {
  event_type: "stx_lock";
  tx_id: string;
  stx_lock_event: {
    locked_amount: string;
    unlock_height: number;
    locked_address: string;
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxAssetTransactionEvent2 = AbstractTransactionEvent12 & {
  event_type: "stx_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    sender: string;
    recipient: string;
    amount: string;
    memo?: string;
  };
};
export type FungibleTokenAssetTransactionEvent2 = AbstractTransactionEvent13 & {
  event_type: "fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    amount: string;
  };
};
export type NonFungibleTokenAssetTransactionEvent2 = AbstractTransactionEvent14 & {
  event_type: "non_fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type SmartContractLogTransactionEvent3 = AbstractTransactionEvent15 & {
  event_type: "smart_contract_log";
  tx_id: string;
  contract_log: {
    contract_id: string;
    topic: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxLockTransactionEvent3 = AbstractTransactionEvent16 & {
  event_type: "stx_lock";
  tx_id: string;
  stx_lock_event: {
    locked_amount: string;
    unlock_height: number;
    locked_address: string;
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxAssetTransactionEvent3 = AbstractTransactionEvent17 & {
  event_type: "stx_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    sender: string;
    recipient: string;
    amount: string;
    memo?: string;
  };
};
export type FungibleTokenAssetTransactionEvent3 = AbstractTransactionEvent18 & {
  event_type: "fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    amount: string;
  };
};
export type NonFungibleTokenAssetTransactionEvent3 = AbstractTransactionEvent19 & {
  event_type: "non_fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type SmartContractLogTransactionEvent4 = AbstractTransactionEvent20 & {
  event_type: "smart_contract_log";
  tx_id: string;
  contract_log: {
    contract_id: string;
    topic: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxLockTransactionEvent4 = AbstractTransactionEvent21 & {
  event_type: "stx_lock";
  tx_id: string;
  stx_lock_event: {
    locked_amount: string;
    unlock_height: number;
    locked_address: string;
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxAssetTransactionEvent4 = AbstractTransactionEvent22 & {
  event_type: "stx_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    sender: string;
    recipient: string;
    amount: string;
    memo?: string;
  };
};
export type FungibleTokenAssetTransactionEvent4 = AbstractTransactionEvent23 & {
  event_type: "fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    amount: string;
  };
};
export type NonFungibleTokenAssetTransactionEvent4 = AbstractTransactionEvent24 & {
  event_type: "non_fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type SmartContractLogTransactionEvent5 = AbstractTransactionEvent25 & {
  event_type: "smart_contract_log";
  tx_id: string;
  contract_log: {
    contract_id: string;
    topic: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxLockTransactionEvent5 = AbstractTransactionEvent26 & {
  event_type: "stx_lock";
  tx_id: string;
  stx_lock_event: {
    locked_amount: string;
    unlock_height: number;
    locked_address: string;
  };
};
/**
 * Only present in `smart_contract` and `contract_call` tx types.
 */
export type StxAssetTransactionEvent5 = AbstractTransactionEvent27 & {
  event_type: "stx_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    sender: string;
    recipient: string;
    amount: string;
    memo?: string;
  };
};
export type FungibleTokenAssetTransactionEvent5 = AbstractTransactionEvent28 & {
  event_type: "fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    amount: string;
  };
};
export type NonFungibleTokenAssetTransactionEvent5 = AbstractTransactionEvent29 & {
  event_type: "non_fungible_token_asset";
  tx_id: string;
  asset: {
    asset_event_type: "transfer" | "mint" | "burn";
    asset_id: string;
    sender: string;
    recipient: string;
    value: {
      hex: string;
      repr: string;
    };
  };
};

/**
 * Transaction with STX transfers for a given address
 */
export interface AddressTransactionWithTransfers {
  tx:
    | TokenTransferTransaction
    | SmartContractTransaction
    | ContractCallTransaction
    | PoisonMicroblockTransaction
    | CoinbaseTransaction
    | TenureChangeTransaction;
  /**
   * Total sent from the given address, including the tx fee, in micro-STX as an integer string.
   */
  stx_sent: string;
  /**
   * Total received by the given address in micro-STX as an integer string.
   */
  stx_received: string;
  stx_transfers: {
    /**
     * Amount transferred in micro-STX as an integer string.
     */
    amount: string;
    /**
     * Principal that sent STX. This is unspecified if the STX were minted.
     */
    sender?: string;
    /**
     * Principal that received STX. This is unspecified if the STX were burned.
     */
    recipient?: string;
  }[];
  ft_transfers?: {
    /**
     * Amount transferred as an integer string. This balance does not factor in possible SIP-010 decimals.
     */
    amount: string;
    /**
     * Fungible Token asset identifier.
     */
    asset_identifier: string;
    /**
     * Principal that sent the asset.
     */
    sender?: string;
    /**
     * Principal that received the asset.
     */
    recipient?: string;
  }[];
  nft_transfers?: {
    /**
     * Non Fungible Token asset value.
     */
    value: {
      hex: string;
      repr: string;
    };
    /**
     * Non Fungible Token asset identifier.
     */
    asset_identifier: string;
    /**
     * Principal that sent the asset.
     */
    sender?: string;
    /**
     * Principal that received the asset.
     */
    recipient?: string;
  }[];
}
export interface TokenTransferTransaction {
  /**
   * Transaction ID
   */
  tx_id: string;
  /**
   * Used for ordering the transactions originating from and paying from an account. The nonce ensures that a transaction is processed at most once. The nonce counts the number of times an account's owner(s) have authorized a transaction. The first transaction from an account will have a nonce value equal to 0, the second will have a nonce value equal to 1, and so on.
   */
  nonce: number;
  /**
   * Transaction fee as Integer string (64-bit unsigned integer).
   */
  fee_rate: string;
  /**
   * Address of the transaction initiator
   */
  sender_address: string;
  sponsor_nonce?: number;
  /**
   * Denotes whether the originating account is the same as the paying account
   */
  sponsored: boolean;
  sponsor_address?: string;
  post_condition_mode: "allow" | "deny";
  post_conditions: (
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "stx";
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "fungible";
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code: "sent" | "not_sent";
        type: "non_fungible";
        asset_value: {
          hex: string;
          repr: string;
        };
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
  )[];
  /**
   * `on_chain_only`: the transaction MUST be included in an anchored block, `off_chain_only`: the transaction MUST be included in a microblock, `any`: the leader can choose where to include the transaction.
   */
  anchor_mode: "on_chain_only" | "off_chain_only" | "any";
  /**
   * Hash of the blocked this transactions was associated with
   */
  block_hash: string;
  /**
   * Height of the block this transactions was associated with
   */
  block_height: number;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
   */
  block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  burn_block_time: number;
  /**
   * Height of the anchor burn block.
   */
  burn_block_height: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this block was mined.
   */
  burn_block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this parent block was mined
   */
  parent_burn_block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this parent block was mined.
   */
  parent_burn_block_time_iso: string;
  /**
   * Set to `true` if block corresponds to the canonical chain tip
   */
  canonical: boolean;
  /**
   * Index of the transaction, indicating the order. Starts at `0` and increases with each transaction
   */
  tx_index: number;
  /**
   * Status of the transaction
   */
  tx_status: "success" | "abort_by_response" | "abort_by_post_condition";
  /**
   * Result of the transaction. For contract calls, this will show the value returned by the call. For other transaction types, this will return a boolean indicating the success of the transaction.
   */
  tx_result: {
    /**
     * Hex string representing the value fo the transaction result
     */
    hex: string;
    /**
     * Readable string of the transaction result
     */
    repr: string;
  };
  /**
   * Number of transaction events
   */
  event_count: number;
  /**
   * Hash of the previous block.
   */
  parent_block_hash: string;
  /**
   * True if the transaction is included in a microblock that has not been confirmed by an anchor block.
   */
  is_unanchored: boolean;
  /**
   * The microblock hash that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be an empty string.
   */
  microblock_hash: string;
  /**
   * The microblock sequence number that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be 2147483647 (0x7fffffff, the max int32 value), this value preserves logical transaction ordering on (block_height, microblock_sequence, tx_index).
   */
  microblock_sequence: number;
  /**
   * Set to `true` if microblock is anchored in the canonical chain tip, `false` if the transaction was orphaned in a micro-fork.
   */
  microblock_canonical: boolean;
  /**
   * Execution cost read count.
   */
  execution_cost_read_count: number;
  /**
   * Execution cost read length.
   */
  execution_cost_read_length: number;
  /**
   * Execution cost runtime.
   */
  execution_cost_runtime: number;
  /**
   * Execution cost write count.
   */
  execution_cost_write_count: number;
  /**
   * Execution cost write length.
   */
  execution_cost_write_length: number;
  events: (
    | SmartContractLogTransactionEvent
    | StxLockTransactionEvent
    | StxAssetTransactionEvent
    | FungibleTokenAssetTransactionEvent
    | NonFungibleTokenAssetTransactionEvent
  )[];
  tx_type: "token_transfer";
  token_transfer: {
    recipient_address: string;
    /**
     * Transfer amount as Integer string (64-bit unsigned integer)
     */
    amount: string;
    /**
     * Hex encoded arbitrary message, up to 34 bytes length (should try decoding to an ASCII string)
     */
    memo: string;
  };
}
export interface AbstractTransactionEvent {
  event_index: number;
}
export interface AbstractTransactionEvent1 {
  event_index: number;
}
export interface AbstractTransactionEvent2 {
  event_index: number;
}
export interface AbstractTransactionEvent3 {
  event_index: number;
}
export interface AbstractTransactionEvent4 {
  event_index: number;
}
export interface SmartContractTransaction {
  /**
   * Transaction ID
   */
  tx_id: string;
  /**
   * Used for ordering the transactions originating from and paying from an account. The nonce ensures that a transaction is processed at most once. The nonce counts the number of times an account's owner(s) have authorized a transaction. The first transaction from an account will have a nonce value equal to 0, the second will have a nonce value equal to 1, and so on.
   */
  nonce: number;
  /**
   * Transaction fee as Integer string (64-bit unsigned integer).
   */
  fee_rate: string;
  /**
   * Address of the transaction initiator
   */
  sender_address: string;
  sponsor_nonce?: number;
  /**
   * Denotes whether the originating account is the same as the paying account
   */
  sponsored: boolean;
  sponsor_address?: string;
  post_condition_mode: "allow" | "deny";
  post_conditions: (
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "stx";
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "fungible";
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code: "sent" | "not_sent";
        type: "non_fungible";
        asset_value: {
          hex: string;
          repr: string;
        };
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
  )[];
  /**
   * `on_chain_only`: the transaction MUST be included in an anchored block, `off_chain_only`: the transaction MUST be included in a microblock, `any`: the leader can choose where to include the transaction.
   */
  anchor_mode: "on_chain_only" | "off_chain_only" | "any";
  /**
   * Hash of the blocked this transactions was associated with
   */
  block_hash: string;
  /**
   * Height of the block this transactions was associated with
   */
  block_height: number;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
   */
  block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  burn_block_time: number;
  /**
   * Height of the anchor burn block.
   */
  burn_block_height: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this block was mined.
   */
  burn_block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this parent block was mined
   */
  parent_burn_block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this parent block was mined.
   */
  parent_burn_block_time_iso: string;
  /**
   * Set to `true` if block corresponds to the canonical chain tip
   */
  canonical: boolean;
  /**
   * Index of the transaction, indicating the order. Starts at `0` and increases with each transaction
   */
  tx_index: number;
  /**
   * Status of the transaction
   */
  tx_status: "success" | "abort_by_response" | "abort_by_post_condition";
  /**
   * Result of the transaction. For contract calls, this will show the value returned by the call. For other transaction types, this will return a boolean indicating the success of the transaction.
   */
  tx_result: {
    /**
     * Hex string representing the value fo the transaction result
     */
    hex: string;
    /**
     * Readable string of the transaction result
     */
    repr: string;
  };
  /**
   * Number of transaction events
   */
  event_count: number;
  /**
   * Hash of the previous block.
   */
  parent_block_hash: string;
  /**
   * True if the transaction is included in a microblock that has not been confirmed by an anchor block.
   */
  is_unanchored: boolean;
  /**
   * The microblock hash that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be an empty string.
   */
  microblock_hash: string;
  /**
   * The microblock sequence number that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be 2147483647 (0x7fffffff, the max int32 value), this value preserves logical transaction ordering on (block_height, microblock_sequence, tx_index).
   */
  microblock_sequence: number;
  /**
   * Set to `true` if microblock is anchored in the canonical chain tip, `false` if the transaction was orphaned in a micro-fork.
   */
  microblock_canonical: boolean;
  /**
   * Execution cost read count.
   */
  execution_cost_read_count: number;
  /**
   * Execution cost read length.
   */
  execution_cost_read_length: number;
  /**
   * Execution cost runtime.
   */
  execution_cost_runtime: number;
  /**
   * Execution cost write count.
   */
  execution_cost_write_count: number;
  /**
   * Execution cost write length.
   */
  execution_cost_write_length: number;
  events: (
    | SmartContractLogTransactionEvent1
    | StxLockTransactionEvent1
    | StxAssetTransactionEvent1
    | FungibleTokenAssetTransactionEvent1
    | NonFungibleTokenAssetTransactionEvent1
  )[];
  tx_type: "smart_contract";
  smart_contract: {
    clarity_version: number | null;
    /**
     * Contract identifier formatted as `<principaladdress>.<contract_name>`
     */
    contract_id: string;
    /**
     * Clarity code of the smart contract being deployed
     */
    source_code: string;
  };
}
export interface AbstractTransactionEvent5 {
  event_index: number;
}
export interface AbstractTransactionEvent6 {
  event_index: number;
}
export interface AbstractTransactionEvent7 {
  event_index: number;
}
export interface AbstractTransactionEvent8 {
  event_index: number;
}
export interface AbstractTransactionEvent9 {
  event_index: number;
}
export interface ContractCallTransaction {
  /**
   * Transaction ID
   */
  tx_id: string;
  /**
   * Used for ordering the transactions originating from and paying from an account. The nonce ensures that a transaction is processed at most once. The nonce counts the number of times an account's owner(s) have authorized a transaction. The first transaction from an account will have a nonce value equal to 0, the second will have a nonce value equal to 1, and so on.
   */
  nonce: number;
  /**
   * Transaction fee as Integer string (64-bit unsigned integer).
   */
  fee_rate: string;
  /**
   * Address of the transaction initiator
   */
  sender_address: string;
  sponsor_nonce?: number;
  /**
   * Denotes whether the originating account is the same as the paying account
   */
  sponsored: boolean;
  sponsor_address?: string;
  post_condition_mode: "allow" | "deny";
  post_conditions: (
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "stx";
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "fungible";
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code: "sent" | "not_sent";
        type: "non_fungible";
        asset_value: {
          hex: string;
          repr: string;
        };
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
  )[];
  /**
   * `on_chain_only`: the transaction MUST be included in an anchored block, `off_chain_only`: the transaction MUST be included in a microblock, `any`: the leader can choose where to include the transaction.
   */
  anchor_mode: "on_chain_only" | "off_chain_only" | "any";
  /**
   * Hash of the blocked this transactions was associated with
   */
  block_hash: string;
  /**
   * Height of the block this transactions was associated with
   */
  block_height: number;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
   */
  block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  burn_block_time: number;
  /**
   * Height of the anchor burn block.
   */
  burn_block_height: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this block was mined.
   */
  burn_block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this parent block was mined
   */
  parent_burn_block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this parent block was mined.
   */
  parent_burn_block_time_iso: string;
  /**
   * Set to `true` if block corresponds to the canonical chain tip
   */
  canonical: boolean;
  /**
   * Index of the transaction, indicating the order. Starts at `0` and increases with each transaction
   */
  tx_index: number;
  /**
   * Status of the transaction
   */
  tx_status: "success" | "abort_by_response" | "abort_by_post_condition";
  /**
   * Result of the transaction. For contract calls, this will show the value returned by the call. For other transaction types, this will return a boolean indicating the success of the transaction.
   */
  tx_result: {
    /**
     * Hex string representing the value fo the transaction result
     */
    hex: string;
    /**
     * Readable string of the transaction result
     */
    repr: string;
  };
  /**
   * Number of transaction events
   */
  event_count: number;
  /**
   * Hash of the previous block.
   */
  parent_block_hash: string;
  /**
   * True if the transaction is included in a microblock that has not been confirmed by an anchor block.
   */
  is_unanchored: boolean;
  /**
   * The microblock hash that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be an empty string.
   */
  microblock_hash: string;
  /**
   * The microblock sequence number that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be 2147483647 (0x7fffffff, the max int32 value), this value preserves logical transaction ordering on (block_height, microblock_sequence, tx_index).
   */
  microblock_sequence: number;
  /**
   * Set to `true` if microblock is anchored in the canonical chain tip, `false` if the transaction was orphaned in a micro-fork.
   */
  microblock_canonical: boolean;
  /**
   * Execution cost read count.
   */
  execution_cost_read_count: number;
  /**
   * Execution cost read length.
   */
  execution_cost_read_length: number;
  /**
   * Execution cost runtime.
   */
  execution_cost_runtime: number;
  /**
   * Execution cost write count.
   */
  execution_cost_write_count: number;
  /**
   * Execution cost write length.
   */
  execution_cost_write_length: number;
  events: (
    | SmartContractLogTransactionEvent2
    | StxLockTransactionEvent2
    | StxAssetTransactionEvent2
    | FungibleTokenAssetTransactionEvent2
    | NonFungibleTokenAssetTransactionEvent2
  )[];
  tx_type: "contract_call";
  contract_call: {
    /**
     * Contract identifier formatted as `<principaladdress>.<contract_name>`
     */
    contract_id: string;
    /**
     * Name of the Clarity function to be invoked
     */
    function_name: string;
    /**
     * Function definition, including function name and type as well as parameter names and types
     */
    function_signature: string;
    function_args?: {
      hex: string;
      repr: string;
      name: string;
      type: string;
    }[];
  };
}
export interface AbstractTransactionEvent10 {
  event_index: number;
}
export interface AbstractTransactionEvent11 {
  event_index: number;
}
export interface AbstractTransactionEvent12 {
  event_index: number;
}
export interface AbstractTransactionEvent13 {
  event_index: number;
}
export interface AbstractTransactionEvent14 {
  event_index: number;
}
export interface PoisonMicroblockTransaction {
  /**
   * Transaction ID
   */
  tx_id: string;
  /**
   * Used for ordering the transactions originating from and paying from an account. The nonce ensures that a transaction is processed at most once. The nonce counts the number of times an account's owner(s) have authorized a transaction. The first transaction from an account will have a nonce value equal to 0, the second will have a nonce value equal to 1, and so on.
   */
  nonce: number;
  /**
   * Transaction fee as Integer string (64-bit unsigned integer).
   */
  fee_rate: string;
  /**
   * Address of the transaction initiator
   */
  sender_address: string;
  sponsor_nonce?: number;
  /**
   * Denotes whether the originating account is the same as the paying account
   */
  sponsored: boolean;
  sponsor_address?: string;
  post_condition_mode: "allow" | "deny";
  post_conditions: (
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "stx";
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "fungible";
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code: "sent" | "not_sent";
        type: "non_fungible";
        asset_value: {
          hex: string;
          repr: string;
        };
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
  )[];
  /**
   * `on_chain_only`: the transaction MUST be included in an anchored block, `off_chain_only`: the transaction MUST be included in a microblock, `any`: the leader can choose where to include the transaction.
   */
  anchor_mode: "on_chain_only" | "off_chain_only" | "any";
  /**
   * Hash of the blocked this transactions was associated with
   */
  block_hash: string;
  /**
   * Height of the block this transactions was associated with
   */
  block_height: number;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
   */
  block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  burn_block_time: number;
  /**
   * Height of the anchor burn block.
   */
  burn_block_height: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this block was mined.
   */
  burn_block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this parent block was mined
   */
  parent_burn_block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this parent block was mined.
   */
  parent_burn_block_time_iso: string;
  /**
   * Set to `true` if block corresponds to the canonical chain tip
   */
  canonical: boolean;
  /**
   * Index of the transaction, indicating the order. Starts at `0` and increases with each transaction
   */
  tx_index: number;
  /**
   * Status of the transaction
   */
  tx_status: "success" | "abort_by_response" | "abort_by_post_condition";
  /**
   * Result of the transaction. For contract calls, this will show the value returned by the call. For other transaction types, this will return a boolean indicating the success of the transaction.
   */
  tx_result: {
    /**
     * Hex string representing the value fo the transaction result
     */
    hex: string;
    /**
     * Readable string of the transaction result
     */
    repr: string;
  };
  /**
   * Number of transaction events
   */
  event_count: number;
  /**
   * Hash of the previous block.
   */
  parent_block_hash: string;
  /**
   * True if the transaction is included in a microblock that has not been confirmed by an anchor block.
   */
  is_unanchored: boolean;
  /**
   * The microblock hash that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be an empty string.
   */
  microblock_hash: string;
  /**
   * The microblock sequence number that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be 2147483647 (0x7fffffff, the max int32 value), this value preserves logical transaction ordering on (block_height, microblock_sequence, tx_index).
   */
  microblock_sequence: number;
  /**
   * Set to `true` if microblock is anchored in the canonical chain tip, `false` if the transaction was orphaned in a micro-fork.
   */
  microblock_canonical: boolean;
  /**
   * Execution cost read count.
   */
  execution_cost_read_count: number;
  /**
   * Execution cost read length.
   */
  execution_cost_read_length: number;
  /**
   * Execution cost runtime.
   */
  execution_cost_runtime: number;
  /**
   * Execution cost write count.
   */
  execution_cost_write_count: number;
  /**
   * Execution cost write length.
   */
  execution_cost_write_length: number;
  events: (
    | SmartContractLogTransactionEvent3
    | StxLockTransactionEvent3
    | StxAssetTransactionEvent3
    | FungibleTokenAssetTransactionEvent3
    | NonFungibleTokenAssetTransactionEvent3
  )[];
  tx_type: "poison_microblock";
  poison_microblock: {
    /**
     * Hex encoded microblock header
     */
    microblock_header_1: string;
    /**
     * Hex encoded microblock header
     */
    microblock_header_2: string;
  };
}
export interface AbstractTransactionEvent15 {
  event_index: number;
}
export interface AbstractTransactionEvent16 {
  event_index: number;
}
export interface AbstractTransactionEvent17 {
  event_index: number;
}
export interface AbstractTransactionEvent18 {
  event_index: number;
}
export interface AbstractTransactionEvent19 {
  event_index: number;
}
export interface CoinbaseTransaction {
  /**
   * Transaction ID
   */
  tx_id: string;
  /**
   * Used for ordering the transactions originating from and paying from an account. The nonce ensures that a transaction is processed at most once. The nonce counts the number of times an account's owner(s) have authorized a transaction. The first transaction from an account will have a nonce value equal to 0, the second will have a nonce value equal to 1, and so on.
   */
  nonce: number;
  /**
   * Transaction fee as Integer string (64-bit unsigned integer).
   */
  fee_rate: string;
  /**
   * Address of the transaction initiator
   */
  sender_address: string;
  sponsor_nonce?: number;
  /**
   * Denotes whether the originating account is the same as the paying account
   */
  sponsored: boolean;
  sponsor_address?: string;
  post_condition_mode: "allow" | "deny";
  post_conditions: (
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "stx";
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "fungible";
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code: "sent" | "not_sent";
        type: "non_fungible";
        asset_value: {
          hex: string;
          repr: string;
        };
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
  )[];
  /**
   * `on_chain_only`: the transaction MUST be included in an anchored block, `off_chain_only`: the transaction MUST be included in a microblock, `any`: the leader can choose where to include the transaction.
   */
  anchor_mode: "on_chain_only" | "off_chain_only" | "any";
  /**
   * Hash of the blocked this transactions was associated with
   */
  block_hash: string;
  /**
   * Height of the block this transactions was associated with
   */
  block_height: number;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
   */
  block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  burn_block_time: number;
  /**
   * Height of the anchor burn block.
   */
  burn_block_height: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this block was mined.
   */
  burn_block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this parent block was mined
   */
  parent_burn_block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this parent block was mined.
   */
  parent_burn_block_time_iso: string;
  /**
   * Set to `true` if block corresponds to the canonical chain tip
   */
  canonical: boolean;
  /**
   * Index of the transaction, indicating the order. Starts at `0` and increases with each transaction
   */
  tx_index: number;
  /**
   * Status of the transaction
   */
  tx_status: "success" | "abort_by_response" | "abort_by_post_condition";
  /**
   * Result of the transaction. For contract calls, this will show the value returned by the call. For other transaction types, this will return a boolean indicating the success of the transaction.
   */
  tx_result: {
    /**
     * Hex string representing the value fo the transaction result
     */
    hex: string;
    /**
     * Readable string of the transaction result
     */
    repr: string;
  };
  /**
   * Number of transaction events
   */
  event_count: number;
  /**
   * Hash of the previous block.
   */
  parent_block_hash: string;
  /**
   * True if the transaction is included in a microblock that has not been confirmed by an anchor block.
   */
  is_unanchored: boolean;
  /**
   * The microblock hash that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be an empty string.
   */
  microblock_hash: string;
  /**
   * The microblock sequence number that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be 2147483647 (0x7fffffff, the max int32 value), this value preserves logical transaction ordering on (block_height, microblock_sequence, tx_index).
   */
  microblock_sequence: number;
  /**
   * Set to `true` if microblock is anchored in the canonical chain tip, `false` if the transaction was orphaned in a micro-fork.
   */
  microblock_canonical: boolean;
  /**
   * Execution cost read count.
   */
  execution_cost_read_count: number;
  /**
   * Execution cost read length.
   */
  execution_cost_read_length: number;
  /**
   * Execution cost runtime.
   */
  execution_cost_runtime: number;
  /**
   * Execution cost write count.
   */
  execution_cost_write_count: number;
  /**
   * Execution cost write length.
   */
  execution_cost_write_length: number;
  events: (
    | SmartContractLogTransactionEvent4
    | StxLockTransactionEvent4
    | StxAssetTransactionEvent4
    | FungibleTokenAssetTransactionEvent4
    | NonFungibleTokenAssetTransactionEvent4
  )[];
  tx_type: "coinbase";
  coinbase_payload: {
    /**
     * Hex encoded 32-byte scratch space for block leader's use
     */
    data: string;
    alt_recipient?: string | null;
    vrf_proof?: string | null;
  };
}
export interface AbstractTransactionEvent20 {
  event_index: number;
}
export interface AbstractTransactionEvent21 {
  event_index: number;
}
export interface AbstractTransactionEvent22 {
  event_index: number;
}
export interface AbstractTransactionEvent23 {
  event_index: number;
}
export interface AbstractTransactionEvent24 {
  event_index: number;
}
export interface TenureChangeTransaction {
  /**
   * Transaction ID
   */
  tx_id: string;
  /**
   * Used for ordering the transactions originating from and paying from an account. The nonce ensures that a transaction is processed at most once. The nonce counts the number of times an account's owner(s) have authorized a transaction. The first transaction from an account will have a nonce value equal to 0, the second will have a nonce value equal to 1, and so on.
   */
  nonce: number;
  /**
   * Transaction fee as Integer string (64-bit unsigned integer).
   */
  fee_rate: string;
  /**
   * Address of the transaction initiator
   */
  sender_address: string;
  sponsor_nonce?: number;
  /**
   * Denotes whether the originating account is the same as the paying account
   */
  sponsored: boolean;
  sponsor_address?: string;
  post_condition_mode: "allow" | "deny";
  post_conditions: (
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "stx";
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code:
          | "sent_equal_to"
          | "sent_greater_than"
          | "sent_greater_than_or_equal_to"
          | "sent_less_than"
          | "sent_less_than_or_equal_to";
        amount: string;
        type: "fungible";
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
    | {
        principal:
          | {
              type_id: "principal_origin";
            }
          | {
              type_id: "principal_standard";
              address: string;
            }
          | {
              type_id: "principal_contract";
              address: string;
              contract_name: string;
            };
        condition_code: "sent" | "not_sent";
        type: "non_fungible";
        asset_value: {
          hex: string;
          repr: string;
        };
        asset: {
          asset_name: string;
          contract_address: string;
          contract_name: string;
        };
      }
  )[];
  /**
   * `on_chain_only`: the transaction MUST be included in an anchored block, `off_chain_only`: the transaction MUST be included in a microblock, `any`: the leader can choose where to include the transaction.
   */
  anchor_mode: "on_chain_only" | "off_chain_only" | "any";
  /**
   * Hash of the blocked this transactions was associated with
   */
  block_hash: string;
  /**
   * Height of the block this transactions was associated with
   */
  block_height: number;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) indicating when this block was mined.
   */
  block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this block was mined.
   */
  burn_block_time: number;
  /**
   * Height of the anchor burn block.
   */
  burn_block_height: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this block was mined.
   */
  burn_block_time_iso: string;
  /**
   * Unix timestamp (in seconds) indicating when this parent block was mined
   */
  parent_burn_block_time: number;
  /**
   * An ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) timestamp indicating when this parent block was mined.
   */
  parent_burn_block_time_iso: string;
  /**
   * Set to `true` if block corresponds to the canonical chain tip
   */
  canonical: boolean;
  /**
   * Index of the transaction, indicating the order. Starts at `0` and increases with each transaction
   */
  tx_index: number;
  /**
   * Status of the transaction
   */
  tx_status: "success" | "abort_by_response" | "abort_by_post_condition";
  /**
   * Result of the transaction. For contract calls, this will show the value returned by the call. For other transaction types, this will return a boolean indicating the success of the transaction.
   */
  tx_result: {
    /**
     * Hex string representing the value fo the transaction result
     */
    hex: string;
    /**
     * Readable string of the transaction result
     */
    repr: string;
  };
  /**
   * Number of transaction events
   */
  event_count: number;
  /**
   * Hash of the previous block.
   */
  parent_block_hash: string;
  /**
   * True if the transaction is included in a microblock that has not been confirmed by an anchor block.
   */
  is_unanchored: boolean;
  /**
   * The microblock hash that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be an empty string.
   */
  microblock_hash: string;
  /**
   * The microblock sequence number that this transaction was streamed in. If the transaction was batched in an anchor block (not included within a microblock) then this value will be 2147483647 (0x7fffffff, the max int32 value), this value preserves logical transaction ordering on (block_height, microblock_sequence, tx_index).
   */
  microblock_sequence: number;
  /**
   * Set to `true` if microblock is anchored in the canonical chain tip, `false` if the transaction was orphaned in a micro-fork.
   */
  microblock_canonical: boolean;
  /**
   * Execution cost read count.
   */
  execution_cost_read_count: number;
  /**
   * Execution cost read length.
   */
  execution_cost_read_length: number;
  /**
   * Execution cost runtime.
   */
  execution_cost_runtime: number;
  /**
   * Execution cost write count.
   */
  execution_cost_write_count: number;
  /**
   * Execution cost write length.
   */
  execution_cost_write_length: number;
  events: (
    | SmartContractLogTransactionEvent5
    | StxLockTransactionEvent5
    | StxAssetTransactionEvent5
    | FungibleTokenAssetTransactionEvent5
    | NonFungibleTokenAssetTransactionEvent5
  )[];
  tx_type: "tenure_change";
  tenure_change_payload: {
    /**
     * Consensus hash of this tenure. Corresponds to the sortition in which the miner of this block was chosen.
     */
    tenure_consensus_hash: string;
    /**
     * Consensus hash of the previous tenure. Corresponds to the sortition of the previous winning block-commit.
     */
    prev_tenure_consensus_hash: string;
    /**
     * Current consensus hash on the underlying burnchain. Corresponds to the last-seen sortition.
     */
    burn_view_consensus_hash: string;
    /**
     * (Hex string) Stacks Block hash
     */
    previous_tenure_end: string;
    /**
     * The number of blocks produced in the previous tenure.
     */
    previous_tenure_blocks: number;
    /**
     * Cause of change in mining tenure. Depending on cause, tenure can be ended or extended.
     */
    cause: "block_found" | "extended";
    /**
     * (Hex string) The ECDSA public key hash of the current tenure.
     */
    pubkey_hash: string;
  };
}
export interface AbstractTransactionEvent25 {
  event_index: number;
}
export interface AbstractTransactionEvent26 {
  event_index: number;
}
export interface AbstractTransactionEvent27 {
  event_index: number;
}
export interface AbstractTransactionEvent28 {
  event_index: number;
}
export interface AbstractTransactionEvent29 {
  event_index: number;
}
```

</TypeScriptResponse>

</ResponseTypes>

</Response>

<Response value={"4XX"}>

<ResponseTypes>

<ExampleResponse>

```json
{
  "error": "string",
  "message": "string"
}
```

</ExampleResponse>

<TypeScriptResponse>

```ts
export interface ErrorResponse {
  error: string;
  message?: string;
  [k: string]: unknown;
}
```

</TypeScriptResponse>

</ResponseTypes>

</Response>

</Responses>

</APIExample>

</API>

</Root>
