---
title: Concepts
description: Understand Bitcoin metaprotocols, indexing architecture, and how the Bitcoin Indexer extracts structured data from the blockchain.
---

## Bitcoin metaprotocols

Metaprotocols are standards built on top of Bitcoin that add new functionality without modifying the base protocol. They encode data within Bitcoin transactions that can be interpreted to represent assets, ownership, or other information.

### How metaprotocols work

Bitcoin transactions contain space for arbitrary data through:
- **OP_RETURN outputs** - Up to 80 bytes of data
- **Witness data** - Segregated witness fields
- **Inscription envelopes** - Ordinals protocol format

The Bitcoin Indexer parses these data fields to extract metaprotocol information:

```
Bitcoin Transaction → Parser → Structured Data → API
```

### Supported metaprotocols

**Ordinals**
Digital artifacts inscribed on individual satoshis:
- Inscriptions (images, text, code)
- Unique satoshi tracking
- Collection support

**Runes**
Fungible token protocol optimized for efficiency:
- UTXO-based balances
- Efficient state transitions
- No off-chain data

**BRC-20**
Token standard using JSON inscriptions:
- Deploy, mint, transfer operations
- Balance tracking
- Marketplace integration

## Indexing architecture

The Bitcoin Indexer uses a multi-stage pipeline to process blockchain data:

<Mermaid
  chart="
graph TB
    A[Bitcoin Core Node] -->|ZMQ Events| B[Block Processor]
    B --> C{Reorg Detection}
    C -->|New Block| D[Parser Pipeline]
    C -->|Reorg| E[Rollback Handler]
    E --> D
    D --> F[Ordinals Parser]
    D --> G[Runes Parser]
    D --> H[BRC-20 Parser]
    F --> I[PostgreSQL]
    G --> I
    H --> I
    I --> J[REST APIs]
    
    style A fill:#FF7733,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
    style B fill:#B3D9FF,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
    style C fill:#F5F5F5,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
    style D fill:#B3D9FF,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
    style E fill:#B3D9FF,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
    style F fill:#B3D9FF,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
    style G fill:#B3D9FF,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
    style H fill:#B3D9FF,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
    style I fill:#F5F5F5,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
    style J fill:#C2EBC4,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c"
/>

### Processing stages

1. **Block ingestion** - Receives blocks via ZeroMQ from Bitcoin Core
2. **Reorg detection** - Compares block hashes to detect chain reorganizations
3. **Parallel parsing** - Processes metaprotocols concurrently
4. **State management** - Updates balances and ownership
5. **API serving** - Provides REST endpoints for queries

## Reorg handling

Bitcoin reorganizations occur when the network switches to a longer valid chain, invalidating previously confirmed blocks.

### Automatic reorg handling

The indexer maintains internal state to handle reorgs seamlessly:

```json
{
  "block_height": 820000,
  "block_hash": "00000000000000000002ee82e2e0e648d90536e32d214a4917cbec0bbd3e3e91",
  "indexed_at": "2023-12-15T10:30:00Z",
  "metaprotocol_states": {
    "ordinals": { "inscriptions": 45234123 },
    "runes": { "etched": 15234 },
    "brc20": { "tokens": 8923 }
  }
}
```

When a reorg is detected:
1. Rollback to the common ancestor block
2. Mark affected data as pending
3. Re-process blocks on the new chain
4. Update API responses atomically

## Performance optimization

The indexer uses several techniques for optimal performance:

### Parallel processing

Each metaprotocol parser runs in its own thread:
- Independent parsing pipelines
- Shared block data access
- Concurrent database writes

### Archive bootstrapping

Instead of indexing from genesis:
1. Download pre-indexed archives from Hiro
2. Verify archive integrity
3. Resume indexing from archive height
4. Reduces sync time from weeks to hours

### Database optimization

PostgreSQL configuration for high throughput:
- Bulk inserts with COPY
- Partial indexes on hot paths  
- Table partitioning by block height
- Async commit for non-critical data

## API design patterns

REST endpoints follow consistent patterns across metaprotocols:

### Resource endpoints
```
GET /ordinals/v1/inscriptions/{id}
GET /runes/v1/runes/{name}  
GET /brc-20/v1/tokens/{ticker}
```

### List endpoints with pagination
```
GET /ordinals/v1/inscriptions?limit=20&offset=0
GET /runes/v1/activity?limit=50&offset=100
```

### Address-specific queries
```
GET /ordinals/v1/inscriptions?address={address}
GET /runes/v1/balances/{address}
```

:::next-steps
- [System requirements](/tools/bitcoin-indexer/run-indexer/system-requirements): Detailed hardware and software requirements
- [Ordinals API](/tools/bitcoin-indexer/metaprotocol-apis/ordinals-api): Query inscriptions and digital artifacts
:::