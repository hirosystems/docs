---
title: Validating your contracts
sidebarTitle: Validation & analysis
description: Clarinet provides powerful tools for validating, analyzing, and debugging your smart contracts. From static type checking to real-time cost analysis, you can ensure your contracts are correct and efficient before deployment.
---


import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@/components/ui/accordion';

Contract validation in Clarity development encompasses static analysis, runtime debugging, and cost optimization. Each approach serves different purposes in ensuring contract correctness and efficiency.

## Understanding contract validation

**Static Analysis vs Runtime Debugging**

| Static Analysis             | Runtime Debugging            |
|-----------------------------|------------------------------|
| Catches errors before deployment | Reveals behavior during execution |
| Type mismatches, syntax errors   | Actual execution costs   |
| Trait compliance violations      | State changes and side effects |
| Undefined variable usage         | Transaction flow and results |
| Function signature issues        | Performance bottlenecks   |

## Static analysis

The `clarinet check` command performs comprehensive validation of your contracts without executing them:

```terminal
$ clarinet check
[32mâœ”[0m [1m3 contracts checked[0m
```

When validation fails, Clarinet provides detailed diagnostics:

```terminal -o
$ clarinet check
[31mâœ–[0m [1m1 error detected[0m
[31mError in contracts/token.clar:15:10[0m
  |
15|  (ok (+ balance amount))
  |         ^^^^^^^
  |
  = [1mType error: expected uint, found (response uint uint)[0m
```

**Validation scope**

Clarinet validates multiple aspects of your contracts:

| Validation Type | What It Checks |
|----------------|----------------|
| **Type safety** | Function parameters, return values, variable types |
| **Trait compliance** | Implementation matches trait definitions |
| **Response consistency** | Ok/err branches return same types |
| **Variable scope** | All variables defined before use |
| **Function visibility** | Public/private/read-only modifiers |

**Checking specific contracts**

Validate individual contracts during focused development:

```terminal
$ clarinet check contracts/nft.clar
[32mâœ”[0m [1mcontracts/nft.clar syntax checks passed[0m
```

**Integration with CI/CD**

Automate validation in your continuous integration pipeline:

```yaml .github/workflows/validate.yml
name: Contract Validation
on: [push, pull_request]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Clarinet
        run: curl -L https://install.hiro.so/clarinet | sh
      - name: Validate contracts
        run: clarinet check
```

## Runtime analysis

The Clarinet console provides powerful runtime analysis tools that let you inspect contract behavior during execution.

**Cost analysis with `::toggle_costs`**

Enable automatic cost display after every expression:

```terminal -o
$ clarinet console
$ ::toggle_costs
[30mAlways show costs: true[0m
$ (contract-call? .counter count-up)
[30m+----------------------+----------+------------+------------+
|                      | Consumed | Limit      | Percentage |
|----------------------+----------+------------+------------|
| Runtime              | 4775     | 5000000000 | 0.00 %     |
|----------------------+----------+------------+------------|
| Read count           | 5        | 15000      | 0.03 %     |
|----------------------+----------+------------+------------|
| Read length (bytes)  | 268      | 100000000  | 0.00 %     |
|----------------------+----------+------------+------------|
| Write count          | 1        | 15000      | 0.01 %     |
|----------------------+----------+------------+------------|
| Write length (bytes) | 41       | 15000000   | 0.00 %     |
+----------------------+----------+------------+------------+[0m
[1m(ok true)[0m
```

**Execution tracing with `::trace`**

Trace function calls to understand execution flow:

```terminal -o
$ ::trace (contract-call? .defi-pool swap u100 'token-a 'token-b)
(contract-call? .defi-pool swap u100 'token-a 'token-b) [30m<console>[0m
( get-pool-balance 'token-a ) [30mdefi-pool:15:8[0m
  [31mâ†³ args:[0m [1m'token-a[0m
    [34mu50000[0m
( get-pool-balance 'token-b ) [30mdefi-pool:16:8[0m
  [31mâ†³ args:[0m [1m'token-b[0m
    [34mu75000[0m
( calculate-output u100 u50000 u75000 ) [30mdefi-pool:18:12[0m
  [31mâ†³ args:[0m [1mu100, u50000, u75000[0m
    [34mu149[0m
[34m(ok u149)[0m
```

**Interactive debugging with `::debug`**

Set breakpoints and step through execution:

```terminal
$ ::debug (contract-call? .complex-contract process-batch)
$ break validate-input
[32mBreakpoint set at validate-input[0m
$ continue
[33mHit breakpoint at validate-input:23[0m
```

Debug navigation commands:
- `step` or `s` - Step into sub-expressions
- `finish` or `f` - Complete current expression
- `next` or `n` - Step over sub-expressions  
- `continue` or `c` - Continue to next breakpoint

## Cost optimization strategies

Understanding execution costs helps you write efficient contracts that minimize transaction fees for users.

**Understanding cost metrics**

Clarinet tracks five cost categories, each with block-level limits:

| Category | What It Measures | Optimization Focus |
|----------|-----------------|--------------------|
| **Runtime** | Code complexity and contract size | Simplify logic, reduce contract size |
| **Read count** | Memory/state access frequency | Minimize repeated reads |
| **Read length** | Data volume read | Use efficient data structures |
| **Write count** | State modification frequency | Batch updates when possible |
| **Write length** | Data volume written | Store only essential data |

**Using `::get_costs` for analyzing specific function costs:**

```terminal -o
$ ::get_costs (contract-call? .defi-pool add-liquidity u1000 u1000)
[30m+----------------------+----------+------------+------------+
|                      | Consumed | Limit      | Percentage |
|----------------------+----------+------------+------------|
| Runtime              | 12250    | 5000000000 | 0.00 %     |
|----------------------+----------+------------+------------|
| Read count           | 6        | 15000      | 0.04 %     |
|----------------------+----------+------------+------------|
| Read length (bytes)  | 192      | 100000000  | 0.00 %     |
|----------------------+----------+------------+------------|
| Write count          | 3        | 15000      | 0.02 %     |
|----------------------+----------+------------+------------|
| Write length (bytes) | 96       | 15000000   | 0.00 %     |
+----------------------+----------+------------+------------+[0m
[1m(ok {lp-tokens: u1000})[0m
```

**Identifying and optimizing costly operations using `::trace`:**

```terminal
$ ::trace (contract-call? .complex-algo process-large-dataset)
```

Look for:
- Loops with high iteration counts
- Nested map/filter operations
- Repeated contract calls
- Large data structure manipulations

## Debugging workflows

Master interactive debugging to quickly identify issues by starting a debugging session:

```terminal
$ clarinet console
$ ::debug (contract-call? .auction place-bid u1000)
$ continue
```

At each breakpoint:
- Inspect variable values
- Check contract state
- Evaluate expressions
- Modify execution flow

**Analyzing failed transactions using `::trace`:**

```terminal -o
$ ::trace (contract-call? .marketplace purchase u999)
(contract-call? .marketplace purchase u999) [30m<console>[0m
( get-listing u999 ) [30mmarketplace:45:12[0m
  [31mâ†³ args:[0m [1mu999[0m
    [34mnone[0m
[31m(err u404)[0m  [30m# Listing not found[0m
```

**Using `::encode` and `::decode` for data inspection**

Debug complex data structures:

```terminal
$ ::decode 0x0c00000002046e616d65020000000543686f636f62616c616e6365010000000000000000000000000000000064
[1m{balance: u100, name: "Choco"}[0m
$ ::encode (list {id: u1, active: true} {id: u2, active: false})
[30m0x0b000000020c00000002026964010000000000000000000000000000000001066163746976650301...[0m
```

**Testing time-dependent logic using `::get_block_height` and `::advance_chain_tip`:**

```terminal -o
$ ::get_block_height
[1mCurrent block height: u10[0m
$ ::advance_chain_tip 100
[32mâœ” Advanced chain tip by 100 blocks[0m
$ (contract-call? .vesting claim)
[32m(ok {claimed: u2500, remaining: u7500})[0m
```

## Common issues

<Accordion type="single" collapsible>
  <AccordionItem value="validation-errors">
    <AccordionTrigger>Type errors during validation</AccordionTrigger>
    <AccordionContent>
      <div className="pb-4 pt-2">
        Common type validation errors and solutions:

        **Response type mismatch:**
        ```clarity
        ;; Error: branches return different types
        (if condition
            (ok u1)
            (err "failed"))  ;; string vs uint
        
        ;; Fix: ensure consistent types
        (if condition
            (ok u1)
            (err u1))
        ```

        **Trait implementation errors:**
        ```clarity
        ;; Implement all required functions with exact signatures
        (impl-trait .token-trait.token)
        ```
      </div>
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="high-costs">
    <AccordionTrigger>Unexpectedly high execution costs</AccordionTrigger>
    <AccordionContent>
      <div className="pb-4 pt-2">
        Common causes of high costs:

        1. **Unbounded loops**: Use `fold` with fixed-size lists
        2. **Repeated reads**: Cache values in `let` bindings
        3. **Large contract size**: Split into multiple contracts
        4. **Complex expressions**: Simplify nested operations

        Use `::toggle_costs` to identify expensive operations during development.
      </div>
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="debugging-tips">
    <AccordionTrigger>Debugging complex contract interactions</AccordionTrigger>
    <AccordionContent>
      <div className="pb-4 pt-2">
        **Debugging strategy:**

        1. Start with `::trace` to see execution flow
        2. Add breakpoints at critical functions
        3. Use `::get_costs` to find performance issues
        4. Check state with read-only calls between steps
        5. Verify assumptions with `::encode`/`::decode`

        **Pro tip**: Create helper functions for common debugging tasks:
        ```clarity
        (define-read-only (debug-state)
          {balance: (var-get total-balance),
           users: (var-get user-count),
           paused: (var-get is-paused)})
        ```
      </div>
    </AccordionContent>
  </AccordionItem>
</Accordion>

## Next steps

Now that you understand contract validation and analysis:

- Explore [contract deployment](/tools/clarinet/deployment) for moving to testnet/mainnet
- Learn about [automated testing](/tools/clarinet/clarinet-sdk) with the Clarinet SDK
- Review the [CLI reference](/tools/clarinet/cli-reference#clarinet-check) for advanced options