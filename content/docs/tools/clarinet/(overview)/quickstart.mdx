---
title: Quickstart
description: Build your first Clarity smart contract in under 5 minutes
---

## What you'll learn

In this guide, you'll build a simple counter smart contract and interact with it in a local environment. By the end, you'll understand:

<div className="space-y-3 my-6">
  <div className="flex items-start gap-3">
    <ArrowRight className="h-4 w-4 text-brand-orange mt-1.5 flex-shrink-0" />
    <span>How to create and structure a Clarity smart contract project</span>
  </div>
  <div className="flex items-start gap-3">
    <ArrowRight className="h-4 w-4 text-brand-orange mt-1.5 flex-shrink-0" />
    <span>The basics of writing Clarity code with maps and public functions</span>
  </div>
  <div className="flex items-start gap-3">
    <ArrowRight className="h-4 w-4 text-brand-orange mt-1.5 flex-shrink-0" />
    <span>How to validate and test your contracts using Clarinet's console</span>
  </div>
</div>

## Prerequisites

To follow this guide, you'll need:

<div className="space-y-3 my-6">
  <div className="flex items-start gap-3">
    <div className="h-4 w-4 mt-1.5 flex-shrink-0 rounded border-2 border-brand-orange bg-brand-orange flex items-center justify-center">
      <Check className="h-3 w-3 text-white" />
    </div>
    <span>Clarinet installed on your machine. Follow the [installation guide](/tools/clarinet#installation) if needed.</span>
  </div>
  <div className="flex items-start gap-3">
    <div className="h-4 w-4 mt-1.5 flex-shrink-0 rounded border-2 border-brand-orange bg-brand-orange flex items-center justify-center">
      <Check className="h-3 w-3 text-white" />
    </div>
    <span>A code editor like VS Code for editing Clarity files.</span>
  </div>
</div>

## Quickstart

<Steps>
  <Step>
    ### Create your project
    
    Let's start by creating a new Clarinet project. The `clarinet new` command sets up everything you need for smart contract development, including a testing framework, deployment configurations, and a local development environment:
    
    ```terminal
    $ clarinet new counter
    [32mCreate directory[0m [1mcounter[0m
    [32mCreate directory[0m [1mcontracts[0m
    [32mCreate directory[0m [1msettings[0m
    [32mCreate directory[0m [1mtests[0m
    [32mCreate file[0m [1mClarinet.toml[0m
    [32mCreate file[0m [1mpackage.json[0m
    [32mCreate file[0m [1mvitest.config.js[0m
    ```

    Clarinet creates a complete project structure for you. Each folder serves a specific purpose in your development workflow:
    
    <Files className="font-fono pointer-events-none bg-background">
      <Folder name="counter" defaultOpen>
        <Folder name="contracts" />
        <Folder name="settings">
          <File name="Devnet.toml" />
          <File name="Mainnet.toml" />
          <File name="Testnet.toml" />
        </Folder>
        <Folder name="tests" />
        <File name="Clarinet.toml" />
        <File name="package.json" />
        <File name="vitest.config.js" />
      </Folder>
    </Files>
  </Step>
  
  <Step>
    ### Generate your contract
    
    Now that we have our project structure, let's create a smart contract. Navigate into your project directory and use Clarinet's contract generator:
    
    ```terminal
    $ cd counter
    $ clarinet contract new counter
    [32mCreated file[0m [1mcontracts/counter.clar[0m
    [32mCreated file[0m [1mtests/counter.test.ts[0m
    [33mUpdated Clarinet.toml[0m [1mwith contract counter[0m
    ```

    Clarinet automatically creates both your contract file and a corresponding test file. This follows the best practice of writing tests alongside your contract code:
    
    | File | Purpose |
    |------|---------|
    | `contracts/counter.clar` | Your smart contract code |
    | `tests/counter.test.ts` | Test file for your contract |

    <Callout type="info">
    Notice that Clarinet also updated your `Clarinet.toml` file. This configuration file tracks all contracts in your project and their deployment settings.
    </Callout>
  </Step>
  
  <Step>
    ### Write your contract code
    
    Time to write our smart contract! Open `contracts/counter.clar` and replace its contents with our counter implementation. This contract will maintain a separate count for each user who interacts with it:
    
    ```clarity contracts/counter.clar -c
    ;; Define a map to store counts for each user
    (define-map Counters principal uint)

    ;; Increment the count for the caller
    (define-public (count-up)
      (ok (map-set Counters tx-sender (+ (get-count tx-sender) u1)))
    )

    ;; Get the current count for a user
    (define-read-only (get-count (who principal))
      (default-to u0 (map-get? Counters who))
    )
    ```

    Let's understand what each part does:
    - `define-map` creates a persistent storage map that associates each user (principal) with their count
    - `tx-sender` is a built-in variable that contains the address of whoever calls the function
    - `define-public` declares functions that can modify contract state
    - `define-read-only` declares functions that only read data without modifying it
  </Step>
  
  <Step>
    ### Validate your contract
    
    Before we can test our contract, let's make sure it's syntactically correct and type-safe. Clarinet's check command analyzes your contract without deploying it:
    
    ```terminal
    $ clarinet check
    [32mâœ”[0m [1m1 contract checked[0m
    ```

    If you see errors instead, here are the most common issues and how to fix them:

    | Error | Fix |
    |-------|-----|
    | `Unknown keyword` | Check spelling of Clarity functions |
    | `Type mismatch` | Ensure you're using correct types (uint, principal, etc.) |
    | `Unresolved contract` | Verify contract name matches filename |
  </Step>
  
  <Step>
    ### Test in the console
    
    Now for the exciting partâ€”let's interact with our contract! Clarinet provides an interactive console where you can call functions and see results immediately. Start the console with:
    
    ```terminal
    $ clarinet console
    ```

    Once the console loads, you can call your contract functions directly. Here are a few examples you can try:
    
    ```terminal
    $ (contract-call? .counter count-up)
    (ok true)
    $ (contract-call? .counter get-count tx-sender)
    u1
    $ (contract-call? .counter count-up)
    (ok true)
    $ (contract-call? .counter get-count tx-sender)
    u2
    ```
  </Step>
</Steps>

## Next steps

<Cards>
  <NextCard 
    href="/tools/clarinet/writing-clarity-contracts"
    title="Writing Clarity contracts"
    description="Learn how to write Clarity contracts."
  />
  <NextCard 
    href="/tools/clarinet/running-devnet"
    title="Deploy to devnet"
    description="Learn how to deploy your contract to a local blockchain."
  />
</Cards>