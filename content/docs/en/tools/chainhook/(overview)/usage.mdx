---
title: Usage
description: Learn Chainhook core concepts, event filtering, webhook delivery, and best practices
---

# Usage

Learn the core concepts of working with Chainhooks, how they process blockchain events, and best practices for building reliable event-driven applications.

## How Chainhooks Work

A chainhook monitors blockchain events and delivers matching data to your application via webhooks. Each chainhook consists of three main components:

### 1. Filters

Filters define which blockchain events trigger your chainhook. You can monitor:

- **Token events** - FT/NFT transfers, mints, and burns
- **STX events** - STX transfers and operations
- **Contract events** - Deployments, function calls, and logs
- **System events** - Block rewards and tenure changes

Example filter for FT transfers:
```json
{
  "events": [
    {
      "type": "ft_transfer",
      "asset_identifier": "SP...ABC.token::usdc"
    }
  ]
}
```

Learn more in the [Filter Reference](/tools/chainhook/reference/filters).

### 2. Actions

Actions define where chainhook data is delivered. Currently, chainhooks support HTTP POST to your webhook endpoint:

```json
{
  "action": {
    "type": "http_post",
    "url": "https://example.com/webhooks"
  }
}
```

Your endpoint receives a POST request with the event payload whenever a filter matches.

### 3. Options

Options customize the payload content and evaluation behavior:

```json
{
  "options": {
    "decode_clarity_values": true,
    "include_block_metadata": true,
    "enable_on_registration": true
  }
}
```

Learn more in the [Options Reference](/tools/chainhook/reference/options).

---

## Event Processing Flow

1. **Block Evaluation** - Chainhook evaluates each new block against your filters
2. **Event Matching** - If events match your filters, a payload is generated
3. **Webhook Delivery** - The payload is POSTed to your configured endpoint
4. **Reorg Handling** - If a reorg occurs, rollback events are sent

```
Blockchain → Chainhook → Filter Match → Webhook Delivery → Your Application
```

---

## Webhook Payloads

When a chainhook triggers, you receive a payload with this structure:

```json
{
  "event": {
    "apply": [
      {
        "block_identifier": { "index": 150000, "hash": "0x..." },
        "transactions": [
          {
            "metadata": { /* tx info */ },
            "operations": [ /* state changes */ ]
          }
        ]
      }
    ],
    "rollback": [],
    "chain": "stacks",
    "network": "mainnet"
  },
  "chainhook": {
    "uuid": "chainhook-uuid",
    "name": "my-chainhook"
  }
}
```

Learn more in the [Payload Anatomy](/tools/chainhook/reference/payload-anatomy) reference.

---

## Handling Blockchain Reorganizations

Chainhook automatically detects blockchain reorganizations (reorgs) and sends both `apply` and `rollback` events to keep your data consistent.

### Understanding Reorgs

A reorg occurs when the blockchain's canonical chain changes:
1. Some blocks become orphaned (removed from the canonical chain)
2. New blocks become part of the canonical chain
3. Transactions may be reordered or invalidated

### Processing Reorg Events

Always process rollback events before apply events:

```typescript
app.post('/webhooks', async (req, res) => {
  const { apply, rollback } = req.body.event;

  // Step 1: Roll back orphaned blocks
  for (const block of rollback) {
    await database.revertBlock(block);
    console.log(`Rolled back block ${block.block_identifier.index}`);
  }

  // Step 2: Apply new canonical blocks
  for (const block of apply) {
    await database.processBlock(block);
    console.log(`Applied block ${block.block_identifier.index}`);
  }

  res.sendStatus(200);
});
```

### Best Practices for Reorgs

1. **Process rollbacks first** - Always revert orphaned blocks before applying new ones
2. **Use transactions** - Wrap database operations in transactions for atomicity
3. **Track block hashes** - Store block hashes to detect reorgs in your data
4. **Test reorg scenarios** - Use the [evaluate method](/tools/chainhook/evaluate) to test reorg handling

---

## SDK vs Platform

Choose the right tool for your use case:

### Use the Chainhook SDK When:

- **Editing required** - Platform UI doesn't support editing chainhooks yet
- **Automation** - Integrate chainhook management into your CI/CD pipeline
- **Programmatic control** - Create/update/delete chainhooks from your application
- **Scale** - Manage many chainhooks with bulk operations
- **Advanced features** - Use evaluate for historical indexing or testing

### Use the Platform UI When:

- **Getting started** - Create your first chainhook quickly without code
- **Visual creation** - Prefer a form-based interface
- **Viewing status** - Monitor chainhook activity and metrics
- **Managing keys** - Generate and manage API keys visually

:::callout{type="info"}
Both approaches use the same underlying Chainhook API and deliver identical webhook payloads.
:::

---

## Chainhook Lifecycle

### 1. Create
Register a chainhook with filters, action, and options:
- SDK: `client.registerChainhook({ ... })`
- Platform: Fill out the creation form

### 2. Enable
Activate the chainhook to start receiving events:
- SDK: Set `enable_on_registration: true` or call `client.enableChainhook()`
- Platform: Enable toggle in the UI

### 3. Monitor
Track chainhook activity and performance:
- SDK: `client.getChainhook(uuid)` to check status
- Platform: View metrics in the dashboard

### 4. Update
Modify filters, options, or webhook URL:
- SDK: `client.updateChainhook(uuid, { ... })`
- Platform: Not currently available (use SDK)

### 5. Disable/Delete
Pause or remove a chainhook:
- SDK: `client.enableChainhook(uuid, false)` or `client.deleteChainhook(uuid)`
- Platform: Disable toggle or delete button

---

## Best Practices

### Webhook Security

1. **Validate secrets** - Check the `x-chainhook-consumer-secret` header on all requests
2. **Use HTTPS** - Always use encrypted endpoints for webhooks
3. **Rotate secrets** - Periodically rotate webhook secrets with `rotateConsumerSecret()`
4. **Implement retries** - Handle webhook delivery failures gracefully

### Performance

1. **Filter precisely** - Use specific filters to reduce unnecessary webhooks
2. **Process asynchronously** - Return 200 quickly, process events in the background
3. **Batch operations** - Use bulk enable/disable for managing multiple chainhooks
4. **Monitor payload size** - Only enable options you need to reduce payload size

### Reliability

1. **Handle reorgs** - Always process rollback events correctly
2. **Idempotent processing** - Handle duplicate webhook deliveries
3. **Test before enabling** - Use `evaluateChainhook()` against known blocks
4. **Set expiration** - Use `expire_after_occurrences` for time-limited chainhooks

### Development

1. **Start on testnet** - Test your chainhooks on testnet before mainnet
2. **Use decode options** - Enable `decode_clarity_values` for easier debugging
3. **Log webhook deliveries** - Track all incoming webhooks for debugging
4. **Version your chainhooks** - Include version numbers in chainhook names

---

## Common Patterns

### Track User Activity

Monitor all activity for a specific address:

```typescript
await client.registerChainhook({
  name: 'user-activity-tracker',
  chain: 'stacks',
  network: 'mainnet',
  filters: {
    events: [
      { type: 'stx_transfer', sender: 'SP...USER' },
      { type: 'stx_transfer', receiver: 'SP...USER' },
      { type: 'ft_transfer', sender: 'SP...USER' },
      { type: 'nft_transfer', sender: 'SP...USER' },
    ],
  },
  action: { type: 'http_post', url: 'https://api.myapp.com/user-events' },
  options: { decode_clarity_values: true, enable_on_registration: true },
});
```

### Monitor Contract Calls

Track specific contract function calls:

```typescript
await client.registerChainhook({
  name: 'dex-swap-monitor',
  chain: 'stacks',
  network: 'mainnet',
  filters: {
    events: [
      {
        type: 'contract_call',
        contract_identifier: 'SP...DEX.swap-contract',
        function_name: 'swap',
      },
    ],
  },
  action: { type: 'http_post', url: 'https://api.myapp.com/swaps' },
  options: { decode_clarity_values: true, enable_on_registration: true },
});
```

### Time-Limited Monitoring

Create a chainhook that expires after a certain number of events:

```typescript
await client.registerChainhook({
  name: 'limited-nft-mints',
  chain: 'stacks',
  network: 'mainnet',
  filters: {
    events: [
      {
        type: 'nft_mint',
        asset_identifier: 'SP...COLL.nft::collectible',
      },
    ],
  },
  action: { type: 'http_post', url: 'https://api.myapp.com/mints' },
  options: {
    enable_on_registration: true,
    expire_after_occurrences: 1000, // Auto-expire after 1000 mints
  },
});
```

---

## Next Steps

:::next-steps
* [SDK Quickstart](/tools/chainhook/quickstart): Start building with the SDK
* [Filter Reference](/tools/chainhook/reference/filters): Explore all event filters
:::
