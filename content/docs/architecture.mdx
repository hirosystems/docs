---
title: Tool architecture & workflows
description: How Hiro's tools work together to create powerful Bitcoin development workflows
---

Understanding how our tools fit together helps you choose the right combination for your project and use them effectively.

Think of Hiro's tools as specialized components that connect to form complete development workflows. Each tool has a specific job, but they're designed to work seamlessly together.

## The Hiro toolchain

Our tools fall into five main categories that mirror your development journey:

### 1. Development Tools
**Build and test locally**
- **[Clarinet](/tools/clarinet)**: Local blockchain environment for smart contracts
- **[Clarinet JS SDK](/tools/clarinet-js-sdk)**: JavaScript testing framework
- **[VS Code Extension](/features#vs-code-extension)**: IDE support with syntax highlighting and debugging

### 2. Integration Libraries  
**Connect your app to the blockchain**
- **[Stacks.js](/reference/stacks-js)**: Local account integration and transaction broadcasting and building
- **[Stacks Connect](/reference/stacks-connect)**: Frontend wallet integration

### 3. Data Infrastructure
**Process and stream blockchain data**
- **[Chainhook](/tools/chainhook)**: Real-time event streaming from blockchain
- **[Bitcoin Indexer](/bitcoin/indexer)**: Custom blockchain data indexing

### 4. Data APIs
**Access blockchain data efficiently**  
- **[Stacks API](/apis/stacks-blockchain-api)**: Complete blockchain data (accounts, transactions, contracts)
- **[Ordinals API](/apis/ordinals-api)**: Bitcoin inscription data
- **[Runes API](/apis/runes-api)**: Bitcoin fungible token data
- **[Token Metadata API](/apis/token-metadata-api)**: NFT and token metadata

### 5. Platform Services
**Hosted services**
- **[Chainhook](/tools/chainhook)**: Real-time event streaming from blockchain
- **[Contract Monitoring](/tools/contract-monitoring)**: Track contract execution and set up alerts


## Mental models for tool combinations

Different types of applications need different tool combinations. Here are the most common patterns:

### Smart Contract DApp
**Goal**: Users interact with your contracts through a web interface

**Tools you'll use**:
- Clarinet → develop and test contracts locally
- Clarinet JS SDK → write comprehensive unit tests  
- Stacks Connect / Stacks.js → connect wallet and build transactions
- Stacks API → display account balances and transaction history

**Data flow**: Clarinet (development) → Stacks Connect / Stacks.js (frontend) → Stacks API (data)

### Event-Driven Application
**Goal**: Your backend reacts to blockchain events in real-time

**Tools you'll use**:
- Previous stack + Chainhook → stream events to your backend
- Database → store processed event data
- Your API → serve computed data to frontend

**Data flow**: Blockchain → Chainhook → Your Backend → Your API → Frontend

### Bitcoin Meta-Protocol App  
**Goal**: Build on Bitcoin L1 (Ordinals, Runes, custom protocols)

**Tools you'll use**:
- Bitcoin Indexer → create custom indexes for your protocol
- Ordinals/Runes APIs → access existing Bitcoin data

**Data flow**: Bitcoin Indexer → Your API → Frontend

### Production Platform
**Goal**: Enterprise-scale application with monitoring and automation

**Tools you'll use**:
- All previous tools
- Contract Monitoring → track on-chain activity
- Hosted Devnets → team development and CI/CD

**Data flow**: Integrated development, deployment, and monitoring pipeline

## Tool interaction patterns

Understanding how tools connect helps you architect better applications:

{/* This is not true yet, but perhaps soon with TS client. */}

{/* ### Clarinet ↔ Stacks.js
Develop contracts in Clarinet, then use the same contract interfaces in Stacks.js. Your frontend tests run against the same local environment.

```typescript
// Same contract calls work in both environments
const result = await makeContractCall({
  contractAddress: 'ST123...',
  contractName: 'my-contract',
  functionName: 'transfer-tokens'
});
``` */}

### APIs ↔ Everything
All our APIs share consistent data formats. Learn one, use them all.

```javascript
// Same patterns across all APIs
const stxData = await fetch('/v1/address/ST123.../stx');
const ordinalsData = await fetch('/ordinals/v1/address/ST123...');
const runesData = await fetch('/runes/v1/address/ST123...');
```

### Chainhook ↔ APIs
Chainhook streams the same data our APIs serve, just in real-time. Use APIs for queries, Chainhook for reactions or more complex data processing needs.

```json
// Chainhook event matches API transaction format
{
  "transaction": {
    "tx_id": "0x123...",
    "contract_call": {
      "contract_id": "ST123...my-contract",
      "function_name": "transfer"
    }
  }
}
```

### Platform ↔ Local Tools
The platform hosts the same tools you run locally. Deploy your Clarinet project directly to hosted devnets.

## Tool selection guide

**Starting a new project?**
1. Begin with Clarinet for contracts
2. Add Clarinet JS SDK for testing  
3. Use Stacks.js when you build a frontend
4. Consider Chainhook if you need real-time features

**Need blockchain data?**
- **Account info**: Stacks API
- **Bitcoin inscriptions**: Ordinals API  
- **Bitcoin tokens**: Runes API
- **Custom data**: Build with Bitcoin Indexer

**Going to production?**
- **Self-hosted**: Use our open source tools
- **Managed hosting**: Hiro Platform handles infrastructure
- **Hybrid**: Hosted APIs + self-hosted application logic

**Building on Bitcoin L1?**
- **Existing protocols**: Use Ordinals/Runes APIs
- **New protocols**: Start with Bitcoin Indexer

## Quick decision trees

Use these to choose the right tools for your project:

### What type of app are you building?

**Smart contract DApp** → Clarinet + Stacks.js + Stacks API  
**Bitcoin L1 app** → Bitcoin Indexer + Ordinals/Runes APIs  
**Data analytics** → APIs + Chainhook + your database  
**Enterprise platform** → Full stack + Hiro Platform

### What's your deployment strategy?

**Local development** → All tools run on your machine  
**Team collaboration** → Hosted devnets for shared environments  
**Production scale** → Hiro Platform for infrastructure  
**Custom hosting** → Self-host our open source tools

### How much data do you need?

**Basic queries** → Use our APIs directly  
**Real-time updates** → Add Chainhook for event streaming  
**Custom indexing** → Bitcoin Indexer for specialized data  
**High volume** → Consider caching and custom infrastructure

## Next steps

Ready to start building? Here's your path forward:

**New to Hiro tools?** → [Set up your environment](/docs/setting-up-your-environment/installing-prerequisites) to get everything installed.

**Building smart contracts?** → [Create your first Clarinet project](/docs/local-development/creating-clarinet-project) to start coding.

**Need to see all our tools?** → [Browse the complete feature list](/docs/features) for detailed capability overviews.

**Ready for advanced patterns?** → Explore specialized guides:
- [Event-driven architecture with Chainhook](/docs/event-driven-architecture/creating-predicates)
- [API integration patterns](/docs/working-with-apis/api-fundamentals) 
- [Frontend wallet integration](/docs/frontend-applications/wallet-integration)