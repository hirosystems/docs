---
title: filter
description: Filter elements from a list based on a predicate function in Clarity smart contracts.
---

## Function Signature

```clarity
(filter <function> <sequence>)
```

- Input: 
  - `<function>`: A function that takes one argument and returns a boolean
  - `<sequence>`: A list, buffer, or string to iterate over
- Output: A new list containing only the elements for which the function returned true

## Why it matters

The `filter` function is crucial for:

1. Selectively processing elements from a list based on specific criteria.
2. Removing unwanted elements from a list without modifying the original.
3. Implementing complex data filtering logic within smart contracts.
4. Enhancing data manipulation capabilities in list processing.

## When to use it

Use `filter` when you need to:

- Create a subset of a list based on certain conditions.
- Remove elements from a list that don't meet specific criteria.
- Implement data validation or selection logic on lists.
- Prepare data for further processing by removing irrelevant elements.

## Best Practices

- Ensure the predicate function is efficient, especially for large lists.
- Use `filter` in combination with other list functions like `map` or `fold` for complex list operations.
- Be mindful of gas costs when filtering large lists.
- Consider using `filter` with `define-private` functions for reusable filtering logic.

## Practical Example: Filtering Even Numbers

Let's implement a function that filters even numbers from a list:

```clarity
(define-private (is-even (num int))
  (is-eq (mod num 2) 0)
)

(define-read-only (get-even-numbers (numbers (list 10 int)))
  (filter is-even numbers)
)

;; Usage
(get-even-numbers (list 1 2 3 4 5 6 7 8 9 10)) ;; Returns (2 4 6 8 10)
```

This example demonstrates:
1. Defining a private helper function `is-even` to check if a number is even.
2. Using `filter` with the `is-even` function to create a new list of even numbers.
3. Applying the filter operation to a list of integers.

## Common Pitfalls

1. Forgetting that `filter` creates a new list and does not modify the original.
2. Using a computationally expensive predicate function, which could lead to high gas costs.
3. Not considering the potential for an empty result list if no elements match the predicate.

## Related Functions

- `map`: Applies a function to each element in a list, transforming the elements.
- `fold`: Reduces a list to a single value by applying a function to each element.
- `len`: Can be used to check the length of the resulting filtered list.

## Conclusion

The `filter` function is a powerful tool for list manipulation in Clarity smart contracts. It allows you to create refined subsets of data based on specific criteria, enhancing the contract's ability to process and analyze list-based information. When used effectively, `filter` can significantly improve the efficiency and clarity of list operations in smart contracts.
