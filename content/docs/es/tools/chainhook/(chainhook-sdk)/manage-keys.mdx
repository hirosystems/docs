---
title: Gestionar Claves
description: Rotar secretos de consumidor y validar cada entrega de Chainhook
---
## Lo que aprenderás

:::objectives
* Crear/rotar un secreto de consumidor Chainhook.
* Valida las solicitudes de webhook verificando el `Authorization` header.
:::

## Requisitos previos

:::prerequisites
* Clave API de Hiro almacenada como `CHAINHOOKS_API_KEY`.
* Chainhook UUID you want to protect.
* Runtime de Node.js (el ejemplo usa Fastify).
:::

## Validación de solicitudes de webhook con un secreto de consumidor

Los chainhooks adjuntan un `Authorization: Bearer <secret>` encabezado a cada intento de webhook, proporcionándote un simple protocolo de intercambio de secreto compartido.

1. Rotar el secreto con `await client.rotateConsumerSecret(chainhookUuid)` (o el `/chainhooks/{uuid}/secret` API) cada vez que necesites un nuevo token.
2. Persistir lo devuelto `secret` en tu administrador de secretos y recárgalo al inicio del proceso o a través de un bucle de actualización corto.
3. Rechazar las entregas de webhook cuyas `Authorization` el encabezado no es igual a `Bearer <current-secret>`.

### Rotar/crear secreto del consumidor

```ts
import { ChainhooksClient, CHAINHOOKS_BASE_URL } from '@hirosystems/chainhooks-client';

const client = new ChainhooksClient({
  baseUrl: CHAINHOOKS_BASE_URL.mainnet, // or .testnet / custom URL
  apiKey: process.env.CHAINHOOKS_API_KEY!,
});

let consumerSecret: string = await client.rotateConsumerSecret(chainhookUuid).secret;
```

### Servidor Fastify de ejemplo

```ts
import Fastify from 'fastify';

const server = Fastify();

server.post('/webhook', async (request, reply) => {
  if (!consumerSecret) {
    reply.code(503).send({ error: 'consumer secret unavailable' });
    return;
  }

  const authHeader = request.headers.authorization;
  if (authHeader !== `Bearer ${consumerSecret}`) {
    reply.code(401).send({ error: 'invalid consumer secret' });
    return;
  }

  const event = request.body;
  console.log(`received chainhook ${event.chainhook.uuid}`);
  reply.code(204).send();
});

await server.listen({ port: Number(process.env.PORT) || 3000 });
```
