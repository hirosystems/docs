---
title: Integración de sBTC con Clarinet
sidebarTitle: Integración de sBTC
description: En esta guía, aprenderás cómo interactuar con el contrato sBTC de la red principal en tu proyecto Clarinet.
---
:::objectives
* Agregar contratos inteligentes de sBTC a tu proyecto Clarinet
* Probar contratos con financiación automática de sBTC en devnet
* Trabaja con sBTC como un token fungible SIP-010
* Desplegar contratos sBTC en testnet y mainnet
:::

:::prerequisites
* Se requiere Clarinet 2.15.0 o posterior para la integración automática de sBTC.
:::

## Inicio rápido

<Steps>
  <Step>
    ### Agregue sBTC a su proyecto

    Agregue los contratos inteligentes de sBTC a los requisitos de su proyecto Clarinet:

    ```terminal
    $ clarinet requirements add SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-deposit
    ```

    Este comando agrega tres contratos esenciales:

    * **`sbtc-token`** - El contrato de token SIP-010 principal
    * **`sbtc-registry`** - Registro para gestionar la configuración de sBTC
    * **`sbtc-deposit`** - Maneja operaciones de depósito y retiro

    Cuando Clarinet detecta estos contratos, automáticamente financia tus billeteras de prueba con sBTC para realizar pruebas.
  </Step>

  <Step>
    ### Crear un contrato habilitado para sBTC

    Construye un mercado simple de NFT que acepte pagos en sBTC:

    ```clarity contracts/nft-marketplace.clar
    ;; Define NFT
    (define-non-fungible-token marketplace-nft uint)

    ;; Price in sats (smallest sBTC unit)
    (define-data-var mint-price uint u100)
    (define-data-var next-id uint u0)

    ;; Mint NFT with sBTC payment
    (define-public (mint-with-sbtc)
      (begin
        ;; Transfer sBTC from buyer to contract
        (try! (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token transfer
          (var-get mint-price)
          tx-sender
          (as-contract tx-sender)
          none
        ))

        ;; Mint the NFT
        (try! (nft-mint? marketplace-nft (var-get next-id) tx-sender))

        ;; Increment ID for next mint
        (ok (var-set next-id (+ (var-get next-id) u1)))
      )
    )

    ;; Check sBTC balance
    (define-read-only (get-sbtc-balance (owner principal))
      (contract-call? 'SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token get-balance owner)
    )
    ```
  </Step>

  <Step>
    ### Prueba en la consola de Clarinet

    Clarinet financia automáticamente las billeteras de prueba con sBTC. Prueba tu contrato:

    ```terminal
    $ clarinet console
    ```

    Verifique los saldos de la billetera y acuñe un NFT:

    ```clarity
    ;; Check deployer's sBTC balance (auto-funded)
    (contract-call? .nft-marketplace get-sbtc-balance tx-sender)

    ;; Mint NFT with wallet_1 (also auto-funded)
    (contract-call? .nft-marketplace mint-with-sbtc)

    ;; Verify NFT ownership
    (nft-get-owner? .nft-marketplace marketplace-nft u0)
    ```
  </Step>

  <Step>
    ### Escribir pruebas unitarias

    Prueba la funcionalidad de sBTC en tus pruebas de TypeScript:

    ```ts tests/nft-marketplace.test.ts
    import { describe, expect, it } from "vitest";
    import { Cl } from "@stacks/transactions";

    describe("NFT Marketplace", () => {
      it("mints NFT with sBTC payment", () => {
        const mintPrice = 100;

        // Get initial sBTC balance
        const initialBalance = simnet.callReadOnlyFn(
          "nft-marketplace",
          "get-sbtc-balance",
          [Cl.standardPrincipal(accounts.get("wallet_1")!.address)],
          accounts.get("wallet_1")!.address
        );

        // Mint NFT
        const mintResult = simnet.callPublicFn(
          "nft-marketplace",
          "mint-with-sbtc",
          [],
          accounts.get("wallet_1")!.address
        );

        expect(mintResult.result).toBeOk();

        // Verify sBTC was transferred
        const finalBalance = simnet.callReadOnlyFn(
          "nft-marketplace",
          "get-sbtc-balance",
          [Cl.standardPrincipal(accounts.get("wallet_1")!.address)],
          accounts.get("wallet_1")!.address
        );

        expect(Number(Cl.parse(finalBalance.result))).toBeLessThan(
          Number(Cl.parse(initialBalance.result))
        );
      });
    });
    ```
  </Step>

  <Step>
    ### Desplegar en testnet

    En testnet, Clarinet automáticamente remapea a los contratos oficiales de sBTC de Hiro:

    ```terminal
    $ clarinet deployments generate --testnet
    ```

    Su plan de implementación muestra las direcciones reasignadas:

    ```yaml deployments/default.testnet-plan.yaml
    ---
    id: 0
    name: Testnet deployment
    network: testnet
    stacks-node: "https://api.testnet.hiro.so"
    bitcoin-node: "http://blockstream.info"
    plan:
      batches:
        - id: 0
          transactions:
            - requirement-publish:
                contract-id: ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-token
                remap-sender: SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4
                remap-principals:
                  SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4: ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT
                cost: 50000
                path: "./.cache/requirements/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token.clar"
    ```

    Desplegar en testnet:

    ```terminal
    $ clarinet deployments apply -p deployments/default.testnet-plan.yaml
    ```
  </Step>
</Steps>

## Patrones comunes

## Trabajando con direcciones sBTC

Clarinet maneja el mapeo de direcciones de contratos sBTC a través de las redes:

| Red | Dirección del Contrato sBTC |
|---------|---------------------|
| Simnet/Devnet | `SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token` |
| Red de pruebas | `ST1F7QA2MDF17S807EPA36TSS8AMEFY4KA9TVGWXT.sbtc-token` |
| Mainnet | La dirección del contrato permanece sin cambios |

Su código de contrato siempre hace referencia a la dirección de simnet. Clarinet automáticamente remapea durante el despliegue.

## Acuñación manual de sBTC en pruebas unitarias

Aunque Clarinet 2.15.0+ financia automáticamente las billeteras con sBTC en devnet, es posible que necesite acuñar manualmente sBTC en pruebas unitarias para escenarios específicos:

### Acuñando sBTC usando la dirección del implementador

El contrato del token sBTC permite que la dirección del implementador (multisig) acuñe tokens. Utiliza este enfoque en tus pruebas:

```typescript tests/manual-sbtc-mint.test.ts -c
import { describe, expect, it } from "vitest";
import { Cl } from "@stacks/transactions";

describe("Manual sBTC minting", () => {
  it("mints sBTC to custom addresses", () => {
    // The sBTC multisig address that can mint
    const sbtcDeployer = "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4";
    const customWallet = "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM";

    // Mint 1000 sats to custom wallet
    const mintResult = simnet.callPublicFn(
      "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token",
      "mint",
      [
        Cl.uint(1000),              // amount in sats
        Cl.principal(customWallet)   // recipient
      ],
      sbtcDeployer                   // sender must be deployer
    );

    expect(mintResult.result).toBeOk(Cl.bool(true));

    // Verify balance
    const balance = simnet.callReadOnlyFn(
      "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token",
      "get-balance",
      [Cl.principal(customWallet)],
      customWallet
    );

    expect(balance.result).toBeOk(Cl.uint(1000));
  });
});
```

### Pruebas con simulación de ejecución en mainnet

Al utilizar la simulación de ejecución de mainnet, puedes acuñar sBTC utilizando el multisig real de mainnet:

```typescript -c
const mainnetMultisig = "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4";
const mainnetWallet = "SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR";

// Mint sBTC to any mainnet address
simnet.callPublicFn(
  "SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token",
  "mint",
  [Cl.uint(100000), Cl.principal(mainnetWallet)],
  mainnetMultisig
);
```

Este enfoque es útil para:

* Probando cantidades específicas de sBTC
* Simulando diferentes saldos de billeteras
* Probando casos límite con cantidades exactas de tokens
* Pruebas de integración con contratos de mainnet
