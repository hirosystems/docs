---
title: Uso de feeds de precios de Pyth
description: Guía completa para integrar datos de precios de mercado en tiempo real de Pyth Network en tus aplicaciones de Stacks.
---
import { File, Folder, Files } from 'fumadocs-ui/components/files';
import { Steps, Step } from '@/components/steps';
import { ArrowRight, Check } from 'lucide-react';

## Visión general

Esta guía completa te lleva paso a paso por la integración [Red Pyth](https://pyth.network)El oráculo descentralizado de  para datos de precios en tiempo real en tus aplicaciones de Stacks. Construiremos un ejemplo completo: un NFT que solo se puede acuñar pagando exactamente $100 en sBTC.

:::callout
La integración del protocolo Pyth está disponible como Beta en las redes testnet y mainnet. Es mantenida por Trust Machines y proporciona acceso a feeds de precios en tiempo real para BTC, STX, ETH y USDC.
:::

## Descripción general de la arquitectura

Pyth Network utiliza un único **basado en extracción** diseño de oracle:

<Mermaid
  chart="
graph LR
A[Pyth Network] -->|Price Data| B[Wormhole]
B -->|VAA Messages| C[Hermes API]
C -->|Fetch VAA| D[Your Frontend]
D -->|Submit VAA + TX| E[Stacks Chain]
E -->|Verify & Update| F[Pyth Oracle Contract]
F -->|Fresh Price| G[Your Contract]

style A fill:#FF7733,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
style C fill:#B3D9FF,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
style D fill:#F5F5F5,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
style E fill:#B3D9FF,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
style F fill:#C2EBC4,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c
style G fill:#C2EBC4,stroke:#0d0c0c,stroke-width:2px,color:#0d0c0c"
/>

A diferencia de los oráculos basados en push que actualizan continuamente los precios en la cadena, Pyth permite a los usuarios obtener y enviar actualizaciones de precios solo cuando es necesario, haciéndolo más eficiente en términos de gas.

## Lo que estamos construyendo

Crearemos un "Club Benjamin" - un NFT exclusivo que cuesta exactamente $100 en sBTC para acuñar. Esto demuestra:

* Leyendo precios BTC/USD en tiempo real desde Pyth
* Conversión entre cantidades de USD y criptomonedas
* Manejo de aritmética de punto fijo
* Construyendo una integración frontend completa
* Probando contratos dependientes de oráculos

<Files className="font-mono pointer-events-none bg-background">
  <Folder name="benjamin-club" defaultOpen>
    <Folder name="contracts" defaultOpen>
      <File name="benjamin-club.clar" />

      <File name="sbtc-token.clar" />
    </Folder>

    <Folder name="frontend" defaultOpen>
      <File name="MintButton.tsx" />

      <File name="pyth-service.ts" />
    </Folder>

    <Folder name="tests" defaultOpen>
      <File name="benjamin-club.test.ts" />

      <File name="mock-pyth-oracle.clar" />
    </Folder>

    <File name="Clarinet.toml" />
  </Folder>
</Files>

## Pasos de implementación

<Steps>
  <Step>
    ### Escribir el contrato inteligente

    Primero, implementa el contrato de Clarity que lee los datos de precios de Pyth:

    ```clarity contracts/benjamin-club.clar
    ;; Benjamin Club - $100 NFT minting contract
    (define-constant CONTRACT-OWNER tx-sender)
    (define-constant BENJAMIN-COST u100) ;; $100 USD
    (define-constant ERR-INSUFFICIENT-FUNDS (err u100))
    (define-constant ERR-PRICE-UPDATE-FAILED (err u101))
    (define-constant ERR-STALE-PRICE (err u102))

    ;; Pyth oracle contracts
    (define-constant PYTH-ORACLE 'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-oracle-v3)
    (define-constant PYTH-STORAGE 'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-storage-v3)
    (define-constant PYTH-DECODER 'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-pnau-decoder-v2)
    (define-constant WORMHOLE-CORE 'SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.wormhole-core-v3)

    ;; BTC price feed ID
    (define-constant BTC-USD-FEED-ID 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43)

    ;; NFT definition
    (define-non-fungible-token benjamin-nft uint)
    (define-data-var last-token-id uint u0)

    (define-public (mint-for-hundred-dollars (price-feed-bytes (buff 8192)))
      (let (
        ;; Update price feed with fresh VAA data
        (update-result (try! (contract-call? PYTH-ORACLE
          verify-and-update-price-feeds price-feed-bytes {
            pyth-storage-contract: PYTH-STORAGE,
            pyth-decoder-contract: PYTH-DECODER,
            wormhole-core-contract: WORMHOLE-CORE
          })))

        ;; Get the updated BTC price
        (price-data (try! (contract-call? PYTH-ORACLE
          get-price BTC-USD-FEED-ID PYTH-STORAGE)))

        ;; Process the price data
        (btc-price (process-price-data price-data))

        ;; Calculate required sBTC amount for $100
        (required-sbtc (calculate-sbtc-amount btc-price))

        ;; Get user's sBTC balance
        (user-balance (unwrap!
          (contract-call? .sbtc-token get-balance tx-sender)
          ERR-INSUFFICIENT-FUNDS))
      )
        ;; Verify price is fresh (less than 5 minutes old)
        (try! (verify-price-freshness price-data))

        ;; Verify user has enough sBTC
        (asserts! (>= user-balance required-sbtc) ERR-INSUFFICIENT-FUNDS)

        ;; Transfer sBTC from user
        (try! (contract-call? .sbtc-token transfer
          required-sbtc tx-sender (as-contract tx-sender) none))

        ;; Mint the NFT
        (let ((token-id (+ (var-get last-token-id) u1)))
          (try! (nft-mint? benjamin-nft token-id tx-sender))
          (var-set last-token-id token-id)
          (ok { token-id: token-id, price-paid: required-sbtc }))
      )
    )

    (define-private (process-price-data (price-data {
      price-identifier: (buff 32),
      price: int,
      conf: uint,
      expo: int,
      ema-price: int,
      ema-conf: uint,
      publish-time: uint,
      prev-publish-time: uint
    }))
      (let (
        ;; Convert fixed-point to regular number
        ;; For expo = -8, divide by 10^8
        (denominator (pow u10 (to-uint (* (get expo price-data) -1))))
        (price-uint (to-uint (get price price-data)))
      )
        (/ price-uint denominator)
      )
    )

    (define-private (calculate-sbtc-amount (btc-price-usd uint))
      ;; $100 in sats = (100 * 10^8) / btc-price-usd
      (/ (* BENJAMIN-COST u100000000) btc-price-usd)
    )

    (define-private (verify-price-freshness (price-data (tuple)))
      (let (
        (current-time (unwrap-panic (get-block-info? time block-height)))
        (publish-time (get publish-time price-data))
        (max-age u300) ;; 5 minutes
      )
        (if (<= (- current-time publish-time) max-age)
          (ok true)
          ERR-STALE-PRICE)
      )
    )
    ```

    Para una explicación detallada de los componentes del contrato, consulte nuestra [Guía de integración de Clarity](/resources/clarity/external-data).
  </Step>

  <Step>
    ### Construir la integración del frontend

    Crea un servicio para obtener datos de precios de Pyth:

    ```typescript frontend/pyth-service.ts
    import { PriceServiceConnection } from '@pythnetwork/price-service-client';
    import { Buffer } from 'buffer';

    const PRICE_FEEDS = {
      BTC_USD: '0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43'
    };

    export async function fetchBTCPriceVAA(): Promise<string> {
      const pythClient = new PriceServiceConnection(
        'https://hermes.pyth.network',
        { priceFeedRequestConfig: { binary: true } }
      );

      const vaas = await pythClient.getLatestVaas([PRICE_FEEDS.BTC_USD]);
      const messageBuffer = Buffer.from(vaas[0], 'base64');

      return `0x${messageBuffer.toString('hex')}`;
    }
    ```

    Luego crea un componente de React para acuñar:

    ```typescript frontend/MintButton.tsx
    import { request } from '@stacks/connect';
    import { Cl, Pc } from '@stacks/transactions';
    import { fetchBTCPriceVAA } from './pyth-service';
    import { useState } from 'react';

    export function MintBenjaminNFT() {
      const [loading, setLoading] = useState(false);

      const handleMint = async () => {
        setLoading(true);
        try {
          // Fetch fresh price data
          const priceVAA = await fetchBTCPriceVAA();

          // Create post-conditions for safety
          const postConditions = [
            // Oracle fee (1 uSTX max)
            Pc.principal('SP1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRCBGD7R').willSendLte(1).ustx()
          ];

          // Call contract using request
          const response = await request('stx_callContract', {
            contract: 'SP1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRCBGD7R.benjamin-club',
            functionName: 'mint-for-hundred-dollars',
            functionArgs: [Cl.bufferFromHex(priceVAA.slice(2))],
            postConditions,
            postConditionMode: 'deny',
            network: 'mainnet'
          });

          alert(`NFT minted! Transaction ID: ${response.txid}`);
        } catch (error) {
          console.error('Minting failed:', error);
          alert('Failed to mint NFT');
        } finally {
          setLoading(false);
        }
      };

      return (
        <button
          onClick={handleMint}
          disabled={loading}
          className="px-6 py-3 bg-blue-600 text-white rounded-lg"
        >
          {loading ? 'Fetching price...' : 'Mint Benjamin NFT ($100)'}
        </button>
      );
    }
    ```

    Para obtener detalles completos sobre la integración del frontend, consulte nuestra [Guía de integración de Stacks.js](/reference/stacks.js/pyth-oracle-integration).
  </Step>

  <Step>
    ### Prueba tu implementación

    Escriba pruebas exhaustivas utilizando Clarinet:

    ```typescript tests/benjamin-club.test.ts
    import { describe, expect, it } from "vitest";
    import { Cl } from '@stacks/transactions';

    describe("Benjamin Club Tests", () => {
      it("should calculate correct sBTC amount", () => {
        // Set mock BTC price to $100,000
        simnet.callPublicFn(
          "mock-pyth-oracle",
          "set-mock-price",
          [
            Cl.bufferFromHex(BTC_FEED_ID),
            Cl.int(10000000000000), // $100,000 with 8 decimals
            Cl.int(-8)
          ],
          deployer
        );

        // Test price calculation
        const response = simnet.callReadOnlyFn(
          "benjamin-club",
          "get-required-sbtc-amount",
          [],
          wallet1
        );

        // $100 at $100k/BTC = 0.001 BTC = 100,000 sats
        expect(response.result).toBeOk(Cl.uint(100000));
      });
    });
    ```

    Para estrategias de prueba avanzadas, incluyendo simulación de mainnet, consulte nuestra [Guía de prueba del clarinete](/tools/clarinet/pyth-oracle-integration).
  </Step>
</Steps>

## Mejores prácticas

### Frescura de precios

Siempre verifica que los datos de precios sean lo suficientemente recientes para tu caso de uso:

```clarity
(define-constant MAX-PRICE-AGE u300) ;; 5 minutes

(define-private (verify-price-freshness (price-data (tuple)))
  (let ((age (- block-height (get publish-time price-data))))
    (asserts! (<= age MAX-PRICE-AGE) ERR-STALE-PRICE)
    (ok true)))
```

### Manejo de errores

Implementar un manejo integral de errores para fallos del oráculo:

```typescript
try {
  const vaa = await fetchBTCPriceVAA();
  // Process VAA...
} catch (error) {
  if (error.message.includes('Network')) {
    // Retry with exponential backoff
    await retryWithBackoff(() => fetchBTCPriceVAA());
  } else {
    // Handle other errors
    throw error;
  }
}
```

### Optimización de gas

Actualizar múltiples precios en lote cuando sea posible:

```clarity
(define-public (update-multiple-prices
  (btc-vaa (buff 8192))
  (eth-vaa (buff 8192))
  (stx-vaa (buff 8192)))
  (let ((all-vaas (concat btc-vaa (concat eth-vaa stx-vaa))))
    (contract-call? PYTH-ORACLE verify-and-update-price-feeds all-vaas params)))
```

## Solución de problemas

### Problemas comunes

<Accordion type="single" collapsible>
  <AccordionItem value="errores-vaa">
    <AccordionTrigger>La verificación de VAA falla</AccordionTrigger>

    <AccordionContent>
      Asegúrate de obtener datos VAA con `binary: true` opción y convertir correctamente de base64 a hexadecimal. El VAA debe ser reciente (normalmente dentro de los 5 minutos).
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="conversión-de-precios">
    <AccordionTrigger>Los cálculos de precios son incorrectos</AccordionTrigger>

    <AccordionContent>
      Verifica que estés manejando el exponente correctamente. Pyth utiliza representación de punto fijo donde el precio real = precio\_bruto \* 10^exponente. Para exponentes negativos, divide por 10^(-exponente).
    </AccordionContent>
  </AccordionItem>

  <AccordionItem value="problemas-de-gas">
    <AccordionTrigger>La transacción se queda sin gas</AccordionTrigger>

    <AccordionContent>
      Las actualizaciones de oráculos pueden consumir mucho gas. Asegúrate de que tus límites de gas tengan en cuenta tanto la actualización del oráculo como la lógica de tu contrato. Considera almacenar en caché los precios cuando múltiples operaciones necesiten el mismo precio.
    </AccordionContent>
  </AccordionItem>
</Accordion>

## Consideraciones de seguridad

1. **Manipulación de precios**: Utiliza siempre intervalos de confianza e implementa comprobaciones de cordura
2. **Adelantamiento**: Considere utilizar esquemas de compromiso-revelación para operaciones sensibles al precio
3. **Tarifas de Oracle**: Establecer condiciones posteriores apropiadas para limitar la exposición a tarifas
4. **Rancidez**: Rechazar precios más antiguos que tu umbral de seguridad

## Referencia rápida

### Direcciones de contrato

| Red | Contrato | Dirección |
|---------|----------|---------|
| Mainnet | pyth-oracle-v3 | `SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-oracle-v3` |
| Red principal | pyth-storage-v3 | `SP3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-storage-v3` |
| Red de pruebas | pyth-oracle-v3 | `ST3R4F6C1J3JQWWCVZ3S7FRRYPMYG6ZW6RZK31FXY.pyth-oracle-v3` |

### IDs de fuentes de precios

| Activo | ID del Feed |
|--------|-------------|
| BTC/USD | `0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43` |
| STX/USD | `0xec7a775f46379b5e943c3526b1c8d54cd49749176b0b98e02dde68d1bd335c17` |
| ETH/USD | `0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace` |
| USDC/USD | `0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a` |

## Recursos adicionales

* [Documentación de Pyth Network](https://docs.pyth.network)
* [Integración de Pyth en Trust Machines](https://github.com/Trust-Machines/stacks-pyth-bridge)
* [Especificación VAA de Wormhole](https://wormhole.com/docs/protocol/infrastructure/vaas/)

:::next-steps
- [Inmersión profunda en Clarity](/resources/clarity/external-data): Patrones y optimizaciones avanzadas de oráculo
- [Inmersión profunda en el frontend](/reference/stacks.js/pyth-oracle-integration): Construyendo interfaces de usuario de oráculos listas para producción
:::
